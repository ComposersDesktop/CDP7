/*
 * Copyright (c) 1983-2013 Trevor Wishart and Composers Desktop Project Ltd
 * http://www.trevorwishart.co.uk
 * http://www.composersdesktop.com
 *
 This file is part of the CDP System.

    The CDP System is free software; you can redistribute it
    and/or modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    The CDP System is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with the CDP System; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA
 *
 */



#include <stdio.h>
#include <standalone.h>
#include <string.h>

static void RoomReverbFormat(void);
const char* cdp_version = "6.1.0";

/******************************** TKUSAGE_OTHER ********************************/

int main(int argc, char *argv[])
{
	int process, mode;
	if(argc==2 && (strcmp(argv[1],"--version") == 0)) {
		fprintf(stdout,"%s\n",cdp_version);
		fflush(stdout);
		return 0;
	}
	if(argc!=3) {
		fprintf(stdout,"ERROR: Error in usage program tkusage_other\n");
		return -1;
	}
	if(sscanf(argv[1],"%d",&process)!=1) {
		fprintf(stdout,"ERROR: Failed to read process number in tkusage_other\n");
		return -1;
	}
	if(sscanf(argv[2],"%d",&mode)!=1) {
		fprintf(stdout,"ERROR: Failed to read process number in tkusage_other\n");
		return -1;
	}
	switch(process) {
	case(TAPDELAY):
		fprintf(stdout,"INFO: STEREO MULTI-TAPPED DELAY WITH SPATIAL POSITIONING OF DELAYS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DELAY TIMES AMPS (& POSITIONS). A Text Datafile.\n");
		fprintf(stdout,"INFO:       Each line has either 2 values (TIME , AMPLITUDE of one delay).\n");
		fprintf(stdout,"INFO:                    or 3 values (third value specifies spatial POSITION of this delay in the stereo space).\n");
		fprintf(stdout,"INFO:       TIMES (seconds) must be increasing. Duplicate times are ignored.\n");
		fprintf(stdout,"INFO:       A zero time (no delay) overrides the mix parameter,\n");		fprintf(stdout,"INFO:       and determines the level and pan of the (effectively mono) input.\n");
		fprintf(stdout,"INFO:       AMP values must be in the range 0.0 to 1.0\n");
		fprintf(stdout,"INFO:       Empty lines and lines starting with a semi-colon (e.g. comments) are permitted.\n");
		fprintf(stdout,"INFO:       If a Position value is used in any line, outfile will be stereo.\n");
		fprintf(stdout,"INFO:       POSITION values are nominally in the range -1 to +1:     0 = centre.\n");
		fprintf(stdout,"INFO:       If all position values are 0, the output will be mono.\n");
		fprintf(stdout,"INFO:       Values beyond these limits result in attenuation according to the\n");
		fprintf(stdout,"INFO:       inverse-square law, to suggest distance beyond the speakers.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT GAIN ...........Gain applied to output signal.\n");
		fprintf(stdout,"INFO: FEEDBACK ..............Proportion of output signal fed back into input.\n");
		fprintf(stdout,"INFO:                                       (Negative values invert phase of feedback).\n");
		fprintf(stdout,"INFO: SOURCE SIGNAL IN MIX...Proportion of original src sound mixed with the delay-output.\n");
		fprintf(stdout,"INFO: DECAY TAIL DURATION....Time allowed for delays to decay to zero.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(RMRESP):
		fprintf(stdout,"INFO: GENERATE ROOM RESPONSE DATA SUITABLE FOR USE WITH REVERB PROGRAMS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LIVENESS...................... degree of reflection from each surface.\n");
		fprintf(stdout,"INFO: NUMBER OF REFLECTIONS......... number of reflections from each surface.\n");
		fprintf(stdout,"INFO:            (WARNING: high values will create extremely long data files!).\n");
		fprintf(stdout,"INFO: ROOM LENGTH, WIDTH, HEIGHT.... The size of the room, in metres.\n");
		fprintf(stdout,"INFO: SRC POSITION, LENGTHWAYS, WIDTHWAYS & HEIGHT within the room, in metres.\n");;
		fprintf(stdout,"INFO: LISTENER POSITION LENGTHWAYS, WIDTHWAYS, & HEIGHT within the room, in metres.\n");;
		fprintf(stdout,"INFO: PEAK AMPLITUDE OF DATA\n");
		fprintf(stdout,"INFO: REFLECTION TIME RESOLUTION (MS).\n");;
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT is a text datafile suitable for use with MULTIPLE-DELAYS, REVERB or ROOM REVERB processes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB: The first output time is non-zero.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(RMVERB):
		fprintf(stdout,"INFO: MULTI-CHANNEL REVERB WITH ROOM SIMULATION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: An OPTIONAL Text Datafile. (Enter '0' to use preset values instead)......\n");
		RoomReverbFormat();
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ROOM SIZE......................1 small, 2 medium, 3 large.\n");
		fprintf(stdout,"INFO: DENSE REVERB GAIN..............level of the dense reverberation.\n");
		fprintf(stdout,"INFO: SOURCE SIGNAL IN MIX...........Proportion of original src sound mixed with the delay-output.\n");
		fprintf(stdout,"INFO: FEEDBACK ......................Proportion of output signal fed back into input.\n");
		fprintf(stdout,"INFO: AIR-ABSORPTION FILTER CUTOFF...Cutoff frq (Hz) of low pass filter modelling air absorption.\n");
		fprintf(stdout,"INFO:                                       (typically 2500Hz for Large room, 4200Hz for small: set to ZERO for NO absorption).\n");
		fprintf(stdout,"INFO: LOWPASS REVERB-INPUT CUTOFF....Cutoff frq (Hz) of low pass filter on input to reverb.\n");
		fprintf(stdout,"INFO:                                       (set to ZERO for NO filtering of input).\n");
		fprintf(stdout,"INFO: DECAY TAIL DURATION............Time allowed for delays to decay to zero.\n");
		fprintf(stdout,"INFO: LOWPASS INPUT CUTOFF...........Cutoff frq (Hz) of low pass filter on source.\n");
		fprintf(stdout,"INFO: HIGHPASS INPUT CUTOFF..........Cutoff frq (Hz) of high pass filter on source.\n");
		fprintf(stdout,"INFO: REVERB PREDELAY (MS)...........Force delay to start at specified time.\n");
		fprintf(stdout,"INFO: NUMBER OF OUTPUT CHANNELS......Defaults to stereo.\n");
		fprintf(stdout,"INFO: DOUBLE AIR-ABSORPTION.........(Reduces reverb time: Increase Feedback to compensate).\n");
		fprintf(stdout,"INFO: FLOATING POINT OUTPUT FILE.....or not.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXMULTI):
		fprintf(stdout,"INFO: MULTI-CHANNEL MIXING FOR UP TO 64-CHANNELS, WITH CHANNEL CROSS-THREADING.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIXING STARTTIME...starttime in mix (to start mixing later than zero).\n");
		fprintf(stdout,"INFO: MIXING ENDTIME.....endtime in mix (to stop mix before its true end).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Note that the START and END params intended for mix TESTING purposes only.\n");
		fprintf(stdout,"INFO: If you want to keep output from such a testmix, you should TOPNTAIL it.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ATTENUATION.......reduce the mix level, if necessary.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIXFILE FORMAT FOR MULTICHANNEL MIXING:\n");
		fprintf(stdout,"INFO: The first line indicates the number of output channels.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The ensuing lines have the following format   e.g.\n");
		fprintf(stdout,"INFO: snd1.wav 0.0 4  1:1 .5 2:2 .5 3:3 .5 4:4 .5\n");
		fprintf(stdout,"INFO: snd2.wav 2.0 4  1:1 .25 2:1 .25 3:1 .25 4:1 .25\n");
		fprintf(stdout,"INFO: snd3.wav 2.0 16 2:3 .25 4:1 .25\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Each line consists of:\n");
		fprintf(stdout,"INFO: 1)  Name of a soundfile\n");
		fprintf(stdout,"INFO: 2)  Entry time of that sound in the mix\n");
		fprintf(stdout,"INFO: 3)  Channel count of the input sound\n");
		fprintf(stdout,"INFO: 4)  A ROUTING CODE for the input channels, followed by a level for that routing.\n");
		fprintf(stdout,"INFO: The code consists of a number indicating the input channel, a colon, and\n");
		fprintf(stdout,"INFO: a number indicating the output channel in the final mix.\n");
		fprintf(stdout,"INFO: In line 1 (1:1 2:2 3:3 4:4) each input channel goes to the corresponding output channel\n");
		fprintf(stdout,"INFO: In line 2 (1:1 2:1 3:1 4:1) all input channels are mixed into channel 1 of the output\n");
		fprintf(stdout,"INFO: In line 3 (2:3 4:1) channels 2 & 4 ONLY of input, are routed to chans 3 & 1 of the output\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: So the input channels can be threaded to any output channel desired.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ANALJOIN):
		fprintf(stdout,"INFO: SPLICE TOGETHER A SEQUENCE OF ANALYSIS FILES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NO PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PTOBRK):
		fprintf(stdout,"INFO: CONVERT BINARY PITCH DATA TO BRKPNT FILE, RETAINING NO-PITCH MARKERS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: TIME, IN MS, THAT ANY STRETCH OF PITCH-DATA MUST PERSIST, TO BE VALID.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_STRETCH):
		fprintf(stdout,"INFO: TIME-STRETCH A SOUND USING PITCH-SYNCHRONOUS ENVELOPED GRAINS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO: 2) STRETCH FACTOR\n");
		fprintf(stdout,"INFO: 3) NUMBER OF GRAINS PER BLOCK: Block preserved as-is during process.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Timestretching alters pitch: twice as long, down an octave.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_DUPL):
		fprintf(stdout,"INFO: DUPLICATE PITCH-SYNCHRONOUS ENVELOPED GRAINS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2) NUMBER OF DUPLICATIONS.\n");
		fprintf(stdout,"INFO: 3) NUMBER OF GRAINS PER BLOCK: Block preserved as-is during process.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_DEL):
		fprintf(stdout,"INFO: DELETE PITCH-SYNCHRONOUS ENVELOPED GRAINS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2) ONE IN HOW MANY BLOCKS TO KEEP.\n");
		fprintf(stdout,"INFO: 3) NUMBER OF GRAINS PER BLOCK: Block preserved as-is during process.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_STRFILL):
		fprintf(stdout,"INFO: TIME-STRETCH A SOUND USING PITCH-SYNCHRONOUS ENVELOPED GRAINS, AND GRAIN DUPLICATION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2) STRETCH FACTOR\n");
		fprintf(stdout,"INFO: 3) NUMBER OF GRAINS PER BLOCK: Block preserved as-is during process.\n");
		fprintf(stdout,"INFO: 4) TRANSPOSITION IN SEMITONES:\n");
		fprintf(stdout,"INFO: Only certain harmonics-related transpositions work.\n");
		fprintf(stdout,"INFO: and these interact in strange ways with the time-stretch parameter,");
		fprintf(stdout,"INFO: sometimes producing octaves.\n");
		fprintf(stdout,"INFO:         e.g. with a time-stretch of 2, these transpositions work...\n");
		fprintf(stdout,"INFO:         -12 (octave down), 12 (octave up)  24 (2 octaves up).\n");
		fprintf(stdout,"INFO:         7 (major 5th), 16 (octave + major 3rd) 19 (octave + 5th)  22 (octave + minor 7th).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_FREEZE):
		fprintf(stdout,"INFO: GRAB ONE OR MORE PITCH-SYNCHRONISED GRAINS AND USE TO CONSTRUCT A NEW SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2) TIME IN SOURCE WHERE GRAIN(S) GRABBED.\n");
		fprintf(stdout,"INFO: 3) DURATION OF FILE TO BE CREATED.\n");
		fprintf(stdout,"INFO:       Duration oz ZERO will cause a single (block of) grain(s) to be grabbed,\n");
		fprintf(stdout,"INFO: 4) NUMBER OF GRAINS TO GRAB: IF more than 1, this set is used as a block.\n");
		fprintf(stdout,"INFO: 5) DENSITY (PITCH TRANSPOSITION)\n");
		fprintf(stdout,"INFO:       Density 2      Grains overlap so there are always 2 grains playing at once.\n");
		fprintf(stdout,"INFO:       Density 3      Grains overlap so there are always 3 grains playing at once.\n");
		fprintf(stdout,"INFO:       Density 0.5    One grain followed by one gap, of same duration.\n");
		fprintf(stdout,"INFO:       Density 0.25   One grain followed by a gap of three times the duration.\n");
		fprintf(stdout,"INFO:       With a single (or very few) grain(s), Density can be equivalent to transposition ratio.\n");
		fprintf(stdout,"INFO:       For pitched grains, the fundamental is transposed, but not the spectrum.\n");
		fprintf(stdout,"INFO:       Very high fixed densities produce a file with just 2 thumps (only).\n");
		fprintf(stdout,"INFO:       Glissandos through densities above c 2 produce pitch steps rather than a smooth glide.\n");
		fprintf(stdout,"INFO: 6) SPECTRAL TRANSPOSITION: transposes the spectrum but not the fundamental.\n");
		fprintf(stdout,"INFO:       The particular way in which Density and Spectral Transpositions operate\n");
		fprintf(stdout,"INFO:       depends on the size of segments (no of grains) you choose,\n");
		fprintf(stdout,"INFO:       and the particular nature of the grains (pitched, noisy etc.).\n");
		fprintf(stdout,"INFO: 7) RANDOMISATION of the position of the output grain(blocks).\n");
		fprintf(stdout,"INFO:       Randomisation adds noise to any clearly-pitched grain-source.\n");
		fprintf(stdout,"INFO: 8) OVERALL GAIN (If density is > 1.0, gain may need to be reduced).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_CHOP):
		fprintf(stdout,"INFO: REMOVE PITCH-SYNCHRONOUD GRAINS FROM A FILE, AT SPECIFIED TIMES,\n");
		fprintf(stdout,"INFO: AND KEEP THE REMAINING SEPARATED PARTS OF THE SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2) TIME - GRAIN-COUNT FILE.\n");
		fprintf(stdout,"INFO:       Each pair specifies time at which grains are to be found\n");
		fprintf(stdout,"INFO:       and how many grains to omit between the cut sections.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Outputs are the sections of sound left behind once these grains are taken out.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_INTERP):
		fprintf(stdout,"INFO: INTERPOLATE BETWEEN PITCH-SYNCHRONOUS GRAINS,\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) Sustain Duration of first grain.\n");
		fprintf(stdout,"INFO: 2) Duration of Interpolation.\n");
		fprintf(stdout,"INFO: 3) Sustain Duration of final grain.\n");
		fprintf(stdout,"INFO: 4) VIBRATO FREQUENCY.\n");
		fprintf(stdout,"INFO: 5) VIBRATO DEPTH.\n");
		fprintf(stdout,"INFO: 6) TREMOLO FREQUENCY.\n");
		fprintf(stdout,"INFO: 7) TREMOLO DEPTH.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB This process assumes that the input files are single pitch-synchronous grains.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_FEATURES):
		fprintf(stdout,"INFO: ADD NEW FEATURES TO SOUND ANALYSED INTO PITCH-SYNCHRONOUS GRAINS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) PITCH SHIFTING IS ACCOMPANIED BY TIMEWARPING.\n");
		fprintf(stdout,"INFO:       If the pitch goes up, the sound gets shorter, if down, longer.\n");
		fprintf(stdout,"INFO: 2) PITCH SHIFTING IS ACCOMPANIED BY PITCH_DIVISION.\n");
		fprintf(stdout,"INFO:       Results in 2 pitches, the highest at the specified transposition.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2)  NUMBER OF GRAINS PER BLOCK: Block preserved as-is during process.\n");
		fprintf(stdout,"INFO: 3)  TRANSPOSITION (semitones).\n");
		fprintf(stdout,"INFO: 4)  VIBRATO FREQUENCY.\n");
		fprintf(stdout,"INFO: 5)  VIBRATO DEPTH (semitones).\n");
		fprintf(stdout,"INFO: 6)  SPECTRAL TRANSPOSITION (semitones).\n");
		fprintf(stdout,"INFO: 7)  HOARSENESS smaller values (c.0.04) are most effective.\n");
		fprintf(stdout,"INFO: 8)  ATTENUATION.\n");
		fprintf(stdout,"INFO: 9)  FOF-STRETCHING:    N.B. This TURNS OFF spectral transposition.\n");
		fprintf(stdout,"INFO: 10) SUBHARMONIC NUMBER: Divides pitch-frequency to produce subharmonic. Must be at least 2.\n");
		fprintf(stdout,"INFO: 11) SUBHARMONIC LEVEL:  Level of any subharmonic introduced.\n");
		fprintf(stdout,"INFO: 12) ALTERNATIVE ALGORITHM FOR FOF_STRETCH.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_SYNTH):
		fprintf(stdout,"INFO: USE VOCAL FOFS AS CONTOUR ON SYNTHESIZED SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WITH A FIXED BAND OF OSCILLATORS.\n");
		fprintf(stdout,"INFO:       Data file is exactly like that for a User-defined Filterbank.\n");
		fprintf(stdout,"INFO: 1)    BANDS AS FRQ (HZ):..Filter-pitches as frq in Hz.....paired with an amplitude.\n");
		fprintf(stdout,"INFO: 2)    BANDS AS MIDI:......Filter-pitches as MIDI values.....paired with an amplitude.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WITH A TIME-VARYING BANK OF OSCILLATORS.\n");
		fprintf(stdout,"INFO:       Data file is exactly like that for a User-defined Time-varying Filterbank.\n");
		fprintf(stdout,"INFO: 3)    BANDS AS FRQ (HZ):..Filter-pitches as frq in Hz.\n");
		fprintf(stdout,"INFO: 4)    BANDS AS MIDI:......Filter-pitches as MIDI values.\n");
		fprintf(stdout,"INFO:       For full details, see 'User-defined Time-varying Filterbank' information.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 5) WITH NOISE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  TABLE OF FREQUENCIES AND AMPLITUDES, DEFINING A BANK OF OSCILLATORS.\n");
		fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 3)  DEPTH OF FOF CONTOURING (1 TOTAL .... 0, NONE AT ALL).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_IMPOSE):
		fprintf(stdout,"INFO: IMPOSE VOCAL FOFS IN 1ST SOUND ON A 2ND INPUT SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2)  DEPTH OF FOF CONTOURING (1 TOTAL .... 0, NONE AT ALL).\n");
		fprintf(stdout,"INFO: 3)  WINDOW SIZE (mS) FOR ENVELOPE TRACKING 2ND INPUT SOUND.\n");
		fprintf(stdout,"INFO: 4)  GATE LEVEL (dB) BELOW WHICH 2ND INPUT SIGNAL IS TO BE IGNORED.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_SPLIT):
		fprintf(stdout,"INFO: SPLIT VOCAL SOUND INTO SUBHARMONICS AND UPWARD-TRANSPOSED FEATURES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2)  SUBHARMONIC NUMBER (DIVIDES VOICE FREQUENCY).\n");
		fprintf(stdout,"INFO: 3)  UPWARD TRANSPOSITION (SEMITONES).\n");
		fprintf(stdout,"INFO: 4)  SUPPRESSION OF UPWARD-TRANSPOSED COMPONENTS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_SPACE):
		fprintf(stdout,"INFO: SEPARATE FOFS OF A MONO VOCAL SOUND IN STEREO SPACE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2)  SUBHARMONIC NUMBER (DIVIDES VOICE FREQUENCY).\n");
		fprintf(stdout,"INFO: 3)  SPATIAL SEPARATION.\n");
		fprintf(stdout,"INFO:           0  NO SEPARATION.\n");
		fprintf(stdout,"INFO:           1  SPLITS ALTERNATELY TO FULL RIGHT/LEFT.\n");
		fprintf(stdout,"INFO:           -1 SPLITS ALTERNATELY TO FULL LEFT/RIGHT.\n");
		fprintf(stdout,"INFO: 4)  LEFT/RIGHT RELATIVE LEVEL.\n");
		fprintf(stdout,"INFO:           RL = 1.0  LEFT & RIGHT LEVELS EQUAL.\n");
		fprintf(stdout,"INFO:           RL > 1.0  LEFT SIGNAL DIVIDED BY RL. BIAS TO RIGHT\n");
		fprintf(stdout,"INFO:           RL < 1.0  RIGHT SIGNAL MULTIPLIED BY RL. BIAS TO LEFT\n");
		fprintf(stdout,"INFO: 5)  SUPPRESS HIGH COMPONENTS.\n");
		fprintf(stdout,"INFO:           0 = NONE.\n");
		fprintf(stdout,"INFO:           1 = COMPLETE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_INTERLEAVE):
		fprintf(stdout,"INFO: INTERLEAVE FOFS OF 2 SOUNDS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE FOR 1ST SND, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE FOR 2ND SND, SIMILARLY.\n");
		fprintf(stdout,"INFO: 3)  NO OF FOFS TREATED AS A UNIT FOR THE PROCESS.\n");
		fprintf(stdout,"INFO: 4)  PITCH BIAS.\n");
		fprintf(stdout,"INFO:           0  NO BIAS.\n");
		fprintf(stdout,"INFO:           1  PITCH FORCED TOWARDS THAT OF 1ST SND.\n");
		fprintf(stdout,"INFO:           -1 PITCH FORCED TOWARDS THAT OF 2ND SND.\n");
		fprintf(stdout,"INFO: 5)  RELATIVE LEVEL.\n");
		fprintf(stdout,"INFO:           RL = 1.0  1ST & 2ND SOUNDS OF EQUAL LEVEL.\n");
		fprintf(stdout,"INFO:           RL > 1.0  2ND SOUND LEVEL DIVIDED BY RL. BIAS TO 1ST\n");
		fprintf(stdout,"INFO:           RL < 1.0  1ST SOUND LEVEL MULTIPLIED BY RL. BIAS TO 2ND\n");
		fprintf(stdout,"INFO: 6)  RELATIVE WEIGHT.\n");
		fprintf(stdout,"INFO:           RW = 1.0  1ST & 2ND SOUNDS ALTERNATE.\n");
		fprintf(stdout,"INFO:           RL > 1.0  1ST SOUND OCCURS RL TIMES MORE THAN 2ND\n");
		fprintf(stdout,"INFO:           RL < 1.0  2ND SOUND OCCURS 1/RL TIMES MORE THAN 1ST\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_REPLACE):
		fprintf(stdout,"INFO: COMBINE FOFS OF 1ST SOUND WITH PITCH OF 2ND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE FOR 1ST SND, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE FOR 2ND SND, SIMILARLY.\n");
		fprintf(stdout,"INFO: 3)  NO OF FOFS TREATED AS A UNIT FOR THE PROCESS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_EXTEND):
		fprintf(stdout,"INFO: EXTEND A SOUND BY FREEZING IT AT A SPECIFIED TIME, USING A PITCH-SYNCD GRAIN.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:        Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2)  TIME IN SOURCE WHERE GRAIN(S) GRABBED.\n");
		fprintf(stdout,"INFO: 3)  DURATION OF TOTAL FILE ONCE IT IS STRETCHED.\n");
		fprintf(stdout,"INFO: 4)  NUMBER OF GRAINS TO GRAB: IF more than 1, this set is used as a block.\n");
		fprintf(stdout,"INFO: 5)  VIBRATO FREQUENCY.\n");
		fprintf(stdout,"INFO: 6)  VIBRATO DEPTH (semitones).\n");
		fprintf(stdout,"INFO: 7)  GRAIN PITCH TRANSPOSITION (semitones).\n");
		fprintf(stdout,"INFO:        In any brkpntfiles used here, zero time refers to start of \n");
		fprintf(stdout,"INFO:        bring expanded, and NOT (necessarily) to start of sound.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 8)  SMOOTH FOFS.\n");
		fprintf(stdout,"INFO:        Imposes a smoothing window on the extracted FOF(s)\n");
		fprintf(stdout,"INFO:        attempting to remove any high frequency buzz effects.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_EXTEND2):
		fprintf(stdout,"INFO: EXTEND A SOUND BY FREEZING IT AT A SPECIFIED TIME, USING A PITCH-SYNCD GRAIN.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) TIME AT WHICH GRAIN STARTS.\n");
		fprintf(stdout,"INFO: 2) TIME AT WHICH GRAIN ENDS.\n");
		fprintf(stdout,"INFO: 3) DURATION OF TOTAL FILE ONCE IT IS STRETCHED.\n");
		fprintf(stdout,"INFO: 4)  VIBRATO FREQUENCY.\n");
		fprintf(stdout,"INFO: 5)  VIBRATO DEPTH (semitones).\n");
		fprintf(stdout,"INFO: 6)  NUDGE: GRAIN-TIMES MOVED FORWARD OR BACK BY 'NUDGE' ZERO-CROSSINGS.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_LOCATE):
		fprintf(stdout,"INFO: LOCATE EXACT TIME OF START OF GRAIN, NEAREST TO A GIVEN TIME.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2) TIME.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_CUT):
		fprintf(stdout,"INFO: CUT SOUND AT GRAIN START NEAREST TO SPECIFIED TIME.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) KEEP SOUND BEFORE SPECIFIED GRAIN-TIME.\n");
		fprintf(stdout,"INFO: 2) KEEP SOUND AT AND AFTER SPECIFIED GRAIN-TIME.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 2) TIME.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ONEFORM_GET):
		fprintf(stdout,"INFO: EXTRACT FORMANT AT A SPECIFIED TIME, FROM A FORMANT FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) TIME AT WHICH TO EXTRACT FORMANT.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ONEFORM_PUT):
		fprintf(stdout,"INFO: IMPOSE ON SPECTRUM IN AN ANALYSIS FILE\n");
		fprintf(stdout,"INFO: THE SPECTRAL ENVELOPE IN A SINGLE-FORMANT FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REPLACE FORMANTS......New formants REPLACE existing formant envelope.\n");
		fprintf(stdout,"INFO: SUPERIMPOSE FORMANTS..New formants IMPOSED ON TOP OF existing formants.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW FRQ LIMIT...frq, below which spectrum is set to zero.\n");
		fprintf(stdout,"INFO: HIGH FRQ LIMIT..frq, above which spectrum is set to zero.\n");
		fprintf(stdout,"INFO: GAIN............adjustment to spectrum loudness (normally < 1.0).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ONEFORM_COMBINE):
		fprintf(stdout,"INFO: GENERATE SPECTRUM FROM BINARY-PITCHFILE & SINGLE-FORMANT-DATA.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: outfile is analysis file which must be resynthesized to hear.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(NEWGATE):
		fprintf(stdout,"INFO: GATE A SIGNAL TO ZERO WHERE IT FALLS BELOW A CERTAIN LEVEL.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GATE LEVEL...in decibels.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SPEC_REMOVE):
		fprintf(stdout,"INFO: REMOVE SPECIFIC PITCH (AREA) FROM A SPECTRUM, OR REMOVE COMPONENTS NOT OF PITCH (AREA).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: 1) REMOVE PITCH.\n");
		fprintf(stdout,"INFO: 2) REMOVE NON_PITCH.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MINIMUM PITCH (MIDI).\n");
		fprintf(stdout,"INFO: MAXIMUM PITCH (MIDI).\n");
		fprintf(stdout,"INFO: MODE 1) FREQUENCY ABOVE WHICH HARMONICS ARE NOT REMOVED (HZ).\n");
		fprintf(stdout,"INFO: MODE 2) FREQUENCY ABOVE WHICH HARMONICS ARE NOT RETAINED (HZ).\n");
		fprintf(stdout,"INFO: ATENUATION OF SPECIFIED COMPONENTS.\n");
		fprintf(stdout,"INFO:          (1 = full attenuation, 0 = no attenuation).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Process removes all components, and their harmonics, in the given pitch range,\n");
		fprintf(stdout,"INFO: as far as the given frequency limit.\n");
		fprintf(stdout,"INFO: (Or, mode 2, removes all components which are NOT in the pitch range or that of its harmonics)\n");
		fprintf(stdout,"INFO: as far as the given frequency limit.\n");
		fprintf(stdout,"INFO: Pitch range of an octave or more will remove (retain) all spectral components\n");
		fprintf(stdout,"INFO: between the lower pitch and the upper frequency limit\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PREFIXSIL):
		fprintf(stdout,"INFO: ADD SILENCE AT START OF SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION of silence to add.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(STRANS):
		fprintf(stdout,"INFO: CHANGE SPEED & PITCH OF MULTICHANNEL SOURCE SOUND, OR CREATE VIBRATO.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) SPEED CHANGE...............also changing sound pitch.\n");
		fprintf(stdout,"INFO: 2) SPEED CHANGE IN SEMITONES..speed shift given in semitones.\n");
		fprintf(stdout,"INFO:    For BOTH these modes, brkpnt times are infiletimes, unless flagged as outfiletimes.\n");
		fprintf(stdout,"INFO: 3) ACCELERATE SOURCE TO GIVEN SPEED..speed shift given as multiplier.\n");
		fprintf(stdout,"INFO: 4) VIBRATO THE SOURCE....with given speed and depth (possibly time-varying).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODE 1. Speed change as a speed multiplier.\n");
		fprintf(stdout,"INFO: MODE 2. Speed change in semitones.\n");
		fprintf(stdout,"INFO: MODE 3\n");
		fprintf(stdout,"INFO:      ACCELERATION as speed multiplier at the goal time.\n");
		fprintf(stdout,"INFO:      GOAL TIME is speed at which 'acceleration' speed is achieved.\n");
		fprintf(stdout,"INFO:      START TIME is time in source where acceleration begins.\n");
		fprintf(stdout,"INFO: MODE 4\n");
		fprintf(stdout,"INFO:      VIBRATO FREQUENCY is rate of vibrato, in Hz (can vary over time).\n");
		fprintf(stdout,"INFO:      VIBRATO DEPTH is depth of vibrato, in semitones (can vary over time).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PSOW_REINF):
		fprintf(stdout,"INFO: REINFORCE HARMONICS OR ADD INHARMONIC CONSTITUENTS IN SOUND WITH (VOCAL) FOFS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) REINFORCE HARMONICS.\n");
		fprintf(stdout,"INFO: 2) ADD INHARMONIC ELEMENTS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  TABLE OF HARMONIC NUMBERS AND AMPLITUDES.\n");
		fprintf(stdout,"INFO:         These define which harmonics are added to the original source, (range 2 to 256)\n");
		fprintf(stdout,"INFO:         and what their relative-levels are (src assumed to be at level 1.0) (range >0  to 16).\n");
		fprintf(stdout,"INFO:         The output is scaled down in level, if clipping might occur.\n");
		fprintf(stdout,"INFO:         In MODE 2, these 'harmonics' can be FRACTIONAL.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in some places).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In MODE 1\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DON'T DUPLICATE HARMONICS : FOFs corresponding to higher harmonics which\n");
		fprintf(stdout,"INFO: coincide with FOFs corresponding to lower harmonics, are omitted.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In MODE 1\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DELAY OF HARMONICS: mS delay applied (progressively) to harmonics.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In MODE 2\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WEIGTH : Determines how long inharmonic constituents are sustained.\n");
		fprintf(stdout,"INFO: In some circumstances very high weights may cause the memory to overflow.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PARTIALS_HARM):
		fprintf(stdout,"INFO: EXTRACT RELATIVE AMPLITUDES OF PARTIALS IN A PITCHED SOURCE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) SINGLE-WINDOW ANALYSIS FILE -> FRQ DATA.\n");
		fprintf(stdout,"INFO: 2) SINGLE-WINDOW ANALYSIS FILE -> MIDI DATA.\n");
		fprintf(stdout,"INFO: 3) MULTI-WINDOW ANALYSIS FILE -> FRQ DATA.\n");
		fprintf(stdout,"INFO: 4) MULTI-WINDOW ANALYSIS FILE -> MIDI DATA.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  FUNDAMENTAL FREQUENCY:  Fundamental frequency of the window.\n");
		fprintf(stdout,"INFO: 2)  THRESHOLD AMPLITUDE:  Relative level below which partials are ignored.\n");
		fprintf(stdout,"INFO: 3)  TIME OF WINDOW:  (Modes 3 & 4 only) Time, in analysis file, where partials to be found.\n");
		fprintf(stdout,"INFO: 4)  OUTPUT IN VARIPARTIALS FILTER FORMAT:  Outputs data in file-format for varipartials filter.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB Assumes the input file is clearly pitched (at least in the relevant place).\n");
		break;
	case(SPECROSS):
		fprintf(stdout,"INFO: INTERPOLATE PARTIALS OF PITCHED SRC2 TOWARDS THOSE OF PITCHED SRC 1,\n");
		fprintf(stdout,"INFO: RETAINING THE DURATION OF SRC2, AND THE ATTACK LOCATION OF SRC1.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IN-TUNE RANGE:  Semitone range within which harmonics 'in tune'.\n");
		fprintf(stdout,"INFO: MIN WINDOWS TO CONFIRM PITCH:   Minimum number of adjacent windows that must be pitched,\n");
		fprintf(stdout,"INFO:                  for a pitch-value to be registered.\n");
		fprintf(stdout,"INFO: SIGNAL TO NOISE RATIO:  Signal to noise ratio, in decibels.\n");
		fprintf(stdout,"INFO:                  Windows which fall at or below this level, relative to the maximum level in the sound,\n");
		fprintf(stdout,"INFO:                  are assumed to be noise, & any detected pitch is ignored.\n");
		fprintf(stdout,"INFO: VALID HARMONICS COUNT:  Number of the 8 loudest peaks in spectrum which must be harmonics\n");
		fprintf(stdout,"INFO:                  to confirm that the sound is pitched: Default 5.\n");
		fprintf(stdout,"INFO: LOW PITCH LIMIT:  Lowest acceptable frequency (Hz) at which a pitch value is acceptable.\n");
		fprintf(stdout,"INFO: HIGH PITCH LIMIT:  Highest acceptable frequency (Hz) at which a pitch value is acceptable.\n");
		fprintf(stdout,"INFO: PARTIAL THRESHOLD AMPLITUDE:  The threshold amplitude is measured relative to the loudest partial in the window.\n");
		fprintf(stdout,"INFO:                  Any (possible) partial data which falls below this level is ignored.\n");
		fprintf(stdout,"INFO: OUTPUT LEVEL:  Level of the output spectrum. Vary only if reapplying src1 to several src2s,\n");
		fprintf(stdout,"INFO:                  when the relative levels of the src2s are important.\n");
		fprintf(stdout,"INFO: SPECTRAL_INTERPOLATION:  Degree of interpolation between Src2 and Src1.\n");
		fprintf(stdout,"INFO:                  Zero gives the original (cleaned) src 2, 1 gives src1 only.\n");
		fprintf(stdout,"INFO:                  The degree of interpolation may vary (with time) through the sound.\n");
		fprintf(stdout,"INFO:                  Times in any breakpoint file will be scaled to the duration of Src1.\n");
		fprintf(stdout,"INFO: RETAIN FILE2 CONTOUR UNDER FILE1 CONTOUR so amplitude fluctuations of File1 still apparent at max interpolation.\n");
		fprintf(stdout,"INFO: EXTEND 1ST STABLE PITCH OF FILE1 TO START so very start of File 1 is assumed to be pitched.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB Assumes the input files are clearly pitched (at least in the relevant place).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: A typical application would use a (relatively) stable-pitched source for Src1,\n");
		fprintf(stdout,"INFO: while Src2 might vary in pitch (e.g. a speaking voice), but this is not essential.\n");
		break;
	case(LUCIER_GETF):
		fprintf(stdout,"INFO: EXTRACT ROOM-RESONANCE FROM A RECORDING AND CREATE A FILTER-DATA FILE FOR 'FILTER VARIBANK'.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN ROOM DIMENSION (METRES):  Enter ZERO to ignore roomsize.\n");
		fprintf(stdout,"INFO: ROLLOFF INTERVAL: Interval (in semitones) over which resonance fades to zero, above the max resonance frq dictated by room dimensions.\n");
		fprintf(stdout,"INFO: LOW_FRQ_CUTOFF:      Ignore resonances below this frequency.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Longer recordings give better results.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(LUCIER_GET):
		fprintf(stdout,"INFO: EXTRACT ROOM-RESONANCE FROM A RECORDING AND CREATE A CORRESPONDING ANALYSIS DATA FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN ROOM DIMENSION (METRES):  Enter ZERO to ignore roomsize.\n");
		fprintf(stdout,"INFO: ROLLOFF INTERVAL: Interval (in semitones) over which resonance fades to zero, above the max resonance frq dictated by room dimensions.\n");
		fprintf(stdout,"INFO: RESOLVE LOW FRQS: Attempt to resolve low frequency resonances more accurately.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(LUCIER_PUT):
		fprintf(stdout,"INFO: IMPOSE ROOM-RESONANCE FROM A RECORDING (EXTRACTED USING 'LUCIER GET') ONTO AN ANALYSIS FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RESONANCE COUNT:      Number of times the room resonance is (cumulatively) added to the sound.\n");
		fprintf(stdout,"INFO: OCTAVE DUPLICATION ROLLOFF:  If NOT set to zero (default), room resonance is duplicated at higher octaves,\n");
		fprintf(stdout,"INFO:          with resonance level multiplied (cumulatively) by this attenuation from 8va to 8va.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(LUCIER_DEL):
		fprintf(stdout,"INFO: ATTEMPT TO REMOVE ROOM-RESONANCE (EXTRACTED USING 'LUCIER GET') FROM A RECORDING.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SUPPRESSION:   Degree of suppression of room acoustic.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SPECLEAN):
		fprintf(stdout,"INFO: REMOVE PERSISTENT NOISE FROM SPECTRUM, BY COMPARISON WITH AN EXTRACT OF THE NOISE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PERSISTANCE (mS):   Time for which signal in a channel must exceed threshold defined by noise input before it is allowed to pass.\n");
		fprintf(stdout,"INFO: NOISE PREGAIN:          Threshold level for passing clean signal is level of noise signal times this pregain.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SPECTRACT):
		fprintf(stdout,"INFO: REMOVE PERSISTENT NOISE FROM SPECTRUM, BY SUBTRACTING AN EXTRACT OF THE NOISE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PERSISTANCE (mS):   Time for which signal in a channel must exceed threshold defined by noise input before it is allowed to pass.\n");
		fprintf(stdout,"INFO: NOISE PREGAIN:          Threshold level for passing clean signal is level of noise signal times this pregain.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The noise-signal level is also subtracted from any signal exceeding the threshold.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PHASE):
		fprintf(stdout,"INFO: INVERT PHASE, OR ENHANCE STEREO IMAGE BY PHASE CANCELLATION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) INVERT  PHASE OF MONO OR STEREO SIGNAL.\n");
		fprintf(stdout,"INFO: 2) ENHANCE STEREO IMAGE, BY PHASE CANCELLATION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PHASE TRANSFER: (Mode 2 only) Amount of phase-inverted other-channel used to enhance stereo.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(BRKTOPI):
		fprintf(stdout,"INFO: CONVERT TEXT PITCH-DATA TO BINARY PITCH DATA.\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: Pitch data is written to a default format binary file.\n");
		break;
	case(SPECSLICE):
		fprintf(stdout,"INFO: SALAMI-SLICE SPECTRUM INTO (INTERLEAVED) FREQUENCY BANDS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) SLICE SPECTRUM BY ANALYSIS CHANNELS.\n");
		fprintf(stdout,"INFO: 2) SLICE SPECTRUM BY FREQUENCY BANDS.\n");
		fprintf(stdout,"INFO: 3) SLICE SPECTRUM BY PITCH BANDS.\n");
		fprintf(stdout,"INFO: 4) SLICE SPECTRUM BY HARMONICS OF EXTRACTED PITCH.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NUMBER_OF_SLICES : with 3 slices (and 1 channel per slice) Slice-1 = chans 1,4,7...etc   Slice-2 = chans 2,4,8.etc Slice-3 = chans 3,6,9.etc\n");
		fprintf(stdout,"INFO: ANALYSIS_CHANNEL_GROUPING : with 3 slices and grouping 2   Slice-1 = chans 1-2,7-8,13-14...etc   Slice-2 = chans 3-4,9-10..etc Slice-3 = chans 5-6,11-12..etc\n");
		fprintf(stdout,"INFO: SLICE_BANDWIDTH: width of slices in Hz: with Hz 100 and 2 slices: Slice-1 = 0-100Hz + 200-300Hz + 400-500Hz..etc Slice-2 = 100-200Hz + 300-400Hz ..etc\n");
		fprintf(stdout,"INFO: SLICE_WIDTH_IN_SEMITONES: width of slices in semitones.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FOFEX_EX):
		fprintf(stdout,"INFO: EXTRACT AND ORGANISE FOFS IN A SOUND IN ORDER TO RE-USE THEM.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)   EXTRACT ALL FOF(GROUP)S SUBJECT TO EXCLUSIONS, TO SPECIAL FOF-STORAGE SOUNDFILE.\n");     
		fprintf(stdout,"INFO: 2)   EXTRACT SINGLE FOF(GROUP) AT SPECIFIED TIME.\n");     
		fprintf(stdout,"INFO: 3)   EXTRACT ALL FOF(GROUP)S SUBJECT TO EXCLUSIONS, TO SEPARATE SOUNDFILES.\n");     
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES 1 & 3\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  LIST OF SECTIONS OF THE SOURCE (AS PAIRS OF SAMPLETIMES) FROM WHICH ~NO~ FOFS ARE TO BE TAKEN.\n");
		fprintf(stdout,"INFO:           IF THERE ARE NO SUCH AREAS, ENTER THE PARAMETER VALUE \"0\"\n");
		fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES,\n");
		fprintf(stdout,"INFO:     AND DERIVED FROM THE INPUT SOUNDFILE.\n");
		fprintf(stdout,"INFO:       Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 3)  A dB VALUE: FOFS WHICH ARE LESS THAN THIS LEVEL BELOW THE MAX FOF LEVEL ARE REJECTED.\n");
		fprintf(stdout,"INFO:       N.B. A value of ZERO, RETAINS ALL FOFS.\n");
		fprintf(stdout,"INFO: 4)  GROUPED FOFS: Extracts FOFs in (originally adjacent) pairs, triples, etc.\n");
		fprintf(stdout,"INFO: 5)  NO FOF WINDOWING: Cosine shaping is normally applied to starts and ends of FOFs. Set this flag for NO windowing.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IN MODE 1: OUTPUT IS A SPECIAL SOUNDFILE CONTAINING A BANK OF FOFS,\n");
		fprintf(stdout,"INFO:            AND A TEXTFILE PROVIDING INFORMATION ABOUT THE 'FOFBANK'\n");
		fprintf(stdout,"INFO:            THESE CAN BE USED WITH 'FOF reconstruct'\n");
		fprintf(stdout,"INFO: IN MODE 3: OUTPUT IS A SET OF SOUNDFILES EACH CONTAINING A SINGLE (GROUP OF) FOF(S).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODE 2\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  PITCH BREAKPOINT FILE, AS ABOVE\n");
		fprintf(stdout,"INFO: 2)  TIME IN FILE AT WHICH TO EXTRACT FOF(GROUP).\n");
		fprintf(stdout,"INFO: 3)  GROUPED FOFS: EXTRACT A GROUP OF N FOFs.\n");
		fprintf(stdout,"INFO: 4)  NO FOF WINDOWING: AS ABOVE.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FOFEX_CO):
		fprintf(stdout,"INFO: USE A BANK OF FOFS EXTRACTED WITH 'FOF extract' TO SYNTHESIZE A NEW SOUND OVER A PITCHLINE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INPUT FILE----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MUST BE A BANK OF FOFS DERIVED FROM A SOUND USING 'FOF extract'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)   Use 1 FOF.\n");     
		fprintf(stdout,"INFO: 2)   All FOFs superimposed to make output FOF.\n");
		fprintf(stdout,"INFO: 3)   Low FOFs superimposed to make output FOF.\n");
		fprintf(stdout,"INFO: 4)   Midrange FOFs superimposed to make output FOF.\n");
		fprintf(stdout,"INFO: 5)   High FOFs superimposed to make output FOF.\n");
		fprintf(stdout,"INFO: 6)   2 FOFs whose balance varies with pitch.\n");
		fprintf(stdout,"INFO: 7)   3 FOFs whose balance varies with pitch and level.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  TEXTFILE DERIVED FROM 'FOF extract' WHEN YOU CREATED THE (INPUT) FOFBANK.\n");
		fprintf(stdout,"INFO: 2)  PITCH BREAKPOINT FILE, POSSIBLY CONTAINING 'NO-SIGNAL' MARKERS AT SPECIFIC TIMES.\n");
		fprintf(stdout,"INFO:          (But no NO-PITCH markers). Extract the pitch to a binary file, then do the conversion to text.\n");
		fprintf(stdout,"INFO: 3)  LOUDNESS CONTOUR BREAKPOINT DATA, AS TEXT.\n");
		fprintf(stdout,"INFO: 4)  OVERALL GAIN (FOFS may overlap one another).\n");
		fprintf(stdout,"INFO: 5)  THE FOF(S) TO BE USED (their number in the FOFBANK file, counting from 1) - USE \"SOUND VIEW\"\n");
		fprintf(stdout,"INFO: 6)  EQUALISE FOF LEVELS: Adjusts all FOFs to same level before synthesizing output.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GREV_EXTEND):
		fprintf(stdout,"INFO: LOCATE AND EXTEND 'GRAINS', USING ENVELOPE TROUGHS AND ZERO-CROSSING.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: This process locates elements of a sound by searching for troughs in the envelope.\n");
		fprintf(stdout,"INFO: and extends the segment in a coherent way.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW SIZE (MS) .... This determines the size of grains that might be found..\n");
		fprintf(stdout,"INFO: DEPTH OF TROUGHS AS PROPORTION OF PEAK HEIGHT .... e.g. with value .5, troughs between peaks\n");
		fprintf(stdout,"INFO:                    which do not fall to half the peak-height, are ignored\n");
		fprintf(stdout,"INFO: EXTEND_BY_HOW_MUCH .... How much time to add to file, by extending specified grain area\n");
		fprintf(stdout,"INFO: TIME_WHERE_GRAINS_START\n");
		fprintf(stdout,"INFO: TIME_WHERE_GRAINS_END\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PEAKFIND):
		fprintf(stdout,"INFO: LIST TIMES OF PEAKS IN A SOUNDFILE (ESPECIALLY FOR SPEECH).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Locates prominent peaks, separated by troughs, and save a list of their timings.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW SIZE (MS) .... This determines the width of peaks that might be found..\n");
		fprintf(stdout,"INFO: THRESHOLD .... any window falling entirely below this level is assumed to contain no peaks.\n");
		fprintf(stdout,"INFO: Peaks must have a level greater than the  threshold, and be separated by signal lower than the threshold.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If \"threshold\" is set to ZERO, program searches for threshold values appropriate to the local level,\n");
		fprintf(stdout,"INFO: by finding the local maximum in %d windows around the immediate window\n",LOCALMAX_WINDOW);
		fprintf(stdout,"INFO: and then divides this by a factor of %d\n",LOCALPEAK_DECIMATE);
		fprintf(stdout,"INFO: \n");
		break;
	case(CONSTRICT):
		fprintf(stdout,"INFO: SHRINK THE DURATION OF ANY ZERO-LEVEL SEGMENTS IN A SOUND, BY A GIVEN PERCENTAGE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works only with sounds having segments of (completely) zero level.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PERCENTAGE DECIMATION .... Percentage of zero-level segments to delete\n");
		fprintf(stdout,"INFO: Values greater than 100 cause the separated segments to be overlaid.\n");
		fprintf(stdout,"INFO: e.g. 102 overlays very slightly, 200 overlays completely.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(EXPDECAY):
		fprintf(stdout,"INFO: CURTAIL SOUND USING A TRUE EXPONENTIAL ENVELOPE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DECAY START TIME\n");
		fprintf(stdout,"INFO: DECAY END TIME.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PEAKCHOP):
		fprintf(stdout,"INFO: ISOLATE PEAKS IN SOURCE, AND PLAY THEM BACK AT A SPECIFIED TEMPO.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  PLAY BACK PEAKS AT SPECIFIED TEMPO\n");
		fprintf(stdout,"INFO: 2)  OUTPUT PEAK-ISOLATING ENVELOPE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WINDOW SIZE (MS) .... windowsize (in mS) for creating envelope.\n");
		fprintf(stdout,"INFO: PEAK WIDTH (MS).... width of retained peaks (in mS).\n");
		fprintf(stdout,"INFO: RISE TIME (MS).... time for signal to rise to (and fall from) the retained peaks.\n");
		fprintf(stdout,"INFO: TEMPO .... tempo of resulting output as MM (events per minute).\n");
		fprintf(stdout,"INFO: GAIN .... where tempo and peakwidth combine to make events overlap, may be necessary to reduce gain.\n");
		fprintf(stdout,"INFO: TEMPO SCATTER ....randomisation of output times (0-1)\n");
		fprintf(stdout,"INFO: GATE ....level (relative to maximum signal level) below which peaks are ignored (0-1)\n");
		fprintf(stdout,"INFO: LEVELLING .... force peakevent levels to wards level of maximum event.\n");
		fprintf(stdout,"INFO: CENTRING ....centring of envelope on peak (0-1): 0 = at peak at envelope start; 1 = peak at envelope end.\n");
		fprintf(stdout,"INFO: REPETITION .... repeat peakevents in the source.\n");
		fprintf(stdout,"INFO: SKIP BY .... after using a peakevent, miss out the next 'skip by' peakevents.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MCHANPAN):
		fprintf(stdout,"INFO: PAN A FILE OVER MORE THAN 2 OUTPUT CHANNELS.\n");
		fprintf(stdout,"INFO: \n");
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: MODE 1:  MOVE MONO SOUND AROUND A MULTICHANNEL SPACE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PANNING DATA .... is a file containing value triples : time  pan-position  pantype\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:         PAN-POSITION vals lie between (channel) 1 and a max no-of-channels >= 3.\n");
			fprintf(stdout,"INFO:         positions between 0 and 1 are also possible (see below).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:         PANTYPE values can be\n");
			fprintf(stdout,"INFO:         0  = direct pan: pan from 1 to 4 goes directly between lspkrs 1->4\n");
			fprintf(stdout,"INFO:         1  = clockwise rotation: pan from 1 to 4 goes through intermediate lspkrs 1->2->3->4\n");
			fprintf(stdout,"INFO:          (assuming lspks are arranged with numbering increasing in a clockwise direction).\n");
			fprintf(stdout,"INFO:         -1 = anticlockwise rotation: pan from 1 to 4 (with 8 lspkrs) goes 1->8->7->6->5->4\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:         Direct pans must start at a single loudspeaker, so position vals must be integers (and NOT 0).\n");
			fprintf(stdout,"INFO:         Rotations can start and stop anywhere, so position values can be fractional,\n");
			fprintf(stdout,"INFO:         and values between 0 & 1 are positions between maximum lspkr (e.g. 8) and lspkr 1\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE ..... This should not be less than the maximum channel number in the panning data.\n");
			fprintf(stdout,"INFO:         but it can be greater.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: FOCUS ......... Degree to which positioned sound is focused in the loudspeaker.\n");
			fprintf(stdout,"INFO: If focus = 1.0, position set to (e.g.) '2' puts all the signal in lspkr 2.\n");
			fprintf(stdout,"INFO: If focus = 0.9, position '2' puts 90%% of the signal in lspkr 2\n");
			fprintf(stdout,"INFO: and the remainder in the 2 adjacent lspkrs (1 and 3).\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(1):
			fprintf(stdout,"INFO: MODE 2:  SWITCH (SILENCE-SEPARATED) MONO EVENTS IN SOUND BETWEEN SPECIFIED CHANNELS OF OUTPUT.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: OUT-CHANNEL SEQUENCE .... is a file containing a list of output channels.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:         Each output channel in the list will be visited, in turn.\n");
			fprintf(stdout,"INFO:         If the end of the list is reached, the sequence wraps back to the start of the list.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE ..... This should not be less than the maximum channel number in the switching data.\n");
			fprintf(stdout,"INFO:         but it can be greater.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: FOCUS ......... Degree to which positioned sound is focused in the loudspeaker.\n");
			fprintf(stdout,"INFO: If focus = 1.0, position set to (e.g.) '2' puts all the signal in lspkr 2.\n");
			fprintf(stdout,"INFO: If focus = 0.9, position '2' puts 90%% of the signal in lspkr 2\n");
			fprintf(stdout,"INFO: and the remainder in the 2 adjacent lspkrs (1 and 3).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM DURATION OF SILENCES ..... minimum duration (mS) of consecutive zero-samples\n");
			fprintf(stdout,"INFO:          to constitute a silent 'gap' between peak-events.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(2):
			fprintf(stdout,"INFO: MODE 3:  SPREAD SUCCESSIVE (SILENCE-SEPARATED) MONO EVENTS ON DIFFERENT NUMBERS OF CHANNELS.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Events are spread over specified output channels.\n");
			fprintf(stdout,"INFO: If the centre, width or depth of the spread are changing in time,\n");
			fprintf(stdout,"INFO: the placement of events changes only at the onset of a new event in the input.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CENTRE OF SPREAD ....... Channel from which spreading radiates.\n");
			fprintf(stdout,"INFO: CHANNEL SPREAD ......... Total Number of channels over which spreading extends.\n");
			fprintf(stdout,"INFO: DEPTH OF SPREAD FRONT .. Number of channels (on each side) activated behind spreading front.\n");
			fprintf(stdout,"INFO: LEVEL ROLLOFF WITH ADDED CHANNELS .... Level compensation for addition of new output channels.\n");
			fprintf(stdout,"INFO:                       0, No rolloff, all channels go up to full level as they are added.\n");
			fprintf(stdout,"INFO:                       1, Full rolloff, level falls to 1/N for N channels of output.\n");
			fprintf(stdout,"INFO:                       Intermediate values are possible.\n");
			fprintf(stdout,"INFO: MINIMUM DURATION OF SILENCES ..... minimum duration (mS) of consecutive zero-samples\n");
			fprintf(stdout,"INFO:          to constitute a silent 'gap' between peak-events.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CENTRE, SPREAD and DEPTH can vary over time.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(3):
			fprintf(stdout,"INFO: MODE 4:  SPREAD SOUND GRADUALLY OVER DIFFERENT NUMBERS OF CHANNELS (MONO OR STEREO INPUT).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Events are spread over specified output channels.\n");
			fprintf(stdout,"INFO: If the centre, width or depth of the spread are changing in time,\n");
			fprintf(stdout,"INFO: the placement of events changes continuously.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CENTRE OF SPREAD ....... Channel from which spreading radiates (must be an integer).\n");
			fprintf(stdout,"INFO: CHANNEL SPREAD ......... Total Number of channels over which spreading extends.\n");
			fprintf(stdout,"INFO: DEPTH OF SPREAD FRONT .. Number of channels (on each side) activated behind spreading front.\n");
			fprintf(stdout,"INFO: LEVEL ROLLOFF WITH ADDED CHANNELS .... Level compensation for addition of new output channels.\n");
			fprintf(stdout,"INFO:                       0, No rolloff, all channels go up to full level as they are added.\n");
			fprintf(stdout,"INFO:                       1, Full rolloff, level falls to 1/N for N channels of output.\n");
			fprintf(stdout,"INFO:                       Intermediate values are possible.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CENTRE AND SPREAD can vary continuously over time.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(4):
			fprintf(stdout,"INFO: MODE 5:  ANTIPHONALLY SWAP (SILENCE-SEPARATED) EVENTS IN SOUND BETWEEN TWO SETS OF OUTPUT-CHANNELS.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Events are switched between one set of output channels and another.\n");
			fprintf(stdout,"INFO: Event switching occurs only at the onset of a new event.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ANTIPHONAL CHANNEL SETS ..... two strings of letters, with separator ('-')\n");
			fprintf(stdout,"INFO:          representing the 2 sets of output channels to alternate between.\n");
			fprintf(stdout,"INFO:          e.g. abcd-efgh = antiphony between output channels 1,2,3,4 and output channels 5,6,7,8.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE ..... This should not be less than the maximum channel number in the antiphony data,\n");
			fprintf(stdout,"INFO:         but it can be greater.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM DURATION OF SILENCES ..... minimum duration (mS) of consecutive zero-samples\n");
			fprintf(stdout,"INFO:          to constitute a silent 'gap' between peak-events.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(5):
			fprintf(stdout,"INFO: MODE 6:  ANTIPHONALLY SWITCH BETWEEN TWO SETS OF OUTPUT-CHANNELS, USING 1 OR MORE SOUNDS.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Sound output is switched between one set of output channels and another.\n");
			fprintf(stdout,"INFO: Event switching occurs at specified times and, if several files are input, the next sound in the input list is used.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ANTIPHONAL CHANNEL SETS ..... two strings of letters, with separator ('-')\n");
			fprintf(stdout,"INFO:          representing the 2 sets of output channels to alternate between.\n");
			fprintf(stdout,"INFO:          e.g. abcd-efgh = antiphony between output channels 1,2,3,4 and output channels 5,6,7,8.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE ..... This should not be less than the maximum channel number in the antiphony data,\n");
			fprintf(stdout,"INFO:         but it can be greater.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ANTIPHONY_TIMESTEP ..... Timestep before the output switches to the next set of output channels.\n");
			fprintf(stdout,"INFO:                       Can vary through time.\n");
			fprintf(stdout,"INFO: SILENT GAP BETWEEN ANTIPHONAL EVENTS ... Silence separating antiphonal events (if any).\n");
			fprintf(stdout,"INFO:                       Can vary through time.\n");
			fprintf(stdout,"INFO:                       Cannot be equal to or less than the minimum antiphony_timestep.\n");
			fprintf(stdout,"INFO: SPLICELENGTH (mS) ...... Length of splices fading in and out the antiphonal events.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM DURATION OF SILENCES ..... minimum duration (mS) of consecutive zero-samples\n");
			fprintf(stdout,"INFO:          to constitute a silent 'gap' between peak-events.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(6):
			fprintf(stdout,"INFO: MODE 7:  PAN FROM ONE CHANNEL CONFIGURATION TO ANOTHER, PASSING \"THROUGH the CENTRE\".\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PANNING DATA .... is a file containing a list of lines, each having : time  pan-positions\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:         TIME value must increase, from one entry to the next.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:         PAN-POSITIONS is a list of ALL the output channels in any order.\n");
			fprintf(stdout,"INFO:         Input channels 1 to N are mapped, in order, to the channels in your list.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:         On moving from one list to the next, every input channel spreads outwards until\n");
			fprintf(stdout,"INFO:         it feeds every output channel, then gradually focuses into its next output-channel position.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:         To force all inputs to feed all outputs at the start of the sound, at the end of the sound,\n");
			fprintf(stdout,"INFO:         or at any point during the sound, enter a map of zeros (one zero for every input channel)\n");
			fprintf(stdout,"INFO:         at the starttime, and at the endtime, of the desired period.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: LEVEL ROLLOFF WITH ADDED CHANNELS .... Level compensation for addition of new output channels.\n");
			fprintf(stdout,"INFO:                       0, No rolloff, all channels go up to full level as they are added.\n");
			fprintf(stdout,"INFO:                       1, Full rolloff, level falls to 1/N for N channels of output.\n");
			fprintf(stdout,"INFO:                       Intermediate values are possible.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(7):
			fprintf(stdout,"INFO: MODE 8:  PAN A PROCESS ROUND A MULTICHANNEL FILE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The input multichannel sound remains where it is.\n");
			fprintf(stdout,"INFO: The processing itself progresses around the output space in the manner you define.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CENTRE OF PROCESSING  ....... Channel where processing is located.\n");
			fprintf(stdout,"INFO: CHANNEL SPREAD OF PROCESSING .....Total Number of channels over which processing spreads.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(8):
			fprintf(stdout,"INFO: MODE 9:  ROTATE MONO SOUND AROUND MULTICHANNEL SPACE, SPECIFYING (POSSIBLY VARYING) SPEED.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE ..... This should not be less than the maximum channel number in the panning data.\n");
			fprintf(stdout,"INFO:         but it can be greater.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: START CHANNEL ...... Channel in which sound starts out.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPEED (CYCLES PER SEC) ...... Speed of rotation.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: FOCUS ......... Degree to which positioned sound is focused in the loudspeaker.\n");
			fprintf(stdout,"INFO: If focus = 1.0, position set to (e.g.) '2' puts all the signal in lspkr 2.\n");
			fprintf(stdout,"INFO: If focus = 0.9, position '2' puts 90%% of the signal in lspkr 2\n");
			fprintf(stdout,"INFO: and the remainder in the 2 adjacent lspkrs (1 and 3).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ANTICLOCKWISE ...... Force rotation to be anticlockwise (default: clockwise).\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(9):
			fprintf(stdout,"INFO: MODE 10:  SWITCH (SILENCE-SEPARATED) MONO EVENTS IN SOUND BETWEEN RANDOMLY PERMUTED CHANNELS OF OUTPUT.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CHANNELS IN OUTPUT FILE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: FOCUS ......... Degree to which positioned sound is focused in the loudspeaker.\n");
			fprintf(stdout,"INFO: If focus = 1.0, position set to (e.g.) '2' puts all the signal in lspkr 2.\n");
			fprintf(stdout,"INFO: If focus = 0.9, position '2' puts 90%% of the signal in lspkr 2\n");
			fprintf(stdout,"INFO: and the remainder in the 2 adjacent lspkrs (1 and 3).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM DURATION OF SILENCES ..... minimum duration (mS) of consecutive zero-samples\n");
			fprintf(stdout,"INFO:          to constitute a silent 'gap' between events in source-sound.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: EVENT GROUP SIZE ......... number of events at any channel, before switching to next.\n");
			fprintf(stdout,"INFO:          Can vary through time.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: NO STEPS TO ADJACENT CHANNELS.......Reject moving to an adjacent output channel.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: RANDOMLY VARY GROUP SIZE.......number of events at any channel, before switching to next,\n");
			fprintf(stdout,"INFO:          can vary randomly from specified size down to just 1.\n");
			fprintf(stdout,"INFO: \n");
			break;
		}
		break;
	case(TEX_MCHAN):
		fprintf(stdout,"INFO: TEXTURE MADE FROM ONE OR SEVERAL INPUT SOUND FILES, TO MANY OUTPUT CHANNELS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: HARMONIC TYPES OF TEXTURE------------------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Textures are specified WITHIN A (possibly varying) RANGE OF PITCHES\n");
		fprintf(stdout,"INFO: and within that range, the chosen pitches may be\n");
		fprintf(stdout,"INFO: entirely RANDOM, on a HARMONIC SET (using pitches given),\n");
		fprintf(stdout,"INFO: on a HARMONIC FIELD (uses 8va transpositions of pitches given),\n");
		fprintf(stdout,"INFO: or on HARMONIC SETS, OR FIELDS, WHICH CHANGE THROUGH TIME.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: First note (only) of motifs are guaranteed to be on a harmonic set(field) note\n");
		fprintf(stdout,"INFO: except in MOTIFS IN HF, where motifs notes are forced onto set (field) notes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: PARAMETERS FOR TEXTURE---------------------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (** starred items CANNOT VARY in time)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT DURATION...........**.(min) duration of outfile\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- TIMING PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EVENT PACKING ...............(average) time between event onsets.\n");
		fprintf(stdout,"INFO: SKIPTIME BETWEEN GROUP,MOTIF ONSETS..(average) time between group,motif onsets.\n");
		fprintf(stdout,"INFO: EVENT SCATTER................randomisation of event, group or motif onsets.\n");
		fprintf(stdout,"INFO: TIME GRID UNIT...............minstep(MS) quantised timegrid (for event starttimes)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- SOUND PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1ST SND-IN-LIST TO USE,LAST..1st,last snd to use,from listed input sounds.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- LOUDNESS PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN EVENT GAIN, MAX..........min & max level of input events\n");
		fprintf(stdout,"INFO: MIN EVENT SUSTAIN, MAX.......min & max sustain-time of events.\n");
		fprintf(stdout,"INFO: OVERALL ATTENUATION..........overall attenuation of the output\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- PITCH PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN PITCH, MAX...............min & max pitch(MIDI): (gives transposition of input)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- SPATIAL PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPATIAL POSITION.............centre of output sound-image.\n");
		fprintf(stdout,"INFO: SPATIAL SPREAD...............spatial-spread of texture events (0 to all-outchans).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If spatial spread is set to ZERO ....\n");
		fprintf(stdout,"INFO: With MONO sources, output is distributed randomly over all output channels\n");
		fprintf(stdout,"INFO: with no events in positions BETWEEN output channels (all events IN single loudspeakers).\n");
		fprintf(stdout,"INFO: With STEREO sources, each stereo event is assigned to a random pair of output channels,\n");
		fprintf(stdout,"INFO: and these pairs are randomly permuted, so all channels used before any channel visited a 2nd time.\n");
		fprintf(stdout,"INFO: With panning sources, this produces a set of random pan-motions using all channels equally.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- OTHER PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEED.........................same seed-number: reproducible output (0: not so)\n");
		fprintf(stdout,"INFO: PLAY ALL OF INSOUND..........always play whole input-sound (ignoring dur vals).\n");
		fprintf(stdout,"INFO: PLAY FILES CYCLICALLY........play sounds in input order (always uses ALL input sounds).\n");
		fprintf(stdout,"INFO: RANDOMLY PERMUTE EACH CYCLE..permute order of sounds, in each complete cycle.\n");
		fprintf(stdout,"INFO: FIXED POSITIONS..............infiles set at fixed positions in output.\n");
		fprintf(stdout,"INFO:          This option only functions if the output channel count > 2\n");
		fprintf(stdout,"INFO:          and output positions are located on stereo-images formed by alternate lspkrs\n");
		fprintf(stdout,"INFO:          (i.e. stereo 1-3, stereo 2-4, stereo 3-5 etc)\n");
		fprintf(stdout,"INFO:          In this case, \"SPATIAL POSITION\" is read as an offset of the placement of output positions\n");
		fprintf(stdout,"INFO:          With no offset, first sounds entered are on the channels 1-3 stereo image.\n");
		fprintf(stdout,"INFO:          With offset of 1 first sounds entered are on the channels 2-4 stereo image, and so on\n");
		fprintf(stdout,"INFO:          \"SPATIAL SPREAD\" is read as a randomisation of these positions\n");
		fprintf(stdout,"INFO:          with a range 0 to 1 (entered values above 1 are truncated to 1).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: NOTEDATA IS A TEXTFILE CONTAINING-----------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LINE 1: list of (possibly fictional) MIDI pitch of each input snd.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Then, where  harmonic sets or harmonic fields are required,\n");
		fprintf(stdout,"INFO: each subsequent group of lines specifies a NOTELIST\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: NOTELISTS HAVE THE FOLLOWING FORMAT---------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: first line:  #N\n");
		fprintf(stdout,"INFO: other lines: time(SECS)     infile_no      pitch(MIDI)      amp(MIDI)     dur(SECS)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: where N = number of notes (and therefore lines) in notelist to follow,\n");
		fprintf(stdout,"INFO: and times in notelist must never decrease.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (The amp(MIDI) and dur(SECS) params are now redundant, but need to be included).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MANYSIL):
		fprintf(stdout,"INFO: INSERT SEVERAL SILENCES IN A SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SILENCE LOCATION & DURATION .....time/duration value pairs, being the times in the sound to insert the silences,\n");
		fprintf(stdout,"INFO:                                 and the durations of the inserted silences..\n");
		fprintf(stdout,"INFO: SPLICE LENGTH .... length of splices, in mS.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(RETIME):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: MODE 1:  RETIME USER-IDENTIFIED PEAKS IN SOUND, PLACING THEM AT REGULAR BEATS AT SPECIFIED MM.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: LOCATIONS OF BEATS .....list of times of events corresponding to beats, in original sound.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: METRONOME MARK OR BEAT DURATION .... indicating required output tempo.\n");
			fprintf(stdout,"INFO:        (Marked events in source will be placed at regular beats at this MM in output)\n");
			fprintf(stdout,"INFO:        Values between 20 and 400 are interpreted as MM\n");
			fprintf(stdout,"INFO:        Values below 1.0 are interpreted as beat duration\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(1):
			fprintf(stdout,"INFO: MODE 2:  RETIME EVENTS IN ANY SOUND, USING RETIMING DATA.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: RETIMING DATA .....which consists of.\n");
			fprintf(stdout,"INFO:      (a) MM of rhythm of accents in original sound.\n");
			fprintf(stdout,"INFO:      (b) Time, in the outfile, of the first accented event.\n");
			fprintf(stdout,"INFO:      (c) Two columns of (increasing) time-data. \n");
			fprintf(stdout,"INFO:             (1) The true position of the attacks in the original sound.\n");
			fprintf(stdout,"INFO:             (2) The ideal(ised) position of those attacks.\n");
			fprintf(stdout,"INFO:                    NB time of first-accented event must equal a time in this 2nd list.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:      This Data can be generated AUTOMATICALLY from the 'rcode' property in a properties file.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: METRONOME MARK OR BEAT DURATION .... indicating required OUTPUT tempo.\n");
			fprintf(stdout,"INFO:       Values between 20 and 400 are interpreted as MM\n");
			fprintf(stdout,"INFO:       Values below 1.0 are interpreted as beat duration\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PEAKWIDTH (mS) .... ..width to which peak events will be cut, in output.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPLICE LENGTH (mS) .... risetime to events.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(2):
			fprintf(stdout,"INFO: MODE 3:  SHORTEN (SILENCE-SEPARATED) EVENTS IN A SOUND, USING PEAKWIDTH DATA.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
			fprintf(stdout,"INFO:        between peak events.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: OUTPUT PEAKWIDTH .............. width (in mS) of peaks required in output sound.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: OUTPUT SPLICE LENGTH .... ...time (in mS) for splice cutoff of events.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ORIGINAL SPLICE LENGTH .. time (in mS) of splices at end of events in original data.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(3):
			fprintf(stdout,"INFO: MODE 4:  RETIME (SILENCE-SEPARATED) EVENTS IN SOUND, PLACING THEM AT REGULAR BEATS AT SPECIFIED MM.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: METRONOME MARK OR BEAT DURATION .... indicating required output tempo.\n");
			fprintf(stdout,"INFO:       (Marked events in source will be placed at regular beats at this MM in output)\n");
			fprintf(stdout,"INFO:       Values between 20 and 400 are interpreted as MM\n");
			fprintf(stdout,"INFO:       Values below 1.0 are interpreted as beat duration\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
			fprintf(stdout,"INFO:        between peak events.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PREGAIN .... Gain applied to input\n");
			fprintf(stdout,"INFO:       possibly set less than 1.0 where existing grains overlap in output.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(4):
			fprintf(stdout,"INFO: MODE 5:  RETIME (SILENCE-SEPARATED) EVENTS IN SOUND, CHANGING THEIR TIMING BY A GIVEN FACTOR.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TEMPO-CHANGE FACTOR .... increases or decreases tempo of events.\n");
			fprintf(stdout,"INFO:       Factor may vary over time.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
			fprintf(stdout,"INFO:        between peak events.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TEMPO-CHANGE STARTS AFTER .... Events not moved before this time.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TEMPO-CHANGE ENDS BEFORE .... Events not moved after this time.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SYNCHRONISATION TIME .... .. Time of event in input which will sync with its copy in output.\n");
			fprintf(stdout,"INFO:                    Time should be WITHIN the desired event. Zero implies sync at 1st event.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(5):
			fprintf(stdout,"INFO: MODE 6:  REPOSITION (SILENCE-SEPARATED) EVENTS AT SPECIFIED BEATS, AT SPECIFIED TEMPO.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: BEAT LOCATIONS OF EVENTS .... positioning of output events, counted as beats.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: METRONOME MARK OR BEAT DURATION .... indicating required output tempo.\n");
			fprintf(stdout,"INFO:       Values between 20 and 1000 are interpreted as MM\n");
			fprintf(stdout,"INFO:       Values below 1.0 are interpreted as beat duration\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TIME OF FIRST SOUNDING EVENT IN OUTPUT .... in seconds.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
			fprintf(stdout,"INFO:       between peak events.\n");
			fprintf(stdout,"INFO: PREGAIN .... Applied to output: may be necessary if retimed events overlap one another.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(6):
			fprintf(stdout,"INFO: MODE 7:  REPOSITION (SILENCE-SEPARATED) EVENTS AT SPECIFIED TIMES.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TIME LOCATIONS OF EVENTS .... positioning of output events, indicated in seconds.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TIME OF FIRST SOUNDING EVENT IN OUTPUT .... in seconds.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
			fprintf(stdout,"INFO:       between peak events.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PREGAIN .... Applied to output: may be necessary if retimed events overlap one another.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(7):
			fprintf(stdout,"INFO: MODE 8:  REPEAT SPECIFIED (SILENCE-SEPARATED) EVENT, WITHIN SOUND, AT SPECIFIED TEMPO.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
			fprintf(stdout,"INFO:        between peak events.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: METRONOME MARK OR BEAT DURATION .... indicating required output tempo.\n");
			fprintf(stdout,"INFO:       Values between 20 and 1000 are interpreted as MM\n");
			fprintf(stdout,"INFO:       Values below 1.0 are interpreted as beat duration\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: EVENT LOCATION .... (rough) start-time in file of event to be repeated (must be INSIDE event).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: BEATS IN EVENT .... Number of beats (at specified tempo) within the event to repeat.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: EVENT REPETITIONS .... How many times (1 or more) to repeat the event.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
			fprintf(stdout,"INFO:        between peak events.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(8):
			fprintf(stdout,"INFO: MODE 9:  MASK (REPLACE BY SILENCE) (SILENCE-SEPARATED) EVENTS, IN A SPECIFIED PATTERN OF 'DELETIONS'.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MASKING PATTERN......sequence of 0s (mask) and 1s (don't mask) describing masking pattern.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
			fprintf(stdout,"INFO:       between peak events.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(9):
			fprintf(stdout,"INFO: MODE 10: EQUALISE LEVELS, OR ACCENT, (SILENCE-SEPARATED) EVENTS.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
			fprintf(stdout,"INFO:        between peak events.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: DEGREE OF LEVEL EQUALISATION .... Range from 0 to 1.\n");
			fprintf(stdout,"INFO:       1 Boosts level of all events to that of loudest. 0 has no effect.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ACCENT_GROUPING .... If set to ZERO, existing accentuation pattern retained,\n");
			fprintf(stdout,"INFO:       and quieter events are boosted by \"equalisation\".\n");
			fprintf(stdout,"INFO:       If set to (e.g.) 3, every 3rd events is accented,\n");
			fprintf(stdout,"INFO:       (others are set at \"equalisation\" level.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PREGAIN .... Applied to output, only where accent-grouping > 0.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(10):
			fprintf(stdout,"INFO: MODE 11: REPORT DURATION OF SHORTEST (AND LONGEST) (SILENCE-SEPARATED) EVENT.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MINIMUM INTER-EVENT SILENCE (mS) .... minimum duration of any silence\n");
			fprintf(stdout,"INFO:        between peak events.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(11):
			fprintf(stdout,"INFO: MODE 12: LOCATE START OF SOUND (FIRST NON-ZERO SAMPLE) IN FILE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: OUTPUT TEXTFILE .... Data can be written to a new file, or to an existing file.\n");
			fprintf(stdout,"INFO:       The outputfile must have a '.txt' extension, or NO extension.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:       The output data consists of the sound-start-time plus the name of the soundfile.\n");
			fprintf(stdout,"INFO:       The same file can be used for successive calls to this process:\n");
			fprintf(stdout,"INFO:       new data will be appended to the end of the file.\n");
			fprintf(stdout,"INFO:       Hence this process can be applied as a BULK PROCESS on a list of input files.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(12):
			fprintf(stdout,"INFO: MODE 13: MOVE ALL DATA IN FILE SO FILE PEAK FOUND MOVES TO SPECIFIED TIME.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: NEW PEAK TIME ......... Time to which to move peak in file.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(13):
			fprintf(stdout,"INFO: MODE 14: MOVE ALL DATA IN FILE SO FILE EVENT SPECIFIED MOVES TO SPECIFIED TIME.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: NEW PEAK TIME ......... Time to which to move peak in file.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ORIGINAL PEAK TIME .... Time of existing peak in file.\n");
			fprintf(stdout,"INFO: \n");
			break;
		}
		break;
	case(HOVER):
		fprintf(stdout,"INFO: WANDER THROUGH FILE, ZIGZAG READING SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RATE OF HOVER (Hz) .... slow rate read lots of samples forwards, then backwards\n");
		fprintf(stdout,"INFO:                         fast rate read fewer samples forwards, then backwards\n");
		fprintf(stdout,"INFO: LOCATION OF HOVERING .. Time in input sound where samples are read.\n");
		fprintf(stdout,"INFO: RANDOMISATION OF RATE (0-1)\n");
		fprintf(stdout,"INFO: RANDOMISATION OF LOCATION (0-1)\n");
		fprintf(stdout,"INFO: SPLICE LENGTH (mS) .... Must by less then 2 divided by max \"rate\" used\n");
		fprintf(stdout,"INFO: OUTPUT DURATION ....... Total Duration of output file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MULTIMIX):
		fprintf(stdout,"INFO: GENERATE MULTI-CHANNEL MIXFILES FROM A LIST OF SOUNDFILES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (1)  ALL FILES START AT TIME ZERO. OUTPUT CHANNEL COUNT IS MAX INPUT CHANNEL COUNT.\n");
		fprintf(stdout,"INFO: (2)  EACH FILE STARTS WHERE PREVIOUS FILE ENDS. OUT CHANNEL CNT IS MAX INPUT CHANNEL CNT.\n");
		fprintf(stdout,"INFO: (3)  EACH FILE STARTS AT A FIXED 'TIMESTEP' AFTER THE PREVIOUS ONE. OUT CHANNEL CNT IS MAX INPUT CHANNEL CNT.\n");
		fprintf(stdout,"INFO: (4)  STEREO (or mono) SOUND DISTRIBUTED TO NARROW AND WIDE STEREO PAIRS (4 of 8).\n");
		fprintf(stdout,"INFO: (5)  STEREO (or mono) SOUND DISTRIBUTED OVER AN 8-CHANNEL (PAIR-AT FRONT) SYSTEM.\n");
		fprintf(stdout,"INFO:          in modes 4 and 5, mono is treated as stereo with same signal in each channel.\n");
		fprintf(stdout,"INFO: (6)  N MONO SOUNDS SENT, IN ORDER, TO N SEPARATE OUTPUT CHANNELS.\n");
		fprintf(stdout,"INFO: (7)  MONO SOUNDS SENT, IN ORDER, TO SEPARATE OUTPUT CHANNELS.\n");
		fprintf(stdout,"INFO:              wrapping back to initial position, if more input files than output channels.\n");
		fprintf(stdout,"INFO: (8)  ALL FILES START AT TIME ZERO. OUTPUT CHANNEL COUNT SPECIFIED BY PARAMETER.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME STEP BETWEEN ENTRIES ..... (Mode 3).\n");
		fprintf(stdout,"INFO: RELATIVE LEVEL OF OUTER PAIR .. (Mode 4) Assuming inner pair is at level 1, this is outer pair level.\n");
		fprintf(stdout,"INFO:                                                           All levels are adjusted to avoid distortion.\n");
		fprintf(stdout,"INFO: FRONT PAIR LEVEL ........ (Mode 5) Level of stereo signal on front pair of loudspeakers.\n");
		fprintf(stdout,"INFO: FRONT WIDE PAIR LEVEL ... (Mode 5) Level of stereo signal on front pair of loudspeakers.\n");
		fprintf(stdout,"INFO: REAR WIDE PAIR LEVEL .... (Mode 5) Level of stereo signal on front pair of loudspeakers.\n");
		fprintf(stdout,"INFO: REAR PAIR LEVEL ......... (Mode 5) Level of stereo signal on front pair of loudspeakers.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODE 7:\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT .....No of channels in output file.\n");
		fprintf(stdout,"INFO: START CHANNEL ........... Output channel to which first input file is sent.\n");
		fprintf(stdout,"INFO: CHANNEL SKIP ............ Step between output-channel assignment.\n");
		fprintf(stdout,"INFO:                      SKIP 1    assign to successive channels.\n");
		fprintf(stdout,"INFO:                      SKIP 2    assign to alternate channels.\n");
		fprintf(stdout,"INFO:                      SKIP -1   assign to successive channels, counting downwards.\n");
		fprintf(stdout,"INFO: TIMESTEP ................ Timestep between successive entries in mixfile.\n");
		break;
	case(FRAME):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: MODE 1: ROTATE ENTIRE SPATIAL FRAME OF A MULTICHANNEL SOUNDFILE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SNAKING SEQUENCE ...... \n");
			fprintf(stdout,"INFO:       In a clockwise frame rotation, an input channel proceeds on a path around all the lspkrs,\n");
			fprintf(stdout,"INFO:       e.g. in an 8-chan file, input-chan 1 follows the path 1- 2->3->4->5->6->7->8->1 etc\n");
			fprintf(stdout,"INFO:       and the other input channels follow it in a \"snake\".\n");
			fprintf(stdout,"INFO:       This ROTATION-snake is the DEFAULT motion, and you should enter\n");
			fprintf(stdout,"INFO:       a ZERO for the snaking sequence, to generate a rotation.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:       However, the channels might snake around the lspkrs on a different route\n");
			fprintf(stdout,"INFO:       e.g. (for an 8-channel file) \"1 3 5 4 6 8 7 2\"\n");
			fprintf(stdout,"INFO:       and these routes could vary over time.\n");
			fprintf(stdout,"INFO:       You can specify such alternative routes in a text datafile of \"time : route\" values\n");
			fprintf(stdout,"INFO:       A line in the datafile for the above route, starting at time zero, would be\n");
			fprintf(stdout,"INFO:       \"0.0 1 3 5 4 6 8 7 2\"\n");
			fprintf(stdout,"INFO:       A changed route could be specified at a later time, on the next line\n");
			fprintf(stdout,"INFO:       e.g. \"1.3327 1 4 6 3 8 5 7 2\"\n");
			fprintf(stdout,"INFO:       In the datafile, the first time used must be zero, and times must increase.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ROTATION SPEED ........\n");
			fprintf(stdout,"INFO:       The speed of frame-rotation, in complete-rotations per second. This can vary over time.\n");
			fprintf(stdout,"INFO:       Positive values give clockwise rotation; negative values, anticlockwise.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SMEAR ........\n");
			fprintf(stdout,"INFO:       Extent to which signal in any OUTPUT channel bleeds onto its 2 adjacent channels.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(1):
			fprintf(stdout,"INFO: MODE 2: ROTATE ENTIRE SPATIAL FRAME OF SOUNDFILE, ROTATING ODD AND EVEN CHANNELS INDEPENDENTLY.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SNAKING SEQUENCE ...... \n");
			fprintf(stdout,"INFO:       In a clockwise frame rotation here,\n");
			fprintf(stdout,"INFO:       an ODD input channel proceeds on a path around all ODD outchannels,\n");
			fprintf(stdout,"INFO:       e.g. in an 8-chan file, input-chan 1 follows the path 1->3->5->7->1 etc\n");
			fprintf(stdout,"INFO:       and the other ODD input channels follow it in a \"snake\" around the ODD outchannels,\n");
			fprintf(stdout,"INFO:       while an EVEN input channel proceeds on a path around all EVEN outchannels,\n");
			fprintf(stdout,"INFO:       e.g. in an 8-chan file, input-chan 2 follows the path 2->4->6->8->2 etc\n");
			fprintf(stdout,"INFO:       and the other EVEN input channels follow it in a \"snake\" around the EVEN outchannels.\n");
			fprintf(stdout,"INFO:       This ROTATION-snake is the DEFAULT motion, and you should enter\n");
			fprintf(stdout,"INFO:       a ZERO for the snaking sequence, to generate a double rotation.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:       but you can redefine the snaking sequences with a datafile\n");
			fprintf(stdout,"INFO:       e.g.  the snake \"8 6 5 2 7 3 4 1\" produces one snake around the odd entries\n");
			fprintf(stdout,"INFO:       i.e. 8 -> 5 -> 7 -> 4 -> 8 etc\n");
			fprintf(stdout,"INFO:       and a 2nd snake around the even entries\n");
			fprintf(stdout,"INFO:       i.e. 6 -> 2 -> 3 -> 1 -> 6 etc\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: 1ST ROTATION SPEED ........\n");
			fprintf(stdout,"INFO:       The speed of frame-rotation for the ODD input channels, in complete-rotations per second. This can vary over time.\n");
			fprintf(stdout,"INFO:       Positive values give clockwise rotation; negative values, anticlockwise.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: 2ND ROTATION SPEED ........\n");
			fprintf(stdout,"INFO:       The speed of frame-rotation for the EVEN input channels, in complete-rotations per second. This can vary over time.\n");
			fprintf(stdout,"INFO:       Positive values give clockwise rotation; negative values, anticlockwise.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SMEAR ........\n");
			fprintf(stdout,"INFO:       Extent to which signal in any OUTPUT channel bleeds onto its 2 adjacent channels.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(2):
			fprintf(stdout,"INFO: MODE 3:  REORIENTATE THE CHANNELS OF THE INPUT FILE TO (FIXED) NEW POSITIONS.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: REORIENTATION ..... a list of ALL the output channels, in some order.\n");
			fprintf(stdout,"INFO:        Each successive input channel will be sent to the next output channel in the list.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:        For example, the list \"2 4 6 8 1 3 5 7\"  will cause the input channels to be routed\n");
			fprintf(stdout,"INFO:        1 to 2 : 2 to 4 : 3 to 6 : 4 to 8 : 5 to 1 : 6 to 3 : 7 to 5 : 8 to 7\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(3):
			fprintf(stdout,"INFO: MODE 4:  MIRROR the FRAME OF THE INPUT FILE ABOUT A SPECIFIED AXIS.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MIRROR PLANE .... Channel number, or Channel-number + 0.5.\n");
			fprintf(stdout,"INFO:       The output channels are symmetrically mirrored about the channel given \n");
			fprintf(stdout,"INFO:       or around the midpoint between channels (1.5 is midpoint between 1 and 2).\n");
			fprintf(stdout,"INFO:       With an N-channel file, N.5 is midpoint between channels N and 1.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(4):
			fprintf(stdout,"INFO: MODE 5:  RENUMBER the OUTPUT CHANNELS, FROM A RING TO A BILATERAL SCHEMA (OR VICE VERSA).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TO RING FORMAT ....\n");
			fprintf(stdout,"INFO:       WITHOUT this flag, converts from ring schema to bilateral schema.\n");
			fprintf(stdout,"INFO:       WITH this flag, converts from bilateral schema to ring schema.\n");;
			fprintf(stdout,"INFO:               Ring         Bilateral                  Ring               Bilateral\n");
			fprintf(stdout,"INFO:                 1                 1                          1                      1\n");
			fprintf(stdout,"INFO:               8   2            2   3                     5   2                 2   3\n");
			fprintf(stdout,"INFO:              7     3          4     5                     4 3                   4 5\n");
			fprintf(stdout,"INFO:               6   4            6   7\n");
			fprintf(stdout,"INFO:                 5                 8\n");
			fprintf(stdout,"INFO: All multichannel processes assume RING format. If using a bilateral numbering schema\n");
			fprintf(stdout,"INFO: convert from and to Bilateral format, before and after processing data.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(5):
			fprintf(stdout,"INFO: MODE 6:  SWAP ANY 2 CHANNEL OF A MLTICHANNEL FILE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CHANNEL TO SWAP .... The channel to exchange.\n");
			fprintf(stdout,"INFO: CHANNEL TO SWAP WITH .... The channel to exchange it with.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(6):
			fprintf(stdout,"INFO: MODE 7:  ADJUST LEVEL IN (OR ENVELOPE) ONLY SPECIFIED CHANNELS OF A MULTICHANNEL FILE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CHANNELS TO MODIFY ....... Either a channel number, or a text file list of channel numbers.\n");
			fprintf(stdout,"INFO:            Only these channels are modified by the process.\n");
			fprintf(stdout,"INFO: GAIN OR ENVELOPE ....... The gain, or the time-varying gain in the envelope file\n");
			fprintf(stdout,"INFO:            to apply to the specified channels.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(7):
			fprintf(stdout,"INFO: MODE 8:  RENUMBER the OUTPUT CHANNELS, FROM A RING TO BEAST BILATERAL SCHEMA (OR VICE VERSA).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TO RING FORMAT ....\n");
			fprintf(stdout,"INFO:       WITHOUT this flag, converts from ring schema to BEAST bilateral schema.\n");
			fprintf(stdout,"INFO:       WITH this flag, converts from BEAST bilateral schema to ring schema.\n");;
			fprintf(stdout,"INFO:               Ring         Bilateral                  Ring               Bilateral\n");
			fprintf(stdout,"INFO:                 1                 7                          1                      5\n");
			fprintf(stdout,"INFO:               8   2            1   2                     5   2                 1   2\n");
			fprintf(stdout,"INFO:              7     3          3     4                     4 3                   3 4\n");
			fprintf(stdout,"INFO:               6   4            5   6\n");
			fprintf(stdout,"INFO:                 5                 8\n");
			fprintf(stdout,"INFO: All multichannel processes assume RING format. If using a bilateral numbering schema\n");
			fprintf(stdout,"INFO: convert from and to Bilateral format, before and after processing data.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: \"BEAST\" = Birmingham Electro-Acoustic Sound Theatre sound-diffusion system.\n");
			break;
		}
		break;
	case(SEARCH):
		fprintf(stdout,"INFO: FIND THE FIRST REAL SIGNAL IN FILE(S) WHICH START(S) WITH SILENCE.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MCHANREV):
		fprintf(stdout,"INFO: CREATE MULTICHANNEL ECHO OR REVERBERATION AROUND A SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INPUT GAIN................Attenuates signal input to stadium.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LEVEL LOSS WITH DISTANCE..across stadium.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STADIUM SIZE MULTIPLIER...Multiplies average time between echoes.\n");
		fprintf(stdout,"INFO: ..........................(Default average echo time = 0.1 secs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NUMBER OF ECHOS...........Number of stadium echoes produced.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NUMBER OF OUTPUT CHANNELS....Number of channels in output sound.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CENTRE OF SOUND IMAGE........Centre of sound image amongst output channels.\n");
		fprintf(stdout,"INFO:                      Values from 0, to the total number of output channels.\n");
		fprintf(stdout,"INFO:                      Values can be fractional. Values below 1, lie between Channel N and channel 1.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPREAD_OF_ECHOS/REVERB.......Spread of echoes/reverb across output channels.\n");
		fprintf(stdout,"INFO:                      values from 2, to the total number of output channels.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(WRAPPAGE):
		fprintf(stdout,"INFO: GRANULAR RECONSTITUTION OF ONE OR MORE SOUNDFILES, MOVING AROUND A MULTICHANNEL SPACE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CENTRE OF SPREAD  ............ Channel from which sound radiates.Any number between 0 & last output channel.\n");
		fprintf(stdout,"INFO:             Values less than 1, represent locations between the last outchan and the 1st.\n");
		fprintf(stdout,"INFO:             The centre can be moved by supplying a datafile of triples: \"Time   Centre   Direction\"\n");
		fprintf(stdout,"INFO:             Direction, either 1 (clockwise) or -1 (anticlockwise), is direction of motion from PREVIOUS value.\n");
		fprintf(stdout,"INFO: OUTPUT CHANNELS ............. Number of channels of MULTICHANNEL OUTPUT (>2).\n");
		fprintf(stdout,"INFO: CHANNEL SPREAD ............... Total Number of channels over which sound image extends.\n");
		fprintf(stdout,"INFO: DEPTH OF SPREAD FRONT ..... Number of channels (on each side) activated behind spreading front.\n");
		fprintf(stdout,"INFO: TIMESHRINK...... ................Speed of advance in infiles, relative to outfile. (>=0)\n");
		fprintf(stdout,"INFO:              Inverse of timestretch, (& permits infinite timestretch).\n");
		fprintf(stdout,"INFO: DENSITY...........................Amount of grain overlap (>0 : <1 leaves intergrain silence)\n");
		fprintf(stdout,"INFO:              Extremely small values will cease to perform predictably.\n");
		fprintf(stdout,"INFO: GRAINSIZE........................grainsize in MS (must be > 2 * splicelen)\n");
		fprintf(stdout,"INFO: PITCHSHIFT.......... ............is pitchshift of grains in +|- (fractions of) semitones.\n");
		fprintf(stdout,"INFO: LOUDNESS RANGE................is range of gain on grains.\n");
		fprintf(stdout,"INFO:              Use only if amp is to vary (over range &/or through time)\n");
		fprintf(stdout,"INFO: STARTSPLICE.....................length of startsplices on grains,in MS.\n");
		fprintf(stdout,"INFO: ENDSPLICE........................length of endsplices on grains,in MS.\n");
		fprintf(stdout,"INFO: SEARCHRANGE...................for nextgrain, before current 'now' in infile (Default 0 MS).\n");
		fprintf(stdout,"INFO: SCATTER..........................Randomisation of grain position (Range 0-1).\n");
		fprintf(stdout,"INFO: OUTPUT LENGTH.................max outfile length (if end of data not reached).\n");
		fprintf(stdout,"INFO:              Set to zero (Default) for this parameter to be ignored.\n");
		fprintf(stdout,"INFO:              BUT if TIMESHRINK is ANYWHERE 0: OUTLENGTH must be given.\n");
		fprintf(stdout,"INFO: EXPONENTIAL SPLICES.........Default, Linear.\n");
		fprintf(stdout,"INFO: RELATIVE TO OUTPUT TIME..Timeshrink parameters are ALWAYS read relative to time in INPUT file.\n");
		fprintf(stdout,"INFO:              All other parameters are normally also read relative to time in input file.\n");
		fprintf(stdout,"INFO:              Set this flag to force those parameters to be read relative to time in OUTPUT file.\n");
		fprintf(stdout,"INFO: TIMESHRINK LIMIT,DENSITY LIMIT ETC.......allow range of values to be specified\n");
		fprintf(stdout,"INFO:              for any of these params. e.g. With Density & Density Limit set\n");
		fprintf(stdout,"INFO:              a random density is generated between these values,\n");
		fprintf(stdout,"INFO:              while Density & Density Limit can THEMSELVES vary through time.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MCHSTEREO):
		fprintf(stdout,"INFO: INSERT STEREO FILES INTO A MULTICHANNEL OUTPUT SPACE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: This process allows, for example, stereo outputs from processing the individual channels\n");
		fprintf(stdout,"INFO: of a multichannel file (e.g. reverberation) to be remixed into the multichannel context,\n");
		fprintf(stdout,"INFO: at the sample location as their original mono sources.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PREGAIN.......gain applied to stereo inputs before they are mixed to the output.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUT CHANNEL ON WHICH STEREO INPUT CENTRED.......either a channel number,\n");
		fprintf(stdout,"INFO:              or a textfile of channel numbers, one for each stereo inputfile.\n");
		fprintf(stdout,"INFO:              Each stereo input image will be centred (in turn) at the output positions given,\n");
		fprintf(stdout,"INFO:              BUT ...\n");
		fprintf(stdout,"INFO: CENTRE BETWEEN OUTCHANS .... if this flag is set, the output stereo-images are centred\n");
		fprintf(stdout,"INFO:              to the right of the specified output centre, between the 2 output channels.\n");
		fprintf(stdout,"INFO:              e.g. Stereo signal sent to output 2, will be centred between output channels 2 & 3.\n");
		break;
	case(MTON):
		fprintf(stdout,"INFO: CONVERT MONO SOURCE TO MULTICHANNEL SOUND, WITH IDENTICAL DATA IN EVERY CHANNEL.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT.......Number of (identical) channels in the output file.\n");
		break;
	case(FLUTTER):
		fprintf(stdout,"INFO: IMPOSE MULTICHANNEL-DISPERSED LOUDNESS FLUTTERING ON A MULTICHANNEL FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHANNEL SET SEQUENCE ..... The change in loudness occurs first in one set of output channels,\n");
		fprintf(stdout,"INFO:               then in another, as the fluttering proceeds.\n");
		fprintf(stdout,"INFO:               Each line contains a list of 1 or more of the output channels\n");
		fprintf(stdout,"INFO:               forming a 'channel set' which will flutter.\n");
		fprintf(stdout,"INFO:               The flutter passes from the channels in one set, to the channels in the next,\n");
		fprintf(stdout,"INFO:               on every pulse of the fluttering. When all the defined channels sets are used up,\n");
		fprintf(stdout,"INFO:               The sequence begins again at the start (BUT see the 'randomisation' flag, below),\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FLUTTER FREQUENCY (Hz) ...Frequency of loudness fluctuations. May vary over time.\n");
		fprintf(stdout,"INFO: FLUTTER DEPTH ................... Depth of loudness fluctuations. May vary over time.\n");
		fprintf(stdout,"INFO:               Depth between 0 and 1 determines the trough level of the flutter cycle.\n");
		fprintf(stdout,"INFO:               Depth above 1, makes flutter peaks narrower (troughing still at zero).\n");
		fprintf(stdout,"INFO: GAIN ...................................... Overall gain on the output.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RANDOMISE CHANNEL-SETS ORDER .... With this flag set, once all channel-sets have been used\n");
		fprintf(stdout,"INFO:               they are randomly permuted into a different order before the next flutter,\n");
		fprintf(stdout,"INFO:               and when all sets, in this new order, have been used, they are permuted again\n");
		fprintf(stdout,"INFO:               and so on. (The sets themselves are not changed by this process).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ABFPAN):
		fprintf(stdout,"INFO: APPLY FIXED OR ORBITING 1st ORDER B_FORMAT PAN TO A MONO INPUT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START POSITION ..... 0 is front centre, with values increasing clockwise\n");
		fprintf(stdout,"INFO:               until we reach centre again at 1.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: END POSITION ....... \"N.M\" means \"N\" complete orbits, finishing at position \"M\".\n");
		fprintf(stdout,"INFO:               positive values give clockwise orbits, negative values anticlockwise orbits.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NUMBER OF B FORMAT OUTPUT CHANNELS .... Either 3 or (default) 4.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT AS STANDARD WAV: AMBISONIC.\n");
		fprintf(stdout,"INFO: OUTPUT AS STANDARD WAV  ........ (NB You cannot set both of these flags)\n");
		fprintf(stdout,"INFO:               The default output is a WAVEX B-FORMAT Ambisonic File.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ABFPAN2):
		fprintf(stdout,"INFO: APPLY FIXED OR ORBITING 2nd ORDER B_FORMAT PAN TO A MONO INPUT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START POSITION ..... 0 is front centre, with values increasing clockwise\n");
		fprintf(stdout,"INFO:               until we reach centre again at 1.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: END POSITION ....... \"N.M\" means \"N\" complete orbits, finishing at position \"M\".\n");
		fprintf(stdout,"INFO:               positive values give clockwise orbits, negative values anticlockwise orbits.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PREGAIN .... ... Change the input file amplitude.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STANDARD WAV (AMBISONIC) OUTPUT ...... default is WAVEX B-FORMAT.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ABFPAN2P):
		fprintf(stdout,"INFO: APPLY FIXED OR ORBITING 2nd ORDER B_FORMAT PAN TO A MONO INPUT, IN 3-DIMENSIONS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START POSITION ..... 0 is front centre, with values increasing clockwise\n");
		fprintf(stdout,"INFO:               until we reach centre again at 1.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: END POSITION ....... \"N.M\" means \"N\" complete orbits, finishing at position \"M\".\n");
		fprintf(stdout,"INFO:               positive values give clockwise orbits, negative values anticlockwise orbits.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PREGAIN .... ... Change the input file amplitude.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: HEIGHT.......... 90 is directly above, -90 directly below.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STANDARD WAV (AMBISONIC) OUTPUT ...... default is WAVEX B-FORMAT.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CHANNELX):
		fprintf(stdout,"INFO: EXTRACT CHANNELS FROM A MULTICHANNEL FILE OF ANY FORMAT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INPUT CHANNELS TO EXTRACT.......... Textfile with a list of input channels to extract.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CHORDER):
		fprintf(stdout,"INFO: REORDER CHANNELS INSIDE A MULTICHANNEL FILE OF ANY FORMAT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REORDERING STRING.......... String consisting of (lower-case) letters, with or without zeros.\n");
		fprintf(stdout,"INFO:               The string cannot contain more than 26 items.\n");
		fprintf(stdout,"INFO:               For example, for a 4-channel input file, the channels are represented by \"a\",\"b\",\"c\" and \"d\".\n");
		fprintf(stdout,"INFO:               \"0\" represents a (possible) silent output channel.\n");
		fprintf(stdout,"INFO:               Ordering strings for this 4-channel file could be.....\n");
		fprintf(stdout,"INFO:               \"abcd\" same order as the input (input file not altered).\n");
		fprintf(stdout,"INFO:               \"dcba\" reversed channel-order of the input.\n");
		fprintf(stdout,"INFO:               \"a00b\" input channel 1 to out-channel 1, input channel 2 to out-channel 4, with 2 silent channels.\n");
		fprintf(stdout,"INFO:               \"aababc00ddd\" etc (note that channels can be duplicated in the output).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:               For an 8-channel input file, channels are represented by \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\" and \"h\".\n");
		fprintf(stdout,"INFO:               and so on.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FORCE A .amb FILENAME EXTENSION (CARE!!)\n");
		fprintf(stdout,"INFO:               specifying a \".amb\" file extension does NOT automatically produce an ambisonic output file.\n");
		fprintf(stdout,"INFO:               This can only be guaranteed by the internal structure of the data.\n");
		fprintf(stdout,"INFO:               Forcing a \".amb\" extension onto non-ambisonic data may cause confusion at a later data!\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: This program permits low level manipulation of the data format of files.\n");
		fprintf(stdout,"INFO: With ambisonic or other non-trivial data structures, it should be used WITH CAUTION!!\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FMDCODE):
		fprintf(stdout,"INFO: PLAIN MULTI-LAYOUT DECODER FOR AMBISONIC FILES.\n");
		fprintf(stdout,"INFO: (No shelf filter or NF compensation used).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT LAYOUT.......... This can take one of the following values.\n");
		fprintf(stdout,"INFO:               1  : *   Mono (= W signal only).\n");
		fprintf(stdout,"INFO:               2  : *   Stereo (quasi mid/side, = W +- Y) \n");
		fprintf(stdout,"INFO:               3  :     Square (FL  FR  RR  RL  order)\n");
		fprintf(stdout,"INFO:               4  : *   Quad   (FL  FR  RL  RR  order)\n");
		fprintf(stdout,"INFO:               5  :     Pentagon  \n");
		fprintf(stdout,"INFO:               6  : *   5.0  (WAVEX order)\n");
		fprintf(stdout,"INFO:               7  : *   5.1  (WAVEX order : silent LFE)\n");
		fprintf(stdout,"INFO:               8  :     hexagon  \n");
		fprintf(stdout,"INFO:               9  :     octagon 1 (pair at front)\n");
		fprintf(stdout,"INFO:               10 :    octagon 2  (single lspkr at front centre)\n");
		fprintf(stdout,"INFO:               11 :    cube  (as 3 : low/high interleaved)\n");
		fprintf(stdout,"INFO:               12 : *  cube  (as 4 : low quad followed by high quad)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WRITE WAVEX LSPKR POSITIONS TO HEADER ....... NB only applies to \"*\" layouts above.\n");
		fprintf(stdout,"INFO: PLAIN WAV OUTFILE FORMAT ...... Default is generic wavex format.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CHXFORMAT):
		fprintf(stdout,"INFO: SET OR CHANGE THE LOUDSPEAKER POSITION MASK IN A WAVEX FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \nLSPKR_POSITION_MASK ....... Indicates the loudspeaker positions for sound output.");
		fprintf(stdout,"INFO:               0 : Unsets the loudspeaker mask.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CHXFORMATG):
		fprintf(stdout,"INFO: CHANGE GUID TYPE FROM WAVEX TO AMBISONIC, UNSETTING THE LSPKR POSITION MASK.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CHXFORMATM):
		fprintf(stdout,"INFO: SET THE POSSIBLE LOUDSPEAKER POSITION MASK VALUES FOR A WAVEX FILE.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INTERLX):
		fprintf(stdout,"INFO: INTERELAVE LIST OF MONO OR STEREO SOUNDS (IN A TEXTFILE) TO A MULTICHANNEL OUTPUT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT CHANNEL FORMAT  ....... Indicates the output soundfile format.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:               0 : Standard (wav, aiff etc.) format.\n");
		fprintf(stdout,"INFO:               1 : generic WAV_EX (no loudspeaker assignments).\n");
		fprintf(stdout,"INFO:               2 : WAV_EX mono/stereo/quad (FL  FR  RL  RR). 1,2 or 4 input channels needed.\n");
		fprintf(stdout,"INFO:               3 : WAV_EX quad surround (L, C, R, S). Four input channels needed.\n");
		fprintf(stdout,"INFO:               4 : WAV_EX 5.1 format surround. Six input channels needed.\n");
		fprintf(stdout,"INFO:               5 : WAV_EX Ambisonic B-Format (W,X,Y,Z....). 3,4,5,6,7,8,9,11 or 16 input chans needed.\n");
		fprintf(stdout,"INFO:               6 : WAV_EX 5.0 surround. Five input channels needed.\n");
		fprintf(stdout,"INFO:               7 : WAV_EX 7.1 surround. Eight input channels needed.\n");
		fprintf(stdout,"INFO:               8 : WAV_EX Cube surround. Eight input channels needed.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Input files must match in sample rate, and number of channels, but can have different sample types.\n");
		fprintf(stdout,"INFO: If Input files are WAVEX, any loudspeaker position information is ignored.\n");
		fprintf(stdout,"INFO: The same input file can be listed several times, if required to send to several output channels.\n");
		break;
	case(COPYSFX):
		fprintf(stdout,"INFO: COPY SOUNDFILE, CHANGING THE FORMAT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SAMPLE TYPE  ....... Indicates the output sample type.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:               0 : Retain sample type of input file.\n");
		fprintf(stdout,"INFO:               1 : 16 bit integer (short).\n");
		fprintf(stdout,"INFO:               2 : 32 bit integer (long).\n");
		fprintf(stdout,"INFO:               3 : 32 bit floating-point.\n");
		fprintf(stdout,"INFO:               4 : 24 bit integer (packed).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTFILE FORMAT  ....... Indicates the output soundfile format.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:               -1 : Retain format of input file.\n");
		fprintf(stdout,"INFO:               0 : Standard wav format.\n");
		fprintf(stdout,"INFO:               1 : generic WAV_EX (no loudspeaker assignments).\n");
		fprintf(stdout,"INFO:               2 : WAV_EX mono/stereo/quad (FL  FR  RL  RR). 1,2 or 4 input channels needed.\n");
		fprintf(stdout,"INFO:               3 : WAV_EX quad surround (L, C, R, S). Four input channels needed.\n");
		fprintf(stdout,"INFO:               4 : WAV_EX 5.1 format surround. Six input channels needed.\n");
		fprintf(stdout,"INFO:               5 : WAV_EX Ambisonic B-Format (W,X,Y,Z....). 3,4,5,6,7,8,9,11 or 16 input chans needed.\n");
		fprintf(stdout,"INFO:               6 : WAV_EX 5.0 surround. Five input channels needed.\n");
		fprintf(stdout,"INFO:               7 : WAV_EX 7.1 surround. Eight input channels needed.\n");
		fprintf(stdout,"INFO:               8 : WAV_EX Cube surround. Eight input channels needed.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ADD TDPF DITHER TO 16 BIT OUTFILE .... improving quality of low level signals.\n");
		fprintf(stdout,"INFO: WRITE MINIMAL HEADER (NO PEAKDATA) ... header gets no information about peaks in the output file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(NJOINCH):
		fprintf(stdout,"INFO: CHECK COMPATIBLITY OF FILES FOR CONCATENATION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CD COMPATIBLE FILES ONLY .... All files must have sample-rate 44100\n");
		fprintf(stdout,"INFO:               and must be at least 4 seconds in duration. \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: All files must match in sample-rate and number of channels,\n");
		fprintf(stdout,"INFO: but may have different sample types (e.g. 16-bit, 32-bit etc.)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(NJOIN):
		fprintf(stdout,"INFO: CONCATENATE FILES e.g. FOR C.D. COMPILATION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SILENCE BETWEEN FILES ...... silence separating the files in concatenated output.\n");
		fprintf(stdout,"INFO:               To eliminate silence BEFORE 1st file in output, enter a NEGATIVE value.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CD COMPATIBLE FILES ONLY .... All files must have sample-rate 44100\n");
		fprintf(stdout,"INFO:               and must be at least 4 seconds in duration. \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT A TEXTFILE OF CUES .... Output extra file, with cue points in compilation. \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: All files must match in sample-rate and number of channels,\n");
		fprintf(stdout,"INFO: but may have different sample types (e.g. 16-bit, 32-bit etc.)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The output sample format is taken from the file with the highest precision.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(NMIX):
		fprintf(stdout,"INFO: MIX TWO FILES OF THE SAME FORMAT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Any format is accepted, so long as both files have the same format.\n");
		fprintf(stdout,"INFO: Formats may be wav, aiff, WAVEX, Ambisonic, etc.\n");
		fprintf(stdout,"INFO: (WAVEX files must have the same loudspeaker layout).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Files may have different sample types (16bit, 32bit etc.)\n");
		fprintf(stdout,"INFO: and (unless \"Float Output\" flag is set) output takes the sample-type of the FIRST file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START TIME OF 2nd FILE .... First file starts at zero; 2nd file starts at time specified here.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: APPLY DITHER TO 16bit OUTPUT .... Enhance quality of low level signal (only with 16bit output).\n");
		fprintf(stdout,"INFO: FLOAT OUTPUT ......................... Force 32bit floating point output type.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(RMSINFO):
		fprintf(stdout,"INFO: REPORT RMS AND AVERAGE POWER.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Scans the file (between the times specified) and reports the loudness in various forms.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Output is a table of values showing, for each channel,\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) the RMS loudness, as amplitude(0-1) and in dB\n");
		fprintf(stdout,"INFO: 2) the average loudness (power) as amplitude(0-1) and in dB\n");
		fprintf(stdout,"INFO: 3) the NET DC loudness as amplitude(0-1) and in dB\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SFEXPROPS):
		fprintf(stdout,"INFO: DISPLAY PROPERTIES OF WAVEX FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: These include\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The File Format.\n");
		fprintf(stdout,"INFO: The loudspeaker configuration.\n");
		fprintf(stdout,"INFO: The loudspeaker positions (if specified).\n");
		fprintf(stdout,"INFO: Creation date of the file.\n");
		fprintf(stdout,"INFO: Sample Rate.\n");
		fprintf(stdout,"INFO: Channel Count.\n");
		fprintf(stdout,"INFO: Sample Type (16-bit,32-bit etc.)\n");
		fprintf(stdout,"INFO: Duration.\n");
		fprintf(stdout,"INFO: Peak data information for each channel.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SETHARES):
		fprintf(stdout,"INFO: EXTRACT PEAKS FROM ANALYSIS DATA.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (1)  LIST (TIME-VARYING) PEAKS\n");
		fprintf(stdout,"INFO:              List peaks in each window - windows may have different numbers of peaks.\n");
		fprintf(stdout,"INFO: (2)  STREAM MAXIMUM NUMBER OF PEAKS.\n");
		fprintf(stdout,"INFO:              Number of streams = maximum number of peaks in any one window in the file.\n");
		fprintf(stdout,"INFO:              Where a window has insufficient peaks to fill all the streams\n");
		fprintf(stdout,"INFO:              a zero-amplitude peak, at an estimated frequency , is set in the stream for that window.\n");
		fprintf(stdout,"INFO:              In this process, all peaks are retained.\n");
		fprintf(stdout,"INFO: (3)  STREAM MOST PROMINENT PEAKS.\n");
		fprintf(stdout,"INFO:              This process assumes that the spectrum is relatively stable.\n");
		fprintf(stdout,"INFO:              The peaks at every semitone interval in every window are counted.\n");
		fprintf(stdout,"INFO:              This determines the weighting of each pitch among the peaks in the entire file.\n");
		fprintf(stdout,"INFO:              The most prominent pitches are chosen as the stream-centres.\n");
		fprintf(stdout,"INFO:              Time-varying pitch/amp data is then assigned to these streams.\n");
		fprintf(stdout,"INFO:              In this process, some peaks may be discarded.\n");
		fprintf(stdout,"INFO: (4)  OUTPUT AVERAGE PITCHES.\n");
		fprintf(stdout,"INFO:              This process assumes that the spectrum is relatively stable.\n");
		fprintf(stdout,"INFO:              Streams are calculated as in Mode 3, and an average value calculated for each stream.\n");
		fprintf(stdout,"INFO:              The output data does not vary in time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEARCH WINDOW SIZE (SEMITONES) .... semitone width of subwindow used to search for local peaks in spectrum.\n");
		fprintf(stdout,"INFO: PEAKING RATIO .............................. a peak is defined as a channel whose amplitude\n");
		fprintf(stdout,"INFO:              exceeds the median amplitude of all the channels in the subwindow, by this factor.\n");
		fprintf(stdout,"INFO: AMPLITUDE FLOOR .......................... peak must also exceed a floor value to be retained.\n");
		fprintf(stdout,"INFO:             Entered value is first multiplied by the maximum channel amplitude found in the file.\n");
		fprintf(stdout,"INFO: LOW PITCH LIMIT ............................ Minimum frequency to accept as a peak.\n");
		fprintf(stdout,"INFO: HIGH PITCH LIMIT ............................ Maximum frequency to accept as a peak.\n");
		fprintf(stdout,"INFO: IN-TUNE RANGE (SEMITONES) ............. range within which harmonics accepted as in tune.\n");
		fprintf(stdout,"INFO:             If NON-ZERO, peaks which are harmonics of other peaks are not retained.\n");
		fprintf(stdout,"INFO:             If set to zero, ALL peaks are retained.\n");
 		fprintf(stdout,"INFO: NO AMPLITUDES ............................. Discard the amplitude information.\n");
		fprintf(stdout,"INFO:             NB: If the output is in \"FILTER FORMAT\", all amplitudes are set to 1.0.\n");
 		fprintf(stdout,"INFO: MIDI OUTPUT ................................. Frequency data output as MIDI values.\n");
		fprintf(stdout,"INFO: QUANTISE TO QUARTERTONES ........... Quantise frqs to tempered-scale quartertone.\n");
		fprintf(stdout,"INFO: MARK ZEROS ................................. Mark windows which have NO peaks.\n");
		fprintf(stdout,"INFO:             If set, peak-free areas are marked by (timed) zeros in the output data.\n");
		fprintf(stdout,"INFO: FILTER FORMAT ............................. Output data in filter varibank format.\n");
		fprintf(stdout,"INFO:             This overrides the \"MARK ZEROS\" flag.\n");
 		fprintf(stdout,"INFO: \n");
		break;
	case(MCHSHRED):
		fprintf(stdout,"INFO: MULTICHANNEL SOUND SHREDDING.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (1)  SHRED MONO FILE TO N OUTPUT CHANNELS\n");
		fprintf(stdout,"INFO: (2)  SHRED MULTICHANNEL FILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Cut file into segments, rearrange the segments: Repeat the process on the output.\n");
		fprintf(stdout,"INFO: The output chunks are also sent to a randomly permuted sequence of output channels.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NUMBER OF SHREDS. ...number of repeats of shredding process.\n");
		fprintf(stdout,"INFO: AVERAGE CHUNKLENGTH..average length of chunks to cut & permute.\n");
		fprintf(stdout,"INFO: CUT SCATTER..........randomisation of cuts (0 to K): default 1.\n");
		fprintf(stdout,"INFO: .....................where K = total number of chunks (snd-duration/chunklen).\n");
		fprintf(stdout,"INFO: .....................If scatter = 0: sound is reordered without shredding.\n");
		fprintf(stdout,"INFO: OUTPUT CHANNEL CNT...For Mode 1 only.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MCHZIG):
		fprintf(stdout,"INFO: READ BACK AND FORTH INSIDE SOUNDFILE, WITH RANDOM PANS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (1)  RANDOM ZIGZAGS\n");
		fprintf(stdout,"INFO: (2)  ZIGZAG BETWEEN USER SPECIFIED TIMES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In mode USER SPECIFIED\n");
		fprintf(stdout,"INFO: Required data is textfile containing sequence of times to zigzag (and pan) between.\n");
		fprintf(stdout,"INFO: Each step-between-times must be > (3 * splicelen).\n");
		fprintf(stdout,"INFO: Successive zigsteps moving in same (time-)direction are concatenated.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ZIGZAGGING START TIME..... Start time of the area of the infile where zigzagging will happen.\n");
		fprintf(stdout,"INFO: ZIGZAGGING END TIME ........ End time of the area of the infile where zigzagging will happen.\n");
		fprintf(stdout,"INFO: MIN DURATION OUTFILE ...... output will be at least this long.\n");
		fprintf(stdout,"INFO: MIN ZIG LENGTH ............... in \"Random\" mode, minimum duration of any zig or zag.\n");
		fprintf(stdout,"INFO: OUTPUT CHANNEL CNT\n");
		fprintf(stdout,"INFO: SPLICE LENGTH (MS)\n");
		fprintf(stdout,"INFO: MAX ZIG LENGTH ............... in \"Random\" mode, maximum duration of any zig or zag.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RANDOM SEED..a number to generate a replicable random sequence. (>0)\n");
		fprintf(stdout,"INFO: .............enter same number on next program run, to get same outfile.\n");
		fprintf(stdout,"INFO: .............(Default: (0) random sequence is different every time).\n");
		fprintf(stdout,"INFO: NO PANS BETWEEN ADJACENT CHANNELS.......Reject zigs between adjacent output channels.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MCHITER):
		fprintf(stdout,"INFO: ITERATE INPUT SOUND IN FLUID MANNER, DISTRIBUTING TO MANY CHANNELS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ****  WARNING: Do NOT use with large files. ****\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DELAY..................(average) delay between iterations. Default:infile dur.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RANDOMISATION OF DELAY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCH SCATTER..........max of random pitchshift of each iteration: semitones\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AMPLITUDE SCATTER......max of random amp-reduction on each iteration.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PROGRESSIVE FADE.......(average) amplitude reduction between iterations.\n");
		fprintf(stdout,"INFO:                        A small value is a small amplitude reduction.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OVERALL GAIN...........(special) value 0, gives best guess for no distortion.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEED RANDOM GENERATOR..same number produces identical output on rerun,\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SPECSPHINX):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: IMPOSE CHANNEL AMPLITUDES OF FILE2 ON CHANNEL FRQS OF FILE 1\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: AMPLITUDE BALANCE..... Proportion of File1 Channel-amplitudes retained.\n");
			fprintf(stdout,"INFO: FREQUENCY BALANCE..... Proportion of File2 Channel-frequencies retained in output spectrum.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(1):
			fprintf(stdout,"INFO: MULTIPLY CHANNEL AMPLITUDES OF TWO SPECTRA\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Note that the spectral FREQUENCIES of the FIRST input are always retained.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: BIAS ....... If NON-zero, a proportion of the (channel-by-channel) amplitude of original signal is added to the output.\n");
			fprintf(stdout,"INFO:                        If less than 1, a proportion of the 1st input signal is added to the multiplied output.\n");
			fprintf(stdout,"INFO:                        If greater than 1, a proportion of the 2nd input signal is added to the multiplied output.\n");
			fprintf(stdout,"INFO:                        Ratio of original to multiplied signal, in the output = abs(bias)/(1.0 - abs(bias))\n");
			fprintf(stdout,"INFO:                        where \"abs(bias)\" is the absolute (unsigned) value of \"bias\"\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: GAIN ....... Overall gain on output.\n");
			fprintf(stdout,"INFO: \n");
			break;
		}
		break;
	case(SUPERACCU):
		fprintf(stdout,"INFO: SUSTAIN EACH SPECTRAL BAND, UNTIL LOUDER DATA APPEARS IN THAT BAND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: This process is similar to \"FOCUS ACCUMULATE\"\n");
		fprintf(stdout,"INFO: but at the file end, any decaying channels are retained until they decay to zero.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (1)  SUSTAIN (AND POSSIBLY GLISS) LOUDEST PARTIALS.\n");
		fprintf(stdout,"INFO: (2)  AS (1) BUT TUNE (START OF) SUSTAINED PARTIALS TO TEMPERED SCALE.\n");
		fprintf(stdout,"INFO: (3)  AS (1) BUT TUNE (START OF) SUSTAINED PARTIALS TO NEAREST OF SPECIFIED FREQUENCIES.\n");
		fprintf(stdout,"INFO:             (HARMONIC SET GIVEN IN INPUT DATA FILE).\n");
		fprintf(stdout,"INFO: (4)  AS (1) BUT TUNE (START OF) SUSTAINED PARTIALS TO NEAREST OF SPECIFIED FREQUENCIES OR THEIR 8vas\n");
		fprintf(stdout,"INFO:             (HARMONIC FIELD GIVEN IN INPUT DATA FILE).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DECAY RATE....sutained channel data decays by DECAYRATE per sec.\n");
		fprintf(stdout,"INFO: GLISS RATE....sutained channel data glisses at GLISRATE 8vas per sec.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TUNING....forces the (start) frq of sustained partials to one of the specified frequencies.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REASSIGN CHANNELS .... glissing data is moved into more appropriate channel\n");
		fprintf(stdout,"INFO:                        if it strays beond the channel frq limits.\n");
		fprintf(stdout,"INFO:                        (can cause sustained glissandi to persist for longer.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PARTITION):
		fprintf(stdout,"INFO: PARTITION MONO SOUND FILE INTO DISJUNCT BLOCKS, ASSIGNING EVERY Nth BLOCK TO ONE OF N OUTPUT FILES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: For input file \"abcdefghijklmno....\" and 3 output files\n");
		fprintf(stdout,"INFO: (where \"a\",\"b\" etc are successive blocks), we produce\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Outfile1 \"a--d--g--j--m--...\n");
		fprintf(stdout,"INFO: Outfile2 \"-b--e--h--k--n-...\n");
		fprintf(stdout,"INFO: Outfile3 \"--c--f--i--l--o...\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: where \"--\" is silence replacing the missing blocks\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (1)  BLOCKS DEFINED BY THE COUNT OF THE WAVESETS THEY CONTAIN.\n");
		fprintf(stdout,"INFO: (2)  BLOCKS DEFINED BY THEIR DURATION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GRID COUNT ..... is the number of output files to generate.\n");
		fprintf(stdout,"INFO: WAVESET COUNT PER GRID BLOCK (Mode 1) ..... is the number of wavesets in each Block in the output files.\n");
		fprintf(stdout,"INFO: DURATION OF GRID BLOCKS (Mode 2) ..... is the duration (in seconds) of each Block.\n");
		fprintf(stdout,"INFO: RANDOMISATION OF DURATION (Mode 2) ..... is the randomisation of that duration (Range 0 -1).\n");
		fprintf(stdout,"INFO: SPLICE LENGTH (Mode 2) ..... is the duration of the splices used to cut the blocks, in milliseconds.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SPECGRIDS):
		fprintf(stdout,"INFO: PARTITION SPECTRUM INTO PARTS, OVER A GRID\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTFILECNT    Number of output spectral files.\n");
		fprintf(stdout,"INFO: CHANGROUPING  Number of adjacent channels per group in the output spectra.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The product of the 2 parameters must be a divisor of the channel count.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If the input file has 16 channels \"abcdefghijklmnop\"\n");
		fprintf(stdout,"INFO: With 2 outfiles and changrouping 1\n");
		fprintf(stdout,"INFO: The outfiles contain \"a-c-e-g-i-k-m-o\" and \"b-d-f-h-j-l-n-p\" respectively.\n");
		fprintf(stdout,"INFO: With 2 outfiles and changrouping 2\n");
		fprintf(stdout,"INFO: The outfiles contain \"ab-ef-ij-mn\" and \"cd-gh-kl-op\".\n");
		fprintf(stdout,"INFO: With 2 outfiles and changrouping 4\n");
		fprintf(stdout,"INFO: The outfiles contain \"abcd-ijkl\" and \"efgh-mnop\".\n");
		fprintf(stdout,"INFO: With 2 outfiles and changrouping 8\n");
		fprintf(stdout,"INFO: The outfiles contain \"abcdefgh\" and \"mnopijkl\".\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: With 4 outfiles and changrouping 1\n");
		fprintf(stdout,"INFO: The outfiles contain \"a-e-i-m\" \"b-f-j-n\" \"c-g-k-o\" and \"d-h-l-p\".\n");
		fprintf(stdout,"INFO: With 4 outfiles and changrouping 2\n");
		fprintf(stdout,"INFO: With changrouping 2 and 4 outfiles\n");
		fprintf(stdout,"INFO: The outfiles contain \"ab-ij\" \"cd-kl\" \"ef-mn\" and \"gh-op\".\n");
		fprintf(stdout,"INFO: With 4 outfiles and changrouping 4\n");
		fprintf(stdout,"INFO: The outfiles contain \"abcd\" \"efgh\" \"ijkl\" and \"mnop\".\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GLISTEN):
		fprintf(stdout,"INFO: RANDOM PARTITION THE SPECTRUM INTO BINS AND PLAY THESE BACK IN ORDER\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: All the channels of the spectrum are partitioned into N mutually exclusive sets\n");
		fprintf(stdout,"INFO: with channels assigned at random to each set. These sets form 1 complete group.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Then channels in the first set are played, for a given number of windows,\n");
		fprintf(stdout,"INFO: at which point channels in the 2nd set are played, and so on.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (As this happens, we are progressing through the original spectrum at the original rate.\n");
		fprintf(stdout,"INFO: The process determines merely which channels are used - the others being zeroed).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Once all N sets are exhausted, a new group is made by random partition, and so on.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GROUP DIVISIONS ..... Number of sets to divide analysis-channels into\n");
		fprintf(stdout,"INFO:                     (e.g. with value 4, process partitions channels randomly\n");
		fprintf(stdout,"INFO:                     among 4 sets with [totalchans/4] channels per set).\n");
		fprintf(stdout,"INFO:                     NB Must be an exact divisior of the channel count.\n");
		fprintf(stdout,"INFO: WINDOW LENGTH .......  Number of windows for which each channel-set persists\n");
		fprintf(stdout,"INFO:                     before we switch to next set-of-channels (Range 1-1024)\n");
		fprintf(stdout,"INFO: PITCHSHIFT ............. Maximum +- range of random pitch shifting of each set\n");
		fprintf(stdout,"INFO:                     (Range 0 to 12.0  semitones)\n");
		fprintf(stdout,"INFO: WINDOWLENGTH RANDOMISE ... Randomisation of Window length to use (between 1 and value set)\n");
		fprintf(stdout,"INFO: GROUPDIVIDE RANDOMISE ..... Randomise number of channels in each set in a group\n");
		fprintf(stdout,"INFO:                     Without randomisation, each set-in-a-group has an equal number of channels.\n");
		fprintf(stdout,"INFO:                     With randomisation, a group has sets of different sizes.\n");
		break;
	case(TUNEVARY):
		fprintf(stdout,"INFO: REPLACE SPECTRAL FRQS BY HARMONICS OF SPECIFIED PITCH(ES), POSSIBLY IN MOTION\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Data required a time-changing template of MIDI pitch-values\n");
		fprintf(stdout,"INFO: Each line must start with a time, in seconds,\n");
		fprintf(stdout,"INFO: and be followed by (possibly fractional) MIDI values (range 0 - 127).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Times must start at zero and increase from line to line.\n");
		fprintf(stdout,"INFO: Lines must have equal numbers of entries,\n");
		fprintf(stdout,"INFO: but duplicated MIDI values can be used on any line.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FOCUS..........degree of focusing of partial pitches onto template.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CLARITY........degree to which non-template partials are suppressed.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TRACE..........number of (window_by_window) most prominent channels\n");
		fprintf(stdout,"INFO: ...............to be replaced by template frqs. (default, all channels)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW FRQ LIMIT..frqs below this are ignored.\n");
		fprintf(stdout,"INFO: \n");
	case(ISOLATE):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: ISOLATE, IN PLACE, SINGLE SPECIFIED SEGMENT(S) OF A SOURCE, TO DISTINCT OUTFILES\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Specified segments are cut from the input file to distinct output files\n");
			fprintf(stdout,"INFO: but the segments retain silent preambles\n");
			fprintf(stdout,"INFO: so they occur at SAME TIME in the outfiles, as in the input file.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Process concludes by generating a file of all material left over after segment removal.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The original file is reconstructible by mixing all these components.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CUT SEGMENT TIMES .....The datafile is a list of time-pairs,\n");
			fprintf(stdout,"INFO:           being the start and end times of segments to be cut.\n");
			fprintf(stdout,"INFO:           These should be in time order, and must not overlap one another.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:           If 2 cuts abutt each other, or are so close that the end and start splices overlap,\n");
			fprintf(stdout,"INFO:           the end of the first cut will be moved back, and the start of 2nd cut moved forward\n");
			fprintf(stdout,"INFO:           so that they overlap by a single splicelength.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:           On the Loom, the \"Sound View\" window allows cut-segments to be marked\n");
			fprintf(stdout,"INFO:           on a graphic of the input file waveform.\n");
			fprintf(stdout,"INFO:           Input segments are sorted into order and checked for overlap.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPLICELEN ............ Length of the splices in mS\n");
			fprintf(stdout,"INFO: \n");
		    fprintf(stdout,"INFO: EXTEND END-SILENCES TO ENDTIME OF SOURCE forces all output files to be the same length.\n");
		    fprintf(stdout,"INFO: REVERSE SEGMENT OUTPUT outputs the segmented data backwards-in-time.\n");
			fprintf(stdout,"INFO:            This is useful if the segments are to be INVERSE-PROCESSED.\n");
			fprintf(stdout,"INFO:            i.e. a time-reversed file is processed and the process-output re-reversed, restoring the original time-direction.\n");
			fprintf(stdout,"INFO:            This might be useful where a process generates a tail of sound after the end of the original source  e.g. reverb\n");
			fprintf(stdout,"INFO:            Reverse-processing in this way causes the 'tail' to PRECEDE the source in the final output.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:            NB If all outputs are the same length in \"ISOLATE\", the reversed files can be processed\n");
			fprintf(stdout,"INFO:            then rejoined with the remnant file using \"REJOIN\", WITHOUT needing to re-reverse them first.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(1):
			fprintf(stdout,"INFO: ISOLATE, IN PLACE, SETS OF SPECIFIED SEGMENT(S) OF A SOURCE, TO DISTINCT OUTFILES\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Specified sets of isolated segments are cut from the input file.\n");
			fprintf(stdout,"INFO: Each output file has a different set of isolated segments of the source.\n");
			fprintf(stdout,"INFO: The files have silent preambles so that events occur at SAME TIME in the outfiles\n");
			fprintf(stdout,"INFO: as in the source file.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The original file is reconstructible by mixing all these components.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CUT SEGMENT TIMES ...... Each line of the datafile has a list of time-pairs,\n");
			fprintf(stdout,"INFO:           the start & end times of segments to be cut for that particular output file.\n");
			fprintf(stdout,"INFO:           These should be in time order, in each line.\n");
			fprintf(stdout,"INFO:           None of segments (in any of the lines) must overlap one another.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:           If 2 cuts abutt each other, or are so close that the end and start splices overlap,\n");
			fprintf(stdout,"INFO:           the end of the first cut will be moved back, and the start of 2nd cut moved forward\n");
			fprintf(stdout,"INFO:           so that they overlap by a single splicelength.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:           On the Loom, the \"Sound View\" window allows cut-segments to be marked\n");
			fprintf(stdout,"INFO:           on a graphic of the input file waveform.\n");
			fprintf(stdout,"INFO:           Marked segments which succeed each other in time are placed on the same line.\n");
			fprintf(stdout,"INFO:           (assumed to be part of the data for the same output file).\n");
			fprintf(stdout,"INFO:           If a new marked segment preceeds (in time) a previous marked segment,\n");
			fprintf(stdout,"INFO:           a new data line is initiated for a 2nd output file, and so on.\n");
			fprintf(stdout,"INFO:           Input segments are also checked for overlap.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPLICELEN ............ Length of the splices in mS\n");
			fprintf(stdout,"INFO: \n");
		    fprintf(stdout,"INFO: EXTEND END-SILENCES TO ENDTIME OF SOURCE forces all output files to be the same length.\n");
		    fprintf(stdout,"INFO: REVERSE SEGMENT OUTPUT outputs the segmented data backwards-in-time.\n");
			fprintf(stdout,"INFO:            This is useful if the segments are to be INVERSE-PROCESSED.\n");
			fprintf(stdout,"INFO:            i.e. a time-reversed file is processed and the process-output re-reversed, restoring the original time-direction.\n");
			fprintf(stdout,"INFO:            This might be useful where a process generates a tail of sound after the end of the original source  e.g. reverb\n");
			fprintf(stdout,"INFO:            Reverse-processing in this way causes the 'tail' to PRECEDE the source in the final output.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:            NB If all outputs are the same length in \"ISOLATE\", the reversed files can be processed\n");
			fprintf(stdout,"INFO:            then rejoined with the remnant file using \"REJOIN\", WITHOUT needing to re-reverse them first.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: \n");
			break;
		case(2):
			fprintf(stdout,"INFO: ISOLATE, IN PLACE, SEVERAL SEGMENT(S) OF A SOURCE, TO A SINGLE OUTFILE\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Specified segments are cut from the input file and placed in the same output file.\n");
			fprintf(stdout,"INFO: but the segments retain silent surrounds\n");
			fprintf(stdout,"INFO: so they occur at SAME TIME in the outfiles, as in the input file.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Segment starts and ends are located using threshold-on and threshold-off parameters.\n");
			fprintf(stdout,"INFO: If a segment-length is set, only the initial part (length specified) of each segment is retained.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Process concludes by generating a file of all material left over after segment removal.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The original file is reconstructible by mixing both these components.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: THRESHOLD ON .......... dB level at which a segment is triggered to  be cut.\n");
			fprintf(stdout,"INFO: THRESHOLD OFF ......... dB level at which a cut segment is triggered to end.\n");
			fprintf(stdout,"INFO: MINIMUM SEGMENT LENGTH.. Minimum Duration in mS which segment must have, to be accepted.\n");
			fprintf(stdout,"INFO: SEGMENT RETAIN LENGTH .. Duration in mS of (start-)portion of segments to retain.\n");
			fprintf(stdout,"INFO:                     If segment length is set to zero, the complete segments are retained.\n");
			fprintf(stdout,"INFO: SPLICELEN ............ Length of the splices in mS\n");
			fprintf(stdout,"INFO: \n");
		    fprintf(stdout,"INFO: EXTEND END-SILENCES TO ENDTIME OF SOURCE forces all output files to be the same length.\n");
		    fprintf(stdout,"INFO: REVERSE SEGMENT OUTPUT outputs the segmented data backwards-in-time.\n");
			fprintf(stdout,"INFO:            This is useful if the segments are to be INVERSE-PROCESSED.\n");
			fprintf(stdout,"INFO:            i.e. a time-reversed file is processed and the process-output re-reversed, restoring the original time-direction.\n");
			fprintf(stdout,"INFO:            This might be useful where a process generates a tail of sound after the end of the original source  e.g. reverb\n");
			fprintf(stdout,"INFO:            Reverse-processing in this way causes the 'tail' to PRECEDE the source in the final output.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:            NB If all outputs are the same length in \"ISOLATE\", the reversed files can be processed\n");
			fprintf(stdout,"INFO:            then rejoined with the remnant file using \"REJOIN\", WITHOUT needing to re-reverse them first.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(3):
			fprintf(stdout,"INFO: ISOLATE, IN PLACE, ALL THE SLICED UP SEGMENT(S) OF A SOUNDFILE\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The source is segmented into successive adjacent segments, written to distinct output files.\n");
			fprintf(stdout,"INFO: The files have silent preambles so that events occur at SAME TIME in the outfiles\n");
			fprintf(stdout,"INFO: as in the source file.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The original file is reconstructible by mixing all these components.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SLICE TIMES ...... Datafile contains a list of (increasing) times where the source is to be cut.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:           On the Loom, the \"Sound View\" window allows cut-times to be marked\n");
			fprintf(stdout,"INFO:           on a graphic of the input file waveform.\n");
			fprintf(stdout,"INFO:           Cut-times are sorted into ascending order.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPLICELEN ............ Length of the splices in mS\n");
			fprintf(stdout,"INFO: \n");
		    fprintf(stdout,"INFO: EXTEND END-SILENCES TO ENDTIME OF SOURCE forces all output files to be the same length.\n");
		    fprintf(stdout,"INFO: REVERSE SEGMENT OUTPUT outputs the segmented data backwards-in-time.\n");
			fprintf(stdout,"INFO:            This is useful if the segments are to be INVERSE-PROCESSED.\n");
			fprintf(stdout,"INFO:            i.e. a time-reversed file is processed and the process-output re-reversed, restoring the original time-direction.\n");
			fprintf(stdout,"INFO:            This might be useful where a process generates a tail of sound after the end of the original source  e.g. reverb\n");
			fprintf(stdout,"INFO:            Reverse-processing in this way causes the 'tail' to PRECEDE the source in the final output.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:            NB If all outputs are the same length in \"ISOLATE\", the reversed files can be processed using \"REJOIN\",\n");
			fprintf(stdout,"INFO:            WITHOUT needing to re-reverse them first.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(4):
			fprintf(stdout,"INFO: ISOLATE, IN PLACE, ALL THE SLICED UP SEGMENT(S) OF A SOUNDFILE, WITH SLIGHT OVERLAPS\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The source is segmented into successive adjacent segments, written to distinct output files.\n");
			fprintf(stdout,"INFO: The files have silent preambles so that events occur at SAME TIME in the outfiles\n");
			fprintf(stdout,"INFO: as in the source file.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The cut segments are made to overlap slightly (good for isolating speech syllables).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The original file is reconstructible by mixing all these components.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SLICE TIMES ...... Datafile contains a list of (increasing) times where the source is to be cut.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:           On the Loom, the \"Sound View\" window allows cut-times to be marked\n");
			fprintf(stdout,"INFO:           on a graphic of the input file waveform.\n");
			fprintf(stdout,"INFO:           Cut-times are sorted into ascending order.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPLICELEN ............ Length of the splices in mS\n");
			fprintf(stdout,"INFO: DOVETAIL  ............ Length of segment overlaps in mS\n");
			fprintf(stdout,"INFO: \n");
		    fprintf(stdout,"INFO: EXTEND END-SILENCES TO ENDTIME OF SOURCE forces all output files to be the same length.\n");
		    fprintf(stdout,"INFO: REVERSE SEGMENT OUTPUT outputs the segmented data backwards-in-time.\n");
			fprintf(stdout,"INFO:            This is useful if the segments are to be INVERSE-PROCESSED.\n");
			fprintf(stdout,"INFO:            i.e. a time-reversed file is processed and the process-output re-reversed, restoring the original time-direction.\n");
			fprintf(stdout,"INFO:            This might be useful where a process generates a tail of sound after the end of the original source  e.g. reverb\n");
			fprintf(stdout,"INFO:            Reverse-processing in this way causes the 'tail' to PRECEDE the source in the final output.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:            NB If all outputs are the same length in \"ISOLATE\", the reversed files can be processed using \"REJOIN\",\n");
			fprintf(stdout,"INFO:            WITHOUT needing to re-reverse them first.\n");
			fprintf(stdout,"INFO: \n");
			break;
		}
		break;
	case(REJOIN):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: REMIX SEGMENT-FILES ORIGINATING IN THE \"ISOLATE\" PROCESS\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Process assumes the source files are semgents cut from a source, using \"ISOLATE\"\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The (possibly processed) files are here remixed together\n");
			fprintf(stdout,"INFO: returning segments to their original timings in the source.\n");
			fprintf(stdout,"INFO: \n");
		    fprintf(stdout,"INFO: If the segments were originally REVERSED by the isolate process\n");
			fprintf(stdout,"INFO: setting \"REVERSE SEGMENTS\" here will automatically re-reverse the (possibly processed) segments\n");
			fprintf(stdout,"INFO: before mixing them.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: GAIN ....... Changes the output level (Range 0 - 1).\n");
			fprintf(stdout,"INFO:             (Note that output level is automatically turned down if output clips).\n");
			fprintf(stdout,"INFO: \n");
			break;		
		case(1):
			fprintf(stdout,"INFO: REMIX SEGMENT-FILES ORIGINATING IN THE \"ISOLATE\" PROCESS, WITH THE REMNANT FILE\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Process assumes the source files are segments cut from a source, using \"ISOLATE\"\n");
			fprintf(stdout,"INFO: PLUS the remnant file, which must be LAST in the list of input files.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The (possibly processed) files are here remixed together\n");
			fprintf(stdout,"INFO: returning segments to their original timings in the source.\n");
			fprintf(stdout,"INFO: \n");
		    fprintf(stdout,"INFO: If the segments were originally REVERSED by the isolate process\n");
			fprintf(stdout,"INFO: setting \"REVERSE SEGMENTS\" here will automatically re-reverse the (possibly processed) segments\n");
			fprintf(stdout,"INFO: before mixing them with the remnant file.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: GAIN ....... Changes the output level (Range 0 - 1).\n");
			fprintf(stdout,"INFO:             (Note that output level is automatically turned down if output clips).\n");
			fprintf(stdout,"INFO: \n");
			break;		
		}
		break;
	case(PANORAMA):
		fprintf(stdout,"INFO: CREATE PANORAMA OF INPUT FILES, SPREADING ACROSS MULTICHANNEL SURROUND SPACE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Loudspeakers assumed to be effectively surrounding the listening area from the front outwards.\n");
		fprintf(stdout,"INFO: Input sounds distributed in order from leftmost to rightmost position\n");
		fprintf(stdout,"INFO: (with a 360 degree spread specified, 180 is assumed to be the rightmost position).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES ----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
	    fprintf(stdout,"INFO: 1)  SPECIFY THE NUMBER OF LOUDSPEAKERS, AND THE TOTAL ANGULAR WIDTH ( >= 190 degrees )\n");
		fprintf(stdout,"INFO: 2)  LIST OF LOUDSPEAKER POSITIONS, IN A FILE (TOTAL ANGULAR WIDTH >= 190 degrees)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS -------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODE 1:\n");
		fprintf(stdout,"INFO:       NO. OF LOUDSPEAKERS ........ Assumed equally spaced.\n");
		fprintf(stdout,"INFO:       TOTAL ANGULAR WIDTH OF LSPKRS ......(190 - 360).\n");
		fprintf(stdout,"INFO:                       The loudspeaker array is assumed to be symmetrical around its centre-line.\n");
		fprintf(stdout,"INFO: MODE 2:\n");
		fprintf(stdout,"INFO:       LOUDSPEAKER POSITIONS ....... A textfile list of the angular positions of the loudspeakers.\n");
		fprintf(stdout,"INFO:           positions to the right of centre lie between 0 (front) and 180 (rear)\n");
		fprintf(stdout,"INFO:           positions to the left of centre lie between >180 (rear) and 360(=0) (front)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ANGULAR WIDTH OF SOUND IMAGE .......... (0 - 360 degrees).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ANGULAR OFFSET OF SOUND IMAGE ...... angle between centre-line of sounds and centre-line of loudspeakers.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SOUND CONFIGURATION ........ Distribution of output sounds within the sound image angle.\n");
		fprintf(stdout,"INFO:          1: sounds are equally spaced\n");
		fprintf(stdout,"INFO:          2: two sounds are equally spaced, followed by a gap, etc.\n");
		fprintf(stdout,"INFO:          3: three sounds are equally spaced, followed by a gap, etc.\n");
		fprintf(stdout,"INFO:          and so on\n");
		fprintf(stdout,"INFO:          Must be a divisor of the number of input sounds used.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RANDOMISATION ............... Randomisation of sound positions (0-1).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FRONT-PAIR LSPKRS ....... If the angular width of the loudspeakers is 360 degrees.\n");
		fprintf(stdout,"INFO:          The speaker orientation is ambiguous.\n");
		fprintf(stdout,"INFO:          Default assumes that there is a single loudspeaker at centre front.\n");
		fprintf(stdout,"INFO:          Setting this flag forces a pair of lspkrs, symmetrically placed to each side of centre-front.\n");
		fprintf(stdout,"INFO:          (The flag is IGNORED if TOTAL ANGULAR WIDTH OF LSPKRS is less than 360 degrees )\n");
		fprintf(stdout,"INFO: FRONT-PAIR SOUND IMAGES ....... The same logic applied to the SOUND positions\n");
		fprintf(stdout,"INFO:          (ignored if the ANGULAR WIDTH OF SOUND IMAGE is less than 360 degrees )\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TREMOLO):
		fprintf(stdout,"INFO: TREMOLO A SOUND, WITH ADJUSTABLE PEAK-WIDTH\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FRQWISE....Interpolate linearly between frqs in any frq brktable (default).\n");
		fprintf(stdout,"INFO: PITCHWISE..Interpolate logarithmically (like pitch). (Care with zero frqs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TREMOLO FREQUENCY..is frequency of the tremolo vibration itself.\n");
		fprintf(stdout,"INFO: TREMOLO DEPTH......amplitude depth of tremolo.\n");
		fprintf(stdout,"INFO: OVERALL GAIN.......Overall signal gain, or envelope.\n");
		fprintf(stdout,"INFO: PEAK NARROWING ....Tremolo peaks can be made narrower.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ECHO):
		fprintf(stdout,"INFO: REPEATEDLY ECHO A SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DELAY...................must be greater than the sound duration.\n");
		fprintf(stdout,"INFO:               (use the \"DELAY\" program otherwise).\n");
		fprintf(stdout,"INFO: ATTENUATION.............change in level from one echo to the next.\n");
		fprintf(stdout,"INFO: MAXIMUM DURATION....... maximum duration of output (output may be shorter).\n");
		fprintf(stdout,"INFO: RANDOMISATION ......... Randomisation of echo times.\n");
		fprintf(stdout,"INFO: CUTOFF LEVEL .......... Level below which output signal is cut off.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PACKET):
	    fprintf(stdout,"INFO: CREATE AN ENVELOPED SOUND-PACKET, CUT AND SHAPED FROM A SOURCE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FOUND....Use signal minima around the specified location in the source, to determine where to cut a packet.\n");
		fprintf(stdout,"INFO: FORCED...Cut a packet at the specified location in the source.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PACKET LOCATION IN SOURCE ........ Time in source around which packet is to be cut.\n");
		fprintf(stdout,"INFO:                    A single time value or a textfile list of times.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION ......... Duration (of forced packet) or minimum-duration (of found packet) in mS.\n");
		fprintf(stdout,"INFO:                    (Must be less than half the source duration).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NARROWING ........ Narrowing of the packet envelope, which is normally cosinusoidal.\n");
		fprintf(stdout,"INFO:                    Values below 1.0 broaden the packet.\n");
		fprintf(stdout,"INFO:                    Values very close to zero may produce clicks (square-wave envelope).\n");
		fprintf(stdout,"INFO:                    High vals with short packets may produce click-impulses or silence.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CENTRING ........  Centring of the peak of the packet envelope.\n");
		fprintf(stdout,"INFO:                    0  gives a peak at centre: -ve values move the peak towards the start of packet\n");
		fprintf(stdout,"INFO:                    +ve values move the peak towards the end of the packet.\n");
		fprintf(stdout,"INFO:                    If the packet content has varying level, the true peak position may not correspond\n");
		fprintf(stdout,"INFO:                    to the envelope peak position, unless the \"-f\" flag is used.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NORMALISE ........ Normalise the packet level.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXPAND ........... Packet wave maxima(minima) are forced up(down) to the envelope contour of the packet.\n");
		fprintf(stdout,"INFO:                    (default, the packet envelope is simply imposed on the existing signal).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SHAVE SILENCE..... Remove leading or trailing silence in resultant packet.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SYNTHESIZER):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: SYNTHESIZE COMPLEX TONES\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Creates tones with any number of partials which may vary through time in frequency and level.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPECTRUM DATA ..... A textfile Listing of partial ratios and relative levels, against time.\n");
			fprintf(stdout,"INFO:                     Data is a text file of lines of data and every line must have the same number of entries.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     The 1ST ENTRY on each line is a time. Times must start at zero and increase.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     All EVEN NUMBERED entries are partial numbers\n");
			fprintf(stdout,"INFO:                     For synthesizing tones, the first partial number on each line must be 1.\n");
			fprintf(stdout,"INFO:                     Partial numbers must increase through a line.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     All other ODD NUMBERED entries are partial levels and may have any numeric value.\n");
			fprintf(stdout,"INFO:                     -ve values invert the phase of the partial.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SAMPLE_RATE ....... Sample rate of the synthesized sound.\n");
			fprintf(stdout,"INFO: DURATION .......... Total Duration of the synthesized sound.\n");
			fprintf(stdout,"INFO: FREQUENCY ......... Fundamental frequency of the synthesized sound (possibly time-varying).\n");
			break;
		case(1):
			fprintf(stdout,"INFO: SYNTHESIZE PACKET_STREAMS\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Creates a stream of wave-packets, which may vary in content through time.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPECTRUM DATA ..... A textfile Listing of partial ratios and relative levels, against time.\n");
			fprintf(stdout,"INFO:                     Data is a text file of lines of data and every line must have the same number of entries.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     The 1ST ENTRY on each line is a time. Times must start at zero and increase.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     All EVEN NUMBERED entries are partial numbers\n");
			fprintf(stdout,"INFO:                     For synthesizing tones, the first partial number on each line must be 1.\n");
			fprintf(stdout,"INFO:                     Partial numbers must increase through a line.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     All other ODD NUMBERED entries are partial levels and may have any numeric value.\n");
			fprintf(stdout,"INFO:                     -ve values invert the phase of the partial.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SAMPLE_RATE ....... Sample rate of the synthesized sound.\n");
			fprintf(stdout,"INFO: DURATION .......... Total Duration of the synthesized sound.\n");
			fprintf(stdout,"INFO: FREQUENCY ......... Fundamental frequency of the synthesized sound (possibly time-varying).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: NARROWING ......... Narrowing of the packet envelope, which is normally cosinusoidal.\n");
			fprintf(stdout,"INFO:                     Values below 1.0 broaden the packet.\n");
			fprintf(stdout,"INFO:                     Values very close to zero may produce clicks (square-wave envelope).\n");
			fprintf(stdout,"INFO:                     High vals with high frequencies may produce click-impulses or silence.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: CENTRING .........  Centring of the peak of the packet envelope.\n");
			fprintf(stdout,"INFO:                     0 gives a peak at centre: -ve values move the peak towards the start of packet\n");
			fprintf(stdout,"INFO:                     +ve values move the peak towards the end of the packet.\n");
			fprintf(stdout,"INFO:                     If the packet content has varying level, the true peak position may not correspond\n");
			fprintf(stdout,"INFO:                     to the envelope peak position.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: STATIONARY PACKET PARAMS .......\n");
			fprintf(stdout,"INFO:                     With this flag set, packet parameters are set at the outset of a packet,\n");
			fprintf(stdout,"INFO:                     and remain the same until its end.\n");
			fprintf(stdout,"INFO:                     With no flag set, frq and level parameters of partials continue to vary WITHIN the packets.\n");
			break;
		case(2):
			fprintf(stdout,"INFO: SYNTHESIZE GLISTENING SOUNDS\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Creates a distribution of partials-components of spectrum (which may vary through time), varying in time and space.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPECTRUM DATA ..... A textfile Listing of partial ratios and relative levels, against time.\n");
			fprintf(stdout,"INFO:                     Data is a text file of lines of data and every line must have the same number of entries.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     The 1ST ENTRY on each line is a time. Times must start at zero and increase.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     All EVEN NUMBERED entries are partial numbers\n");
			fprintf(stdout,"INFO:                     For synthesizing tones, the first partial number on each line must be 1.\n");
			fprintf(stdout,"INFO:                     Partial numbers must increase through a line.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     All other ODD NUMBERED entries are partial levels and may have any numeric value.\n");
			fprintf(stdout,"INFO:                     -ve values invert the phase of the partial.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SAMPLE_RATE ....... Sample rate of the synthesized sound.\n");
			fprintf(stdout,"INFO: DURATION ............ Total Duration of the synthesized sound.\n");
			fprintf(stdout,"INFO: FREQUENCY ......... Fundamental frequency of the synthesized sound (possibly time-varying).\n");
			fprintf(stdout,"INFO: CHANNEL COUNT ... Number of output channels.\n");
			fprintf(stdout,"INFO: MAX OCTAVE TRANSPOSITION.. Maximum transposition of spectral components.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TIMESTEP ............ Average timestep between changes in partials-content of output.\n");
			fprintf(stdout,"INFO: RISETIME ............ Time taken to attain max octave transposition range, at start of sound.\n");
			fprintf(stdout,"INFO: FALLTIME ............ Time taken to return to minimal range.\n");
			fprintf(stdout,"INFO: STEADY STATE ...... Time spent in minimal range at end of sound.\n");
			fprintf(stdout,"INFO: FROM FUNDAMENTAL  Initial rise in number of partials is from fundamental only.\n");
			fprintf(stdout,"INFO: TO FUNDAMENTAL .... Final \"steady state\" gradually contracts to using fundamental only.\n");
			fprintf(stdout,"INFO: SPLICETIME (mS).... Length of fade-in/out times of components in output sound, in milliseconds.\n");
			fprintf(stdout,"INFO: PARTIALS IN PLAY . Number of partials used in any segment: If set to zero, number of partials used is random.\n");
			fprintf(stdout,"INFO: MAXCHANGE PARTIALS .. As far as possible, always change partials used, from one segment to the next.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPATIALISE ............ Distribute components in space.\n");
			fprintf(stdout,"INFO: EMERGENCE CHANNEL .. If spatial image emerges from a single channel, to fill the space, this is the channel.\n");
			fprintf(stdout,"INFO: EMERGENCE TIME .... If spatial image emerges from a single channel, time taken to fully emerge.\n");
			fprintf(stdout,"INFO: CONVERGENCE CHANNEL .. If spatial image converges to a single channel at end of sound, this is the channel.\n");
			fprintf(stdout,"INFO: CONVERGENCE TIME . If spatial image converges to a single channel, time taken to fully converge.\n");
			fprintf(stdout,"INFO: JUMP .................. Use same spatial position for all partials in a segment.\n");
			fprintf(stdout,"INFO: ROTATION SPEED .... Rotation speed for Special Space Type 3 (only).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPECIAL SPACE TYPE  (8-channel files only) .... Special types of spatialisation.\n");
			fprintf(stdout,"INFO:    1:  Left-Right Rand ........... Alternate Left and Right sides, random positions.\n");
			fprintf(stdout,"INFO:    2:  Front-Back Rand .......... Alternate Front and back areas of space , random positions.\n");
			fprintf(stdout,"INFO:    3:  Rotate ...................... (Requires a positive or negative rotation speed).\n");               
			fprintf(stdout,"INFO:    4:  Superspace1 ............... Single channel positions only.\n");
			fprintf(stdout,"INFO:    5:  Superspace2 ............... Single channels and channel-pairs only.\n");
			fprintf(stdout,"INFO:    6:  Superspace3 ............... Single channels and channel-pairs and channel-triples only.\n");
			fprintf(stdout,"INFO:    7:  Superspace4 ............... Single channels, channel-pairs, channel-triples, square, diamond and all-positions.\n");
			fprintf(stdout,"INFO:    8:  Left-Right Alternate ....... Alternate Left and Right sides, using all channels of each.\n");
			fprintf(stdout,"INFO:    9:  Back-Front Alternate ...... Alternate Back and Front areas, using all channels of each.\n");
			fprintf(stdout,"INFO:    10: Frameswitch ............... Alternate Between Square and Diamond 4-sets.\n");
			fprintf(stdout,"INFO:    11: Triangle Rotate 1 ......... Rotate a triple of alternate channels, clockwise.\n");
			fprintf(stdout,"INFO:    12: Triangle AntiRotate 1 ..... Rotate a triple of alternate channels, anticlockwise.\n");
			fprintf(stdout,"INFO:    13: Triangle Rotate 2 ......... Rotate a channel and the pair opposite, clockwise.\n");
			fprintf(stdout,"INFO:    14: Triangle AntiRotate 2 ..... Rotate a channel and the pair opposite, anticlockwise.\n");
			break;
		}
		break;
	case(TAN_ONE):
		fprintf(stdout,"INFO: PLAY REPETITIONS OF MONO SOUND ON TANGENT PATH TO AN 8-CHANNEL RING OF LSPKRS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: loudspeaker array is numbered clockwise, starting with \"1\" at front-centre.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Different modes have different tangent styles...\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FAR TANGENT  .... For focus at speaker 1, starts along line at right-angles to speaker 2.\n");
		fprintf(stdout,"INFO: NEAR TANGENT .... For focus at speaker 1, starts along line formed by speakers 2 and 3.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION ....... Duration of output file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EVENT COUNT ... Count of the events in the tangent stream (Single and Two src modes only).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAXIMUM ANGLE .. (Far Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
		fprintf(stdout,"INFO:                       Max angle of rotation of the motion lies between 3rd pair (  i.e. between  90 to 135 degrees).\n");
		fprintf(stdout,"INFO:                       (lsprks 3-4 in the example)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SKEW  ....... .. (Near Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
		fprintf(stdout,"INFO:                       Skew is the ratio (0-1) of time spent between the last pair & the penultimate pair of lspkrs.\n");
		fprintf(stdout,"INFO:                       (lspkr pairs 3-4 and 2-3, in the example)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DECIMATION ..... Loudness decimation on passing from one event to the next.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FOCUS POSITION .. Loudpseaker at which the motion ends (approaching motion) or begins (receding motion).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: JITTER ..........  Randomisation of event timings (0-1, default 0) Can vary over time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DRAG ........... (Far Tangent Modes) Slows the pan-motion acceleration.\n");
		fprintf(stdout,"INFO:                  Smaller values make stream proceed more slowly to (or from) the focus position.\n");
		fprintf(stdout,"INFO:                  For approaching motion, 0.5 avoids the arrival being too fast to tell.\n");
		fprintf(stdout,"INFO:                  For receding motion, 1.0, makes the initial motion rapid.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RECEDE ........  Sounds Recede (default, sounds approach).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AT LEFT .......  Motion is to or from the left of the focal lspkr (default: motion is to or from the right).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Note that in the part of the stream closest to the focal lspkr,\n");
		fprintf(stdout,"INFO: the SAME final (approaching)  or initial (receding) event is repeated, at fixed level.\n");
		fprintf(stdout,"INFO: These repeated events are ADDITIONAL to the event-count.\n");
		break;
	case(TAN_TWO):
		fprintf(stdout,"INFO: PLAY REPETITIONS OF TWO MERGED MONO SOUNDS ON TANGENT PATH TO AN 8-CHANNEL RING OF LSPKRS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: loudspeaker array is numbered clockwise, starting with \"1\" at front-centre.\n");
		fprintf(stdout,"INFO: \n");
	    fprintf(stdout,"INFO: The two sources are superimposed along the tangent path, beginning with only the 1st sound\n");
		fprintf(stdout,"INFO: and gradually mixing in more of the 2nd sound from one event to the next.\n");
		fprintf(stdout,"INFO: If one input is a filtered version of the other, this suggest it might be more distant.\n");
		fprintf(stdout,"INFO: Hence for approaching motion the filterd sound should be first,\n");
		fprintf(stdout,"INFO: whereas for receding motion the filtered sound should be second.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Different modes have different tangent styles...\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FAR TANGENT  .... For focus at speaker 1, starts along line at right-angles to speaker 2.\n");
		fprintf(stdout,"INFO: NEAR TANGENT .... For focus at speaker 1, starts along line formed by speakers 2 and 3.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION ....... Duration of output file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EVENT COUNT ... Count of the events in the tangent stream (Single and Two src modes only).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAXIMUM ANGLE .. (Far Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
		fprintf(stdout,"INFO:                       Max angle of rotation of the motion lies between 3rd pair (  i.e. between  90 to 135 degrees).\n");
		fprintf(stdout,"INFO:                       (lsprks 3-4 in the example)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SKEW  ....... .. (Near Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
		fprintf(stdout,"INFO:                       Skew is the ratio (0-1) of time spent between the last pair & the penultimate pair of lspkrs.\n");
		fprintf(stdout,"INFO:                       (lspkr pairs 3-4 and 2-3, in the example)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DECIMATION ..... Loudness decimation on passing from one event to the next.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BALANCE ACCUMULATOR ... Progressive accumulation of 2nd sound in the mix.\n");
		fprintf(stdout,"INFO:                  For an accumulation value of 0.33, succeesive mix would be [1.0 : 0.0] [0.66 : 0.33] [0.44 : 0.56] etc.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FOCUS POSITION .. Loudpseaker at which the motion ends (approaching motion) or begins (receding motion).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: JITTER ..........  Randomisation of event timings (0-1, default 0) Can vary over time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DRAG ........... (Far Tangent Modes) Slows the pan-motion acceleration.\n");
		fprintf(stdout,"INFO:                  Smaller values make stream proceed more slowly to (or from) the focus position.\n");
		fprintf(stdout,"INFO:                  For approaching motion, 0.5 avoids the arrival being too fast to tell.\n");
		fprintf(stdout,"INFO:                  For receding motion, 1.0, makes the initial motion rapid.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RECEDE ........  Sounds Recede (default, sounds approach).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AT LEFT .......  Motion is to or from the left of the focal lspkr (default: motion is to or from the right).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Note that in the part of the stream closest to the focal lspkr,\n");
		fprintf(stdout,"INFO: the SAME final (approaching)  or initial (receding) event is repeated, at fixed level.\n");
		fprintf(stdout,"INFO: These repeated events are ADDITIONAL to the event-count, and there are no balance changes here.\n");
		break;
	case(TAN_SEQ):
		fprintf(stdout,"INFO: PLAY SEQUENCE OF MONO SOUNDS ON TANGENT PATH TO AN 8-CHANNEL RING OF LSPKRS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: loudspeaker array is numbered clockwise, starting with \"1\" at front-centre.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Different modes have different tangent styles...\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FAR TANGENT  .... For focus at speaker 1, starts along line at right-angles to speaker 2.\n");
		fprintf(stdout,"INFO: NEAR TANGENT .... For focus at speaker 1, starts along line formed by speakers 2 and 3.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION ....... Duration of output file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAXIMUM ANGLE .. (Far Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
		fprintf(stdout,"INFO:                       Max angle of rotation of the motion lies between 3rd pair (  i.e. between  90 to 135 degrees).\n");
		fprintf(stdout,"INFO:                       (lsprks 3-4 in the example)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SKEW  ....... .. (Near Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
		fprintf(stdout,"INFO:                       Skew is the ratio (0-1) of time spent between the last pair & the penultimate pair of lspkrs.\n");
		fprintf(stdout,"INFO:                       (lspkr pairs 3-4 and 2-3, in the example)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DECIMATION ..... Loudness decimation on passing from one event to the next.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FOCUS POSITION .. Loudpseaker at which the motion ends (approaching motion) or begins (receding motion).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: JITTER ..........  Randomisation of event timings (0-1, default 0) Can vary over time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DRAG ........... (Far Tangent Modes) Slows the pan-motion acceleration.\n");
		fprintf(stdout,"INFO:                  Smaller values make stream proceed more slowly to (or from) the focus position.\n");
		fprintf(stdout,"INFO:                  For approaching motion, 0.5 avoids the arrival being too fast to tell.\n");
		fprintf(stdout,"INFO:                  For receding motion, 1.0, makes the initial motion rapid.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RECEDE ........  Sounds Recede (default, sounds approach).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AT LEFT .......  Motion is to or from the left of the focal lspkr (default: motion is to or from the right).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Note that in the part of the stream closest to the focal lspkr,\n");
		fprintf(stdout,"INFO: the SAME final (approaching) or initial (receding) event is repeated, at fixed level\n");
		fprintf(stdout,"INFO: and these events are ADDED to the input events.\n");
		break;
	case(TAN_LIST):
		fprintf(stdout,"INFO: PLAY SEQUENCE OF MONO SOUNDS (IN A TEXTFILE LIST OF SOUNDS) ON TANGENT PATH TO AN 8-CHANNEL RING OF LSPKRS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: loudspeaker array is numbered clockwise, starting with \"1\" at front-centre.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Different modes have different tangent styles...\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FAR TANGENT  .... For focus at speaker 1, starts along line at right-angles to speaker 2.\n");
		fprintf(stdout,"INFO: NEAR TANGENT .... For focus at speaker 1, starts along line formed by speakers 2 and 3.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION ....... Duration of output file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAXIMUM ANGLE .. (Far Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
		fprintf(stdout,"INFO:                       Max angle of rotation of the motion lies between 3rd pair (  i.e. between  90 to 135 degrees).\n");
		fprintf(stdout,"INFO:                       (lsprks 3-4 in the example)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SKEW  ....... .. (Near Tangent Modes) The motion lies between 3 lspkr pairs (e.g. 1-2, 2-3, 3-4)\n");
		fprintf(stdout,"INFO:                       Skew is the ratio (0-1) of time spent between the last pair & the penultimate pair of lspkrs.\n");
		fprintf(stdout,"INFO:                       (lspkr pairs 3-4 and 2-3, in the example)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DECIMATION ..... Loudness decimation on passing from one event to the next.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FOCUS POSITION .. Loudpseaker at which the motion ends (approaching motion) or begins (receding motion).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: JITTER ..........  Randomisation of event timings (0-1, default 0) Can vary over time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DRAG ........... Slows the pan-motion acceleration.\n");
		fprintf(stdout,"INFO:                  Smaller values make stream proceed more slowly to (or from) the focus position.\n");
		fprintf(stdout,"INFO:                  For approaching motion, 0.5 avoids the arrival being too fast to tell.\n");
		fprintf(stdout,"INFO:                  For receding motion, 1.0, makes the initial motion rapid.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RECEDE ........  Sounds Recede (default, sounds approach).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AT LEFT .......  Motion is to or from the left of the focal lspkr (default: motion is to or from the right).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Note that in the part of the stream closest to the focal lspkr,\n");
		fprintf(stdout,"INFO: the SAME final (approaching) or initial (receding) event is repeated, at fixed level.\n");
		fprintf(stdout,"INFO: and these repeated events are ADDED to the input events.\n");
		break;
	case(SPECTWIN):
		fprintf(stdout,"INFO: INTERBREED THE SPECTRAL CONTENT OF TWO DIFFERENT SOUNDS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Spectral envelope may be drawn over the local-maxima of the channel-levels (Formant Envelope)\n");
		fprintf(stdout,"INFO: or simply follow the amplitude changes from one channel to the next (Absolute Envelope)\n");
		fprintf(stdout,"info: Spectral envelops are interbred as follows ....\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FORMANTS SND 1 WITH FORMANTS SND 2.\n");
		fprintf(stdout,"INFO: FORMANTS SND 1 WITH ABSOLUTE SND 2.\n");
		fprintf(stdout,"INFO: ABSOLUTE SND 1 WITH FORMANTS SND 2.\n");
		fprintf(stdout,"INFO: ABSOLUTE SND 1 WITH ABSOLUTE SND 2.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FREQUENCY INTERPOLATION .... Dominance of spectral frequencies of 2nd input file.\n");
		fprintf(stdout,"INFO:            Values > 0 move channel frequencies from those of file 1 towards those of file 2.\n");
		fprintf(stdout,"INFO: ENVELOPE INTERPOLATION ..... Dominance of spectral envelope of 2nd input file.\n");
		fprintf(stdout,"INFO:            Values > 0 move the envelope from that of file 1 towards that of file 2.\n");
		fprintf(stdout,"INFO:            Note that when Formant and Absolute envelopes are combined,\n");
		fprintf(stdout,"INFO:            the formant peaks are moved onto the absolute envelope,\n");
		fprintf(stdout,"INFO:            with all other channels moving proportionately.\n");
		fprintf(stdout,"INFO: SPECTRAL DUPLICATIONS .... Adds transposed copies to spectrum 1, before proceeding.\n");
		fprintf(stdout,"INFO: DUPLICATION INTERVAL .... Transposition from one duplication to next, in semitones.\n");
		fprintf(stdout,"INFO: DUPLICATION ROLLOFF ....  Level change in passing to next higher duplication.\n");
		break;
	case(TRANSIT):
	    fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS REPETITIONS OF A MONO SOUND\n");
		fprintf(stdout,"INFO:          ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
		fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
		fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
		fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
		fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
		fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
		fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
		fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
		fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
		fprintf(stdout,"INFO:  REPETITIONS ...... Count of events from centre to edge (ONLY).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Total duration and number of repetitions will be double these values, as the mix approaches and then recedes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
		fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
		fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  To extend the motion further (which increases the duration and the number of repetitions)....\n");
		fprintf(stdout,"INFO:  the (gain) decimation can be modified with these 4 parameters ... \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  THRESHOLD FOR EXTENSION.. Value of (decimated) gain at which gain the decimation starts to increase.\n");
		fprintf(stdout,"INFO:  DECIMATION MAXIMUM ......... Maximum level of decimation after it starts to increase (> DECIMATION).\n");
		fprintf(stdout,"INFO:  FINAL GAIN ....................... Decimated gain at which the event concludes ( < THRESHOLD).\n");
		fprintf(stdout,"INFO:  MAXIMUM DURATION .......... Maximum duration of motion from centre to edge (in case FINAL GAIN is never reached) ( >= DURATION).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
		break;
	case(TRANSITF):
	    fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS REPETITIONS OF A PAIR OF MONO SOUNDS\n");
		fprintf(stdout,"INFO:               ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  The 2nd sound is gradually mixed in to the first as distance from focus increases.\n");
		fprintf(stdout,"INFO:  If 2nd sound is a filtered version of the first, this may suggest greater distance.\n");
		fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
		fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
		fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
		fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
		fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
		fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
		fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
		fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
		fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
		fprintf(stdout,"INFO:  REPETITIONS ...... Count of events from centre to edge (ONLY).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Total duration and number of repetitions will be double these values, as the mix approaches and then recedes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
		fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
		fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
		fprintf(stdout,"INFO:  BALANCE DECIMATION ..Proportion of 2nd sound mixed into first as sound becomes more distant from focus.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  To extend the motion further (which increases the duration and the number of repetitions)....\n");
		fprintf(stdout,"INFO:  the (gain) decimation can be modified with these 4 parameters ... \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  THRESHOLD FOR EXTENSION.. Value of (decimated) gain at which gain the decimation starts to increase.\n");
		fprintf(stdout,"INFO:  DECIMATION MAXIMUM ......... Maximum level of decimation after it starts to increase (> DECIMATION).\n");
		fprintf(stdout,"INFO:  FINAL GAIN ....................... Decimated gain at which the event concludes ( < THRESHOLD).\n");
		fprintf(stdout,"INFO:  MAXIMUM DURATION .......... Maximum duration of motion from centre to edge (in case FINAL GAIN is never reached) ( >= DURATION).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
		break;
	case(TRANSITD):
	    fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS REPETITIONS OF A MONO SOUND\n");
		fprintf(stdout,"INFO:        ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS,\n");
		fprintf(stdout,"INFO:                      SHIFTING TO 2nd SOUND ON PASSING FOCUS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  The 2nd sound replaces the first once the focus of the motion is passed.\n");
		fprintf(stdout,"INFO:  If the 2nd sound is a pitch-shifted version of the 1st, this may suggest doppler-shift.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Additional sounds may be input, to place at the centre point of the mix (near the focus)\n");
		fprintf(stdout,"INFO:  suggesting gradual changes in pitch at the doppler-shift moment.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
		fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
		fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
		fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
		fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
		fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
		fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
		fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
		fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
		fprintf(stdout,"INFO:  REPETITIONS ...... Count of events from centre to edge (ONLY).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Total duration and number of repetitions will be double these values, as the mix approaches and then recedes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
		fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
		fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  To extend the motion further (which increases the duration and the number of repetitions)....\n");
		fprintf(stdout,"INFO:  the (gain) decimation can be modified with these 4 parameters ... \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  THRESHOLD FOR EXTENSION.. Value of (decimated) gain at which gain the decimation starts to increase.\n");
		fprintf(stdout,"INFO:  DECIMATION MAXIMUM ......... Maximum level of decimation after it starts to increase (> DECIMATION).\n");
		fprintf(stdout,"INFO:  FINAL GAIN ....................... Decimated gain at which the event concludes ( < THRESHOLD).\n");
		fprintf(stdout,"INFO:  MAXIMUM DURATION .......... Maximum duration of motion from centre to edge (in case FINAL GAIN is never reached) ( >= DURATION).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
		break;
	case(TRANSITFD):
	    fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS REPETITIONS OF A PAIR OF MONO SOUNDS\n");
		fprintf(stdout,"INFO:        ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS,\n");
		fprintf(stdout,"INFO:                      SHIFTING TO 2nd PAIR ON PASSING FOCUS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  The 2nd sound is gradually mixed in to the first as distance from focus increases.\n");
		fprintf(stdout,"INFO:  If 2nd sound is a filtered version of the first, this may suggest greater distance.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  The 3rd sound replaces the first once the focus of the motion is passed.\n");
		fprintf(stdout,"INFO:  If the 3rd sound is a pitch-shifted version of the 1st, this may suggest doppler-shift.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  The 4th sound is gradually mixed in to the 3rd, as with sounds 1 and 2.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Additional sounds may be input, to place at the centre point of the mix (near the focus)\n");
		fprintf(stdout,"INFO:  suggesting gradual changes in pitch at the doppler-shift moment.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
		fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
		fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
		fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
		fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
		fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
		fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
		fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
		fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
		fprintf(stdout,"INFO:  REPETITIONS ...... Count of events from centre to edge (ONLY).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Total duration and number of repetitions will be double these values, as the mix approaches and then recedes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
		fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
		fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
		fprintf(stdout,"INFO:  BALANCE DECIMATION ..Proportion of 2nd(4th) sound mixed into 1st(3rd) as sound becomes more distant from focus.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  To extend the motion further (which increases the duration and the number of repetitions)....\n");
		fprintf(stdout,"INFO:  the (gain) decimation can be modified with these 4 parameters ... \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  THRESHOLD FOR EXTENSION.. Value of (decimated) gain at which gain the decimation starts to increase.\n");
		fprintf(stdout,"INFO:  DECIMATION MAXIMUM ......... Maximum level of decimation after it starts to increase (> DECIMATION).\n");
		fprintf(stdout,"INFO:  FINAL GAIN ....................... Decimated gain at which the event concludes ( < THRESHOLD).\n");
		fprintf(stdout,"INFO:  MAXIMUM DURATION .......... Maximum duration of motion from centre to edge (in case FINAL GAIN is never reached) ( >= DURATION).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
		break;
	case(TRANSITS):
	    fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS A SEQUENCE OF MONO SOUND\n");
		fprintf(stdout,"INFO:          ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
		fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
		fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
		fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
		fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
		fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
		fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
		fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
		fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Total duration will be double this value, as the mix approaches and then recedes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
		fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
		fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
		break;
	case(TRANSITL):
	    fprintf(stdout,"INFO:  CREATE MULTICHANNEL MIX WHICH POSITIONS A SEQUENCE OF MONO SOUND LISTED IN A TEXTFILE\n");
		fprintf(stdout,"INFO:          ON TANGENT PATH TO AND FROM AN 8-CHANNEL RING OF LSPKRS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Loudspeakers assumed to be equidistant in a ring, and numbered clockwise.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         GLANCING                EDGEWISE                  CROSSING                   CLOSE                   CENTRAL\n");
		fprintf(stdout,"INFO:           ---O->>            ->>--O---O->>                       O                          O      O                          O\n");
		fprintf(stdout,"INFO:       O              O                                           ->>--O-------O->>                                           O              O\n");
		fprintf(stdout,"INFO:                                       O                  O                                    ->>-O--------------O->>\n");
		fprintf(stdout,"INFO:     O                  O                                              O                  O                                  ->>-O---------------O->>\n");
		fprintf(stdout,"INFO:                                       O                  O                                            O                  O\n");
		fprintf(stdout,"INFO:       O              O                                                  O              O                                              O              O\n");
		fprintf(stdout,"INFO:               O                            O      O                            O                          O      O                          O\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  FOCUS ............ Centre of motion. Integer for odd modes, 1.5 ; 2.5 etc for even modes.\n");
		fprintf(stdout,"INFO:  DURATION ......... Duration of motion from centre to edge (ONLY).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  Total duration will be double this value, as the mix approaches and then recedes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  MAXIMUM RANGE .... (Modes 1-4) Maximum angle from centreline reached ( < 90).\n");
		fprintf(stdout,"INFO:                                 (Mode 5) Maximum distance from centre, where centre-to-loudspeaker distance is 1.\n");
		fprintf(stdout,"INFO:  DECIMATION ....... Gain multiplier (>0 <1) on passing from one event to the next, away from the focus.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:  LEFTWARDS FROM FOCUS .... Motion towards left of focal position (Default: motion towards right).\n");
		break;
	case(CANTOR):
	    fprintf(stdout,"INFO:  GRADUALLY INSERT HOLES INTO A SOURCE, IN THE MANNER OF A CANTOR SET\n");
		fprintf(stdout,"INFO: \n");
	    fprintf(stdout,"INFO:  A hole is gradually cut in the middle of the source sound, dividing into two parts.\n");
	    fprintf(stdout,"INFO:  Then holes are cut in these two parts, and so on.\n");
	    fprintf(stdout,"INFO:  The output is a set of versions of the source, with more and more holes.\n");
		fprintf(stdout,"INFO:  \n");
		fprintf(stdout,"INFO:  MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO:  \n");
		fprintf(stdout,"INFO:  MODE 1 .... Holesize proportional to size of segment they cut.\n");
		fprintf(stdout,"INFO:  MODE 2 .... Holesize is fixed.\n");
		fprintf(stdout,"INFO:  MODE 3 .... Holes generated by  superimposed layers of sinusoindal envelope-shapng..\n");
		fprintf(stdout,"INFO:  \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO:  \n");
		fprintf(stdout,"INFO:  In Modes 1 & 2\n");
		fprintf(stdout,"INFO:  \n");
		fprintf(stdout,"INFO:  HOLE SIZE ........ Percentage of the input sound (or sound segment) taken up by the hole.\n");
		fprintf(stdout,"INFO:  DIG DEPTH ........ Depth of each cut (as a fraction of 1) as hole is gradually created.\n");
		fprintf(stdout,"INFO:  TRIGGER DEPTH .... Depth of hole at which next pair of holes start to be dug.\n");
		fprintf(stdout,"INFO:  SPLICE LENGTH .... Splice length in milliseconds.\n");
		fprintf(stdout,"INFO:  MAXIMUM DURATION.. Maximum total duration of all the output sounds.\n");
		fprintf(stdout,"INFO:  EXTEND TO LIMIT .. Proceed with hole digging even when there are not enough samples left to create splices.\n");
		fprintf(stdout,"INFO:  \n");
		fprintf(stdout,"INFO:  In Modes 3\n");
		fprintf(stdout,"INFO:  \n");
		fprintf(stdout,"INFO:  MNIMUM HOLE LEVEL .. Level of signal at base of holes.\n");
		fprintf(stdout,"INFO:  DIG DEPTH .......... Number of repetitions for hole to reach its maximum depth.\n");
		fprintf(stdout,"INFO:  LAYER COUNT ........ Number of enveloping layers used.\n");
		fprintf(stdout,"INFO:  LAYER DECIMATION ... Relative depth at which each layer is imposed.\n");
		fprintf(stdout,"INFO:  MAXIMUM DURATION.... Maximum total duration of all the output sounds.\n");
		break;
	case(SHRINK):
		switch(mode) {
		case(0):
		case(1):
		case(2):
		case(3):
			switch(mode) {
			case(0):
				fprintf(stdout,"INFO:  REPEAT A SOUND, SHRINKING IT, BY REMOVING ITS END, AS THE REPETITIONS PROCEEDS.\n");
				break;
			case(1):
				fprintf(stdout,"INFO:  REPEAT A SOUND, SHRINKING IT AROUND ITS MIDPOINT AS THE REPETITIONS PROCEEDS.\n");
				break;
			case(2):
				fprintf(stdout,"INFO:  REPEAT A SOUND, SHRINKING IT, BY REMOVING ITS BEGINNING, AS THE REPETITIONS PROCEEDS.\n");
				break;
			case(3):
				fprintf(stdout,"INFO:  REPEAT A SOUND, SHRINKING IT AROUND A SPECIFIED TIME, AS THE REPETITIONS PROCEEDS.\n");
				break;
			}
			fprintf(stdout,"INFO:  \n");
			fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
			fprintf(stdout,"INFO:  \n");
			if(mode == 3)
				fprintf(stdout,"INFO:  CENTRE OF SHRINKAGE.. Time around which shrinkage takes place.\n");
			fprintf(stdout,"INFO:  SOUND SHRINKAGE ..... Shortening factor of sound from one repeat to the next.\n");
			fprintf(stdout,"INFO:                                                Shrinkage stops once events become too short for the splices.\n");
			fprintf(stdout,"INFO:  EVENT GAP ........... Initial timestep between output events (>= input sound duration).\n");
			fprintf(stdout,"INFO:  TIME CONTRACTION .....Shortening of time between placement of sounds in output stream.\n");
			fprintf(stdout,"INFO:                                                1.0 = events equally spaced, < 1.0 events become closer\n");
			fprintf(stdout,"INFO:                                                Events cannot overlap, so the minimum value of \"contraction\" = value of \"sound shrinkage\".\n");
			fprintf(stdout,"INFO:  DURATION ............ (Minimum) duration of the output.\n");
			fprintf(stdout,"INFO:  SPLICE LENGTH ....... Length of splices, in millseconds.\n");
			fprintf(stdout,"INFO:  MINIMUM EVENT DURATION ....... When sound duration reaches this minimum, shrinkage stops and events thereafter are of equal length.\n");
			fprintf(stdout,"INFO:  MINIMUM EVENT SEPARATION ..... When event separation reaches this minimum, contraction stops and events thereafter are equally spaced in time.\n");
			fprintf(stdout,"INFO:  EVENT TIME RANDOMISATION ..... Randomisation of entry times of events.\n");
			fprintf(stdout,"INFO:  EQUALISE EVENT LEVELS ........ Force the (maximum) level of all output events to that of the input event (if possible).\n");
			fprintf(stdout,"INFO:  REVERSE SEGMENTS ............. Output events are each reversed, but remain in the same time order.\n");
			break;
		case(4):
		case(5):
			switch(mode) {
			case(4):
				fprintf(stdout,"INFO:  IN A SOUND, SHRINK EVENTS CENTRED ROUND DETECTABLE PEAKS.\n");
				break;
			case(5):
				fprintf(stdout,"INFO:  IN A SOUND, SHRINK EVENTS CENTRED ROUND USER-SPECIFIED PEAKS.\n");
				break;
			}
			fprintf(stdout,"INFO:  \n");
			fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
			fprintf(stdout,"INFO:  \n");
			if(mode == 5)
				fprintf(stdout,"INFO:  PEAK TIMES .......... A textfile listing the times of peaks in the input sound file.\n");
			fprintf(stdout,"INFO:  SOUND SHRINKAGE ..... Shortening factor of sound from one repeat to the next.\n");
			fprintf(stdout,"INFO:                                                Shrinkage stops once events become too short for the splices.\n");
			if(mode == 4)
				fprintf(stdout,"INFO:  WINDOW SIZE ......... Size of window for peak detection (in milliSeconds).\n");
			else
				fprintf(stdout,"INFO:  WINDOW SIZE ......... Size of window for minima detection (in milliSeconds).\n");
			fprintf(stdout,"INFO:  TIME CONTRACTION .....Shortening of time between placement of sounds in output stream.\n");
			fprintf(stdout,"INFO:                                                1.0 = events equally spaced, < 1.0 events become closer\n");
			fprintf(stdout,"INFO:                                                Events cannot overlap, so the minimum value of \"contraction\" = value of \"sound shrinkage\".\n");
			fprintf(stdout,"INFO:  SHRINKAGE START...... Time at which shrinking begins.\n");
			fprintf(stdout,"INFO:  SPLICE LENGTH ....... Length of splices, in millseconds.\n");
			fprintf(stdout,"INFO:  MINIMUM EVENT DURATION ....... When sound duration reaches this minimum, shrinkage stops.\n");
			fprintf(stdout,"INFO:  MINIMUM EVENT SEPARATION ..... When event separation reaches this minimum, contraction stops.\n");
			fprintf(stdout,"INFO:  EVENT TIME RANDOMISATION ..... Randomisation of entry times of events.\n");
			fprintf(stdout,"INFO:  \n");
			fprintf(stdout,"INFO:  MINIMUM LENGTH FOR SQUEEZE START.....\n");
			fprintf(stdout,"INFO:                                 Minimum source-segment length before sound squeezing can begin (for the \"SQUEEZE EVENLY\" option)\n");
			fprintf(stdout,"INFO:  INPUT GATE .......... Input level (relative to the maximum level of the source) below which source-peaks are ignored.\n");
			if(mode == 4)
				fprintf(stdout,"INFO:  SKEW ................ Where, in the found source-segment, the sound is cut. e.g. 0 = at start  :  0.5 = in the middle  :  1 = at end.\n");
			fprintf(stdout,"INFO:  \n");
			fprintf(stdout,"INFO:  EQUALISE EVENT LEVELS ........ Force the (maximum) level of all output events to that of the input event (if possible).\n");
			fprintf(stdout,"INFO:  REVERSE SEGMENTS ............. Output events are each reversed, but remain in the same time order.\n");
			fprintf(stdout,"INFO:                        Mixing the output, then reversing the resultant sound produces an 'Expansion' of events,\n");
			fprintf(stdout,"INFO:                        opposite to the 'Shrinkage/Contraction'.\n");
			fprintf(stdout,"INFO:                        Note that the mixed sequence can be developed (each sound processed) to produce new, related sequences\n");
			fprintf(stdout,"INFO:                        which can be mixed using the same mix times as in the original.\n");
			fprintf(stdout,"INFO:                        If sounds processing involves any time-extension, start-times in the mix for the reversed segments will be altered.\n");
			fprintf(stdout,"INFO:                        Hence, with this flag set, an additional file is output listing the gaps between sound-ENDS in any mix\n");
			fprintf(stdout,"INFO:                        of the processed events.\n");
			fprintf(stdout,"INFO:  SQUEEZE EVENLY ............... If \"shrinkage\" > 0, sounds shorten in a regular manner.\n");
			fprintf(stdout,"INFO:                                                                If \"contraction\" > 0, output accelerates in a regular manner.\n");
			fprintf(stdout,"INFO:  OUTPUT GATE .................. Omit any too-quiet events, once a fixed end tempo has been reached.\n");
			break;
		}
		break;
	case(NEWTEX):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: GRANULATE SOURCE SOUND OVER TIME AND SPACE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Granulate several streams from a SINGLE source, where the source can be transposed.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TRANSPOSITION DATA ..... A textfile Listing of transposition ratios and relative levels, against time.\n");
			fprintf(stdout,"INFO:                     Data is a text file of lines of data and every line must have the same number of entries.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     The 1ST ENTRY on each line is a time. Times must start at zero and increase.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     All EVEN NUMBERED entries are transpositions, and these must increase through a line.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                     All other ODD NUMBERED entries are loudness levels for those transposition, between -1 and 1.\n");
			fprintf(stdout,"INFO:                     -ve values invert the phase of the source.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: DURATION ............ Total Duration of the output sound.\n");
			fprintf(stdout,"INFO: CHANNEL COUNT ... Number of output channels.\n");
			fprintf(stdout,"INFO: OCTAVE TRANSPOSITION.. Current range of additional octave transpositions of the original components.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TIMESTEP ............ Average timestep between changes in stream-content of output.\n");
			fprintf(stdout,"INFO: SPLICETIME (mS).... Length of fade-in/out times of components in output sound, in milliseconds.\n");
			fprintf(stdout,"INFO: STREAMS IN PLAY . Number of streams used in any segment: If set to ZERO, number of streams used is random.\n");
			fprintf(stdout,"INFO: MAXCHANGE COMPONENTS  As far as possible, always change components used, from one segment to the next.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: EMERGENCE CHANNEL .. If spatial image emerges from a single channel, to fill the space, this is the channel.\n");
			fprintf(stdout,"INFO: EMERGENCE TIME .... If spatial image emerges from a single channel, time taken to fully emerge.\n");
			fprintf(stdout,"INFO: CONVERGENCE CHANNEL .. If spatial image converges to a single channel at end of sound, this is the channel.\n");
			fprintf(stdout,"INFO: CONVERGENCE TIME . If spatial image converges to a single channel, time taken to fully converge.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Note that Emergence always works but, because of the nature of the algorithm, Convergence is only a tendency\n");
			fprintf(stdout,"INFO: and the signal may not all converge to the specified convergence channel.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: For NO EMERGENCE or NO CONVERGENCE, set the relevant values to ZERO.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: JUMP .................. Use same spatial position for all components in a segment.\n");
			fprintf(stdout,"INFO: ROTATION SPEED .... Rotation speed for Special Space Type 3 (only).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPECIAL SPACE TYPE  (8-channel files only) .... Special types of spatialisation.\n");
			fprintf(stdout,"INFO:    1:  Left-Right Rand ........... Alternate Left and Right sides, random positions.\n");
			fprintf(stdout,"INFO:    2:  Front-Back Rand .......... Alternate Front and back areas of space , random positions.\n");
			fprintf(stdout,"INFO:    3:  Rotate ...................... (Requires a positive or negative rotation speed).\n");               
			fprintf(stdout,"INFO:    4:  Superspace1 ............... Single channel positions only.\n");
			fprintf(stdout,"INFO:    5:  Superspace2 ............... Single channels and channel-pairs only.\n");
			fprintf(stdout,"INFO:    6:  Superspace3 ............... Single channels and channel-pairs and channel-triples only.\n");
			fprintf(stdout,"INFO:    7:  Superspace4 ............... Single channels, channel-pairs, channel-triples, square, diamond and all-positions.\n");
			fprintf(stdout,"INFO:    8:  Left-Right Alternate ....... Alternate Left and Right sides, using all channels of each.\n");
			fprintf(stdout,"INFO:    9:  Back-Front Alternate ...... Alternate Back and Front areas, using all channels of each.\n");
			fprintf(stdout,"INFO:    10: Frameswitch ............... Alternate Between Square and Diamond 4-sets.\n");
			fprintf(stdout,"INFO:    11: Triangle Rotate 1 ......... Rotate a triple of alternate channels, clockwise.\n");
			fprintf(stdout,"INFO:    12: Triangle AntiRotate 1 ..... Rotate a triple of alternate channels, anticlockwise.\n");
			fprintf(stdout,"INFO:    13: Triangle Rotate 2 ......... Rotate a channel and the pair opposite, clockwise.\n");
			fprintf(stdout,"INFO:    14: Triangle AntiRotate 2 ..... Rotate a channel and the pair opposite, anticlockwise.\n");
			break;
		case(1):
			fprintf(stdout,"INFO: GRANULATE SEVERAL SOURCE SOUNDS OVER TIME AND SPACE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Granulate a group of sounds, where the sources are not transposed.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: DURATION ............ Total Duration of the output sound.\n");
			fprintf(stdout,"INFO: CHANNEL COUNT ... Number of output channels.\n");
			fprintf(stdout,"INFO: MAX SOURCE DUPLICATION...... Maximum number of simultaneous streams of any one source.\n");
			fprintf(stdout,"INFO: DELAY ................. Time delay between duplicated streams.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TIMESTEP ............ Average timestep between changes in stream-content of output.\n");
			fprintf(stdout,"INFO: SPLICETIME (mS).... Length of fade-in/out times of components in output sound, in milliseconds.\n");
			fprintf(stdout,"INFO: STREAMS IN PLAY . Number of streams used in any segment: If set to ZERO, number of streams used is random.\n");
			fprintf(stdout,"INFO: MAXCHANGE COMPONENTS  As far as possible, always change components used, from one segment to the next.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: EMERGENCE CHANNEL .. If spatial image emerges from a single channel, to fill the space, this is the channel.\n");
			fprintf(stdout,"INFO: EMERGENCE TIME .... If spatial image emerges from a single channel, time taken to fully emerge.\n");
			fprintf(stdout,"INFO: CONVERGENCE CHANNEL .. If spatial image converges to a single channel at end of sound, this is the channel.\n");
			fprintf(stdout,"INFO: CONVERGENCE TIME . If spatial image converges to a single channel, time taken to fully converge.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Note that Emergence always works but, because of the nature of the algorithm, Convergence is only a tendency\n");
			fprintf(stdout,"INFO: and the signal may not all converge to the specified convergence channel.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: For NO EMERGENCE or NO CONVERGENCE, set the relevant values to ZERO.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: JUMP .................. Use same spatial position for all components in a segment.\n");
			fprintf(stdout,"INFO: ROTATION SPEED .... Rotation speed for Special Space Type 3 (only).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPECIAL SPACE TYPE  (8-channel files only) .... Special types of spatialisation.\n");
			fprintf(stdout,"INFO:    1:  Left-Right Rand ........... Alternate Left and Right sides, random positions.\n");
			fprintf(stdout,"INFO:    2:  Front-Back Rand .......... Alternate Front and back areas of space , random positions.\n");
			fprintf(stdout,"INFO:    3:  Rotate ...................... (Requires a positive or negative rotation speed).\n");               
			fprintf(stdout,"INFO:    4:  Superspace1 ............... Single channel positions only.\n");
			fprintf(stdout,"INFO:    5:  Superspace2 ............... Single channels and channel-pairs only.\n");
			fprintf(stdout,"INFO:    6:  Superspace3 ............... Single channels and channel-pairs and channel-triples only.\n");
			fprintf(stdout,"INFO:    7:  Superspace4 ............... Single channels, channel-pairs, channel-triples, square, diamond and all-positions.\n");
			fprintf(stdout,"INFO:    8:  Left-Right Alternate ....... Alternate Left and Right sides, using all channels of each.\n");
			fprintf(stdout,"INFO:    9:  Back-Front Alternate ...... Alternate Back and Front areas, using all channels of each.\n");
			fprintf(stdout,"INFO:    10: Frameswitch ............... Alternate Between Square and Diamond 4-sets.\n");
			fprintf(stdout,"INFO:    11: Triangle Rotate 1 ......... Rotate a triple of alternate channels, clockwise.\n");
			fprintf(stdout,"INFO:    12: Triangle AntiRotate 1 ..... Rotate a triple of alternate channels, anticlockwise.\n");
			fprintf(stdout,"INFO:    13: Triangle Rotate 2 ......... Rotate a channel and the pair opposite, clockwise.\n");
			fprintf(stdout,"INFO:    14: Triangle AntiRotate 2 ..... Rotate a channel and the pair opposite, anticlockwise.\n");
			break;
		case(2):
			fprintf(stdout,"INFO: GRANULATE SOURCE SOUND(S) OVER TIME AND SPACE, WITH DRUNKEN WALK THROUGH SOURCE(S).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The sources are not transposed.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: DURATION ............ Total Duration of the output sound.\n");
			fprintf(stdout,"INFO: CHANNEL COUNT ... Number of output channels.\n");
			fprintf(stdout,"INFO: MAX SOURCE DUPLICATION...... Maximum number of simultaneous streams of any one source.\n");
			fprintf(stdout,"INFO: LOCUS ................................. Time around which (next) source-read begins.\n");
			fprintf(stdout,"INFO: AMBITUS ............................ Area around locus within which next source-segment read may start.\n");
			fprintf(stdout,"INFO: DRUNK STEP ..................... Maximum size of random leap in source between start of this read and start of next.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TIMESTEP ............ Average timestep in output between changes in stream-content.\n");
			fprintf(stdout,"INFO: SPLICETIME (mS).... Length of fade-in/out times of components in output sound, in milliseconds.\n");
			fprintf(stdout,"INFO: STREAMS IN PLAY . Number of streams used in any segment: If set to ZERO, number of streams used is random.\n");
			fprintf(stdout,"INFO: MAXCHANGE COMPONENTS  As far as possible, always change components used, from one segment to the next.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: EMERGENCE CHANNEL .. If spatial image emerges from a single channel, to fill the space, this is the channel.\n");
			fprintf(stdout,"INFO: EMERGENCE TIME .... If spatial image emerges from a single channel, time taken to fully emerge.\n");
			fprintf(stdout,"INFO: CONVERGENCE CHANNEL .. If spatial image converges to a single channel at end of sound, this is the channel.\n");
			fprintf(stdout,"INFO: CONVERGENCE TIME . If spatial image converges to a single channel, time taken to fully converge.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Note that Emergence always works but, because of the nature of the algorithm, Convergence is only a tendency\n");
			fprintf(stdout,"INFO: and the signal may not all converge to the specified convergence channel.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: For NO EMERGENCE or NO CONVERGENCE, set the relevant values to ZERO.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: JUMP .................. Use same spatial position for all components in a segment.\n");
			fprintf(stdout,"INFO: ROTATION SPEED .... Rotation speed for Special Space Type 3 (only).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SPECIAL SPACE TYPE  (8-channel files only) .... Special types of spatialisation.\n");
			fprintf(stdout,"INFO:    1:  Left-Right Rand ........... Alternate Left and Right sides, random positions.\n");
			fprintf(stdout,"INFO:    2:  Front-Back Rand .......... Alternate Front and back areas of space , random positions.\n");
			fprintf(stdout,"INFO:    3:  Rotate ...................... (Requires a positive or negative rotation speed).\n");               
			fprintf(stdout,"INFO:    4:  Superspace1 ............... Single channel positions only.\n");
			fprintf(stdout,"INFO:    5:  Superspace2 ............... Single channels and channel-pairs only.\n");
			fprintf(stdout,"INFO:    6:  Superspace3 ............... Single channels, channel-pairs and triangles only.\n");
			fprintf(stdout,"INFO:    7:  Superspace4 ............... Single channels, channel-pairs, triangles, square, diamond and all-positions.\n");
			fprintf(stdout,"INFO:    8:  Left-Right Alternate ....... Alternate Left and Right sides, using all channels of each.\n");
			fprintf(stdout,"INFO:    9:  Back-Front Alternate ...... Alternate Back and Front areas, using all channels of each.\n");
			fprintf(stdout,"INFO:    10: Frameswitch ............... Alternate Between Square and Diamond 4-sets.\n");
			fprintf(stdout,"INFO:    11: Triangle Rotate 1 ......... Rotate a triple of alternate channels, clockwise, speed determined by \"Timestep\".\n");
			fprintf(stdout,"INFO:    12: Triangle AntiRotate 1 ..... Rotate a triple of alternate channels, anticlockwise, speed determined by \"Timestep\".\n");
			fprintf(stdout,"INFO:    13: Triangle Rotate 2 ......... Rotate a channel and the pair opposite, clockwise, speed determined by \"Timestep\".\n");
			fprintf(stdout,"INFO:    14: Triangle AntiRotate 2 ..... Rotate a channel and the pair opposite, anticlockwise, speed determined by \"Timestep\".\n");
			break;
		}
		break;
	case(CERACU):
		fprintf(stdout,"INFO: SUPERIMPOSE DIFFERENT CYCLIC REPETITIONS OF A SOUND, UNTIL THE CYCLES RESYNCHRONISE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The source sound repeats at regular time-intervals.\n");
		fprintf(stdout,"INFO: There are 2 or more streams of such repetition, each with a different repetition time-interval.\n");
		fprintf(stdout,"INFO: A \"complete-cycle\" takes us from one point where all the streams are in sync to the next point where this is the case.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE COUNT DATA ................... A list of integers.\n");
		fprintf(stdout,"INFO:                                    The number of items in the list determines the number of simultaneous cycle-streams.\n");
		fprintf(stdout,"INFO:                                    The values entered determined how many repeats there are in each stream before all streams resynchronise.\n");
		fprintf(stdout,"INFO: SHORTEST REPEAT TIME .............. Time before the first repeat in the fastest cycle. If set to ZERO, assumed to be duration of input file.\n");
		fprintf(stdout,"INFO:                                    NB With many prime-number cycles, the \"Shortest Repeat Time\" may be adjusted upwards (sometimes considerably!)\n");
		fprintf(stdout,"INFO:                                    to allow all the repeating cycles to fit into a cycle with the correct number of repeats.\n");
		fprintf(stdout,"INFO:                                    (The minimum output duration, in samples, cannot be less than the Lowest Common Multiple of all the cycle-counts,\n");
		fprintf(stdout,"INFO:                                    and the cyclecnts will all be factors of this duration).\n");
		fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT ............ Number of output channels.\n");
		fprintf(stdout,"INFO: MINIMUM OUTPUT DURATION......... Minimum duration of the output. If set to ZERO, assumed to be one complete-cycle.\n");
		fprintf(stdout,"INFO:                                    Process always outputs a WHOLE NUMBER of complete-cycles\n");
		fprintf(stdout,"INFO:                                    and this output will be equal to or longer in duration than the output duration specified.\n");
		fprintf(stdout,"INFO: OVERRIDE LENGTH LIMIT ............. Force output to continue until a complete cycle is generated, no matter how long this may take.\n");
		fprintf(stdout,"INFO:                                    A warning will be given after 1 hour of output(!).\n");
		fprintf(stdout,"INFO:                                    No guarantee can be given that the program will not crash for extremely long durations.\n");
		fprintf(stdout,"INFO: ECHO DELAY ................................. An optional echo of the entire output can be added. To avoid this echo, set parameter to ZERO.\n");
		fprintf(stdout,"INFO:                                    The echo delay should not be greater than the \"Shortest Repeat Time\" BUT\n");
		fprintf(stdout,"INFO:                                    the \"Shortest Repeat Time\" may be recalculated (see program output) to accomodate\n");
		fprintf(stdout,"INFO: ECHO SPATIAL OFFSET ................ Any optional echo can be offset to a different channel.\n");
		fprintf(stdout,"INFO:                                    1 offset it 1 channel to the right, -1 offsets it 1 chyannel to the left, and so on.\n");
		fprintf(stdout,"INFO: LINEAR OUTPUT ARRAY ................ If output > stereo, loudspeaker array assumed to be in surround (circling the audience).\n");
		fprintf(stdout,"INFO:                                    But if this flag is set, the array is assumed to be linear (reaching from a leftmost to a rightmost point).\n");
		break;
	case(MADRID):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: REPEAT SOUND(S) WITH SPATIALISED ACCENTUATIONS.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The source sounds repeat, with several superimposed copies played at different spatial locations.\n");
			fprintf(stdout,"INFO: By randomly deleting events from these streams spatial relocations and accents are produced.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: OUTPUT DURATION ....................... Maximum Duration of output.\n");
			fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT ............... Number of channels in the output sound.\n");
			fprintf(stdout,"INFO: NUMBER OF STREAMS .................... Number of spatially distinct streams.\n");
			fprintf(stdout,"INFO: DELETION FACTOR ........................ Proportion of events to delete.\n");
			fprintf(stdout,"INFO:                                                        Values between 0 and 1 delete that proportion of events in the various streams.\n");
			fprintf(stdout,"INFO:                                                        For values greater than 1, the proportion of events at a single location increases.\n");
			fprintf(stdout,"INFO: and, if you \"ALLOW GAPS IN OUTPUT\", the proportion of empty events also increases.\n");
			fprintf(stdout,"INFO: EVENT TIME STEP .......................... Time-step between event repetitions.\n");
			fprintf(stdout,"INFO: EVENT TIME RANDOMISATION .......... Randomisation of time-step between event repetitions.\n");
			fprintf(stdout,"INFO: DELETION SEED VALUE .................... If the process is run a 2nd time, with the SAME parameters,\n");
			fprintf(stdout,"INFO:                                                        If the seed value is set to the same POSITIVE value, deletions will be the same.\n");
			fprintf(stdout,"INFO:                                                        If set to zero however, deletions will always be different, even when all other parameters are the same.\n");
			fprintf(stdout,"INFO: ALLOW GAPS IN OUTPUT ................. Some repeptition points may have NO sound at all.\n");
			fprintf(stdout,"INFO: LINEAR OUTPUT ARRAY .................. If output > stereo, loudspeaker array assumed to be in surround (circling the audience).\n");
			fprintf(stdout,"INFO:                                                        But if this flag is set, the array is assumed to be linear (reaching from a leftmost to a rightmost point).\n");
			fprintf(stdout,"INFO: RANDOMLY_PERMUTE_INFILE_ORDER . Randomly permuter order of input files, and play 1 of each in this order before creating the next order permutation.\n");
			fprintf(stdout,"INFO: RANDOMLY_SELECT_INFILE .............. Randomly select the next input file to use, independently of any previous selection.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: You cannot use BOTH Random Permutation AND Random Selection.\n");
			fprintf(stdout,"INFO: Neither of these flags is operational where there is only ONE input sound.\n");
			break;
		case(1):
			fprintf(stdout,"INFO: SEQUENCE SOUND(S) WITH SPATIALISED ACCENTUATIONS.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The source sounds follow each other in a defined sequence\n");
			fprintf(stdout,"INFO: with several superimposed copies played at different spatial locations.\n");
			fprintf(stdout,"INFO: By randomly deleting events from these streams spatial relocations and accents are produced.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SEQUENCE DATA ........................ Textfile of integers between 1 and the number of input files.\n");
			fprintf(stdout,"INFO:                                                        The sequence of numbers in this file determines the sequence of input files used in the output.\n");
			fprintf(stdout,"INFO: OUTPUT DURATION ....................... Maximum Duration of output.\n");
			fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT ............... Number of channels in the output sound.\n");
			fprintf(stdout,"INFO: NUMBER OF STREAMS .................... Number of spatially distinct streams.\n");
			fprintf(stdout,"INFO: DELETION FACTOR ........................ Proportion of events to delete.\n");
			fprintf(stdout,"INFO:                                                        Values between 0 and 1 delete that proportion of events in the various streams.\n");
			fprintf(stdout,"INFO:                                                        For values greater than 1, the proportion of events at a single location increases.\n");
			fprintf(stdout,"INFO: and, if you \"ALLOW GAPS IN OUTPUT\", the proportion of empty events also increases.\n");
			fprintf(stdout,"INFO: EVENT TIME STEP .......................... Time-step between event repetitions.\n");
			fprintf(stdout,"INFO: EVENT TIME RANDOMISATION .......... Randomisation of time-step between event repetitions.\n");
			fprintf(stdout,"INFO: DELETION SEED VALUE .................... If the process is run a 2nd time, with the SAME parameters,\n");
			fprintf(stdout,"INFO:                                                        If the seed value is set to the same POSITIVE value, deletions will be the same.\n");
			fprintf(stdout,"INFO:                                                        If set to zero however, deletions will always be different, even when all other parameters are the same.\n");
			fprintf(stdout,"INFO: ALLOW GAPS IN OUTPUT ................. Some repeptition points may have NO sound at all.\n");
			fprintf(stdout,"INFO: LINEAR OUTPUT ARRAY .................. If output > stereo, loudspeaker array assumed to be in surround (circling the audience).\n");
			fprintf(stdout,"INFO:                                                        But if this flag is set, the array is assumed to be linear (reaching from a leftmost to a rightmost point).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: You cannot use BOTH Random Permutation AND Random Selection.\n");
			fprintf(stdout,"INFO: Neither of these flags is operational where there is only ONE input sound.\n");
			break;
		}
		break;
	case(SHIFTER):
		fprintf(stdout,"INFO: GENERATE A SERIES OF SIMULTANEOUS REPETITION STREAMS WHERE THE RHYTHMIC PULSE SHIFTS FROM ONE TO THE OTHER.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The source sound repeats regularly in (specified) cycles.\n");
		fprintf(stdout,"INFO: The tempi of the cycles is arranged so that the streams resynchronise after a set number of repetitions.\n");
		fprintf(stdout,"INFO: e.g. 11,12,13 would set up 3 streams which repeat the sound 11,12 and 13 times, respectively, before the streams resynchronise.\n");
		fprintf(stdout,"INFO: The focus may shift from one stream to another (by loudness emphasis), as the output sound evolves.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE DATA ................................. Textfile list of at least 2 different integers with values  >= 2.\n");
		fprintf(stdout,"INFO:                                                        In Mode 2, the number of entries should equal the number of input sound-sources.\n");
		fprintf(stdout,"INFO:                                                        These numbers represent the count of repetitions in each output stream before the streams resynchronise.\n");
		fprintf(stdout,"INFO: CYCLE DURATION ........................ Duration from one streams-synchronisation-point to the next.\n");
		fprintf(stdout,"INFO:                                                        Cycle duration and cycle data together determine the tempi of the different streams.\n");
		fprintf(stdout,"INFO: MIN OUTPUT DURATION ................ Minimum Duration of the output.\n");
		fprintf(stdout,"INFO: OUTPUT CHANNEL COUNT ............. Number of channels in the output sound. The cycles play at fixed locations distributed over the output array.\n");
		fprintf(stdout,"INFO: MINIMUM BEAT DIVISION .............. Smallest integer subdivision of the beat: a multiple of 2 or 3, and greater than 4.\n");
		fprintf(stdout,"INFO:                                                        This determines the quantisation of the entry-times in the various streams.\n");
		fprintf(stdout,"INFO: LINGER CYCLES .......................... Number of cycles for which the focus is on any one cycle.\n");
		fprintf(stdout,"INFO: TRANSITION CYCLES .................... Number of cycles during which the focus moves from one cycle to another.\n");
		fprintf(stdout,"INFO:                                                        The sum of Linger cycles and Transition cycles must be >= 1.\n");
		fprintf(stdout,"INFO: FOCUS LEVEL BOOST .................... If the standard stream level is \"L\", the focus stream is increased in level by \"L\" times \"FOCUS LEVEL BOOST\".\n");
		fprintf(stdout,"INFO: LINEAR OUTPUT ARRAY .................. If output > stereo, loudspeaker array assumed to be in surround (circling the audience).\n");
		fprintf(stdout,"INFO:                                                        But if this flag is set, the array is assumed to be linear (reaching from a leftmost to a rightmost point).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In standard operation, focus shifts to each of the listed cycles in the order they appear in the data file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: READ BACK AND FORTH_THROUGH FOCUS .. Focus shifts gradually to the end of the data list, then back gradually towards the start, and so on.\n");
		fprintf(stdout,"INFO: RANDOMLY PERMUTE FOCUS ........... The cycle to focus on is determined by a random permutation of the order of the cycles.\n");
		fprintf(stdout,"INFO:                                                        Once all the cycles have been used, a new permutation is made.\n");
		fprintf(stdout,"INFO: You cannot use both Back-and-Forth AND Random focus shift.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FRACTURE):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: MONO SOUND GRADUALLY FRACTURES INTO ELEMENTS DISTRIBUTED IN SPACE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stderr,"INFO: The source is cut into fragments which are enveloped and possibly transpose-stacked\n");
			fprintf(stderr,"INFO: and these fragments are distributed in space.\n");
			fprintf(stderr,"INFO: Stacks are synchronised at the envelope peak of the fragment.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ENVELOPE SERIES ......... A text datafile of lines consisting of a time and 7 pairs of envelope data.\n");
			fprintf(stdout,"INFO:                                                       The times are abslute times and must start at 0 and advance.\"\n");
			fprintf(stdout,"INFO:                                                       Each pair of the 7 consists of an \"etime\" and a level value.\n");
			fprintf(stdout,"INFO:                                                       Etimes are RELATIVE times within the envelope.\n");
			fprintf(stdout,"INFO:                                                       In Each line they must start at 0, end at 1, and advance.\n");
			fprintf(stdout,"INFO:                                                       Levels values should lie between 0 and 1. The first and last values MUST be zero, and the maximum value MUST be 1.0.\n");
			fprintf(stdout,"INFO:                                                       Envelopes to use at a specific time are derived by interpolating between the given envelopes\n");
			fprintf(stdout,"INFO:                                                       and subsequently modifying their depth (how close to zero they cut - see below).\n");
			fprintf(stdout,"INFO: OUTPUT CHANNELS ......... The number of channels in the output file (2-16).\n");
			fprintf(stdout,"INFO: NUMBER OF SPATIAL STREAMS .. The number of spatial positions to which the resulting fragments are allotted ( >=4 ).\n");
			fprintf(stdout,"INFO: PULSE DURATION ............ The average time between each SET of fragments (one in each stream).\n");
			fprintf(stdout,"INFO: DEPTH AND STACK ........... Between 0 and 1 this parameter controls how deeply the envelopes cut into the source.\n");
			fprintf(stdout,"INFO:                                                       With depth 1 the envelope cuts down to zero (as in the input envelope data).\n");
			fprintf(stdout,"INFO:                                                       With depth 0.75 the envelope cuts 3/4 of the way to zero.\n");
			fprintf(stdout,"INFO:                                                       With depth 0 the envelope has NO EFFECT on the source.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                                                       Once the depth value exceeds 1, a STACK value is derived, being the depth minus 1.\n");
			fprintf(stdout,"INFO:                                                       Stacking adds transposed copies to the fragment, synchronised around the envelope peak.\n");
			fprintf(stdout,"INFO:                                                       With a Depth of 2, the Stack value is 1: The 1st transposed element is added at full level,\n");
			fprintf(stdout,"INFO:                                                       With a Depth of 1.5, the Stack value is .5: the transposed element is added at 1/2 level,\n");
			fprintf(stdout,"INFO:                                                       With a Depth of 2.5, the Stack value is 1.5: The first element is added at full level, the 2nd at 1/2 level\n");
			fprintf(stdout,"INFO:                                                       and so on.\n");
			fprintf(stdout,"INFO: STACKING INTERVAL ........ Interval of (upward) transposition in the stack, in semitones (0-12).\n");
			fprintf(stdout,"INFO:                                                       The (Default) zero value is read as an octave (12). Zeros MUST NOT BE USED in stack brkpoint files.\n");
			fprintf(stdout,"INFO: READ RANDOMISATION .... Randomisation of the fragment read-time in the source. Range 0-1.\n");
			fprintf(stdout,"INFO: PULSE RANDOMISATION ... Randomisation of the pulse duration. Range 0-1.\n");
			fprintf(stdout,"INFO:                                                       In both cases, maximum random scatter scatters within range +- half the duration of the fragment.\n");
			fprintf(stdout,"INFO: STREAM DISPERSAL ........ Scattering of the output timings amongst different streams.\n");
			fprintf(stdout,"INFO:                                                       If pulse(+randomisation) generates a timing \"P\",\n");
			fprintf(stdout,"INFO:                                                       With Dispersal 0 : all fragments start at \"P\".\n");
			fprintf(stdout,"INFO:                                                       With Dispersal 1 : fragments are scattered within a range of +- half the duration of the fragment.\n");
			fprintf(stdout,"INFO:                                                       Intermediate values scattered fragment start-times to various extents around the time \"W\".\n");
			fprintf(stdout,"INFO: LEVEL RANDOMISATION .... Randomisation of the levels of the fragments. Range  0 - 1.\n");
			fprintf(stdout,"INFO:                                                       With value 0: All fragments are at full level. Value 1 produces random levels between 0 & full level.\n");
			fprintf(stdout,"INFO: ENVELOPE RANDOMISATION .. Randomisation of the choice of source envelope.\n");
			fprintf(stdout,"INFO:                                                       This is a time-range between 0 and \"now\".\n");
			fprintf(stdout,"INFO:                                                       If set (>0) the time in the envelope data file at which the envelope is selected\n");
			fprintf(stdout,"INFO:                                                       is set randomly between \"now\" and \"now minus time-range\".\n");
			fprintf(stdout,"INFO: STACK RANDOMISATION .. Randomisation of the stacking depth.\n");
			fprintf(stdout,"INFO:                                                       If set to zero, stacking depth is determined completely by the depth parameter (S = D - 1).\n");
			fprintf(stdout,"INFO:                                                       If set to one, stacking depth is selected at random between 0 and the given value.\n");
			fprintf(stdout,"INFO:                                                       Intermediate values give intermediate random-selection ranges.\n");
			fprintf(stdout,"INFO: PITCH RANDOMISATION IN CENTS .. Randomisation of the transposition of the fragments.\n");
			fprintf(stdout,"INFO:                                                       If set to \"P\", Fragments are randomly transposed in pitch between +P and -P.\n");
			fprintf(stdout,"INFO: RANDOM SEED .............. If the seed value is set as ZERO, and randomising parameters are used,\n");
			fprintf(stdout,"INFO:                                                       running the process again with IDENTICAL parameters will produce DIFFERENT output (due to the the variable randomisation).\n");
			fprintf(stdout,"INFO:                                                       With a POSITIVE seed value, re-running the process with IDENTICAL randomising parameters produces IDENTICAL (randomised) output.\n");
			fprintf(stdout,"INFO: MINIMUM FRAGMENT DURATION .... Minimum duration of any fragment in any stream.\n");
			fprintf(stdout,"INFO: MAXIMUM FRAGMENT DURATION ... Maximum duration of any fragment in any stream.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PERMIT SHORT STACKS ... Normally, very sort events are not stacked (to prevent clipping). Setting this flag allows short events to be stacked.\n");
			fprintf(stdout,"INFO: LINEAR OUTPUT ARRAY ... If output > stereo, loudspeaker array assumed to be in surround (circling the audience).\n");
			fprintf(stdout,"INFO:                                                        But if this flag is set, the array is assumed to be linear (reaching from a leftmost to a rightmost point).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: NB Stacking, and the read, level & pitch randomisations ARE NOT ACTIVATED if the depth is less than 1.\n");
			break;
		case(1):
			fprintf(stdout,"INFO: MONO SOUND GRADUALLY FRACTURES INTO ELEMENTS DISTRIBUTED IN STEREO, THEN STEREO-IMAGE POSITIONED IN MULTICHANNEL SPACE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stderr,"INFO: The source is cut into fragments which are enveloped and possibly transpose-stacked\n");
			fprintf(stderr,"INFO: and these fragments are distributed in space.\n");
			fprintf(stderr,"INFO: Stacks are synchronised at the envelope peak of the fragment.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The stereo \"front\" is then positioned in multichannel space.\n");
			fprintf(stdout,"INFO: If the front moves it must always move forwards.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ENVELOPE SERIES ......... A text datafile of lines consisting of a time and 7 pairs of envelope data.\n");
			fprintf(stdout,"INFO:                                                       The times are abslute times and must start at 0 and advance.\"\n");
			fprintf(stdout,"INFO:                                                       Each pair of the 7 consists of an \"etime\" and a level value.\n");
			fprintf(stdout,"INFO:                                                       Etimes are RELATIVE times within the envelope.\n");
			fprintf(stdout,"INFO:                                                       In Each line they must start at 0, end at 1, and advance.\n");
			fprintf(stdout,"INFO:                                                       Levels values should lie between 0 and 1. The first and last values MUST be zero, and the maximum value MUST be 1.0.\n");
			fprintf(stdout,"INFO:                                                       Envelopes to use at a specific time are derived by interpolating between the given envelopes\n");
			fprintf(stdout,"INFO:                                                       and subsequently modifying their depth (how close to zero they cut - see below).\n");
			fprintf(stdout,"INFO: OUTPUT CHANNELS ......... The number of channels in the output file (2-16).\n");
			fprintf(stdout,"INFO: NUMBER OF SPATIAL STREAMS .. The number of spatial positions to which the resulting fragments are allotted ( >=4 ).\n");
			fprintf(stdout,"INFO: PULSE DURATION ............ The average time between each SET of fragments (one in each stream).\n");
			fprintf(stdout,"INFO: DEPTH AND STACK ........... Between 0 and 1 this parameter controls how deeply the envelopes cut into the source.\n");
			fprintf(stdout,"INFO:                                                       With depth 1 the envelope cuts down to zero (as in the input envelope data).\n");
			fprintf(stdout,"INFO:                                                       With depth 0.75 the envelope cuts 3/4 of the way to zero.\n");
			fprintf(stdout,"INFO:                                                       With depth 0 the envelope has NO EFFECT on the source.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                                                       Once the depth value exceeds 1, a STACK value is derived, being the depth minus 1.\n");
			fprintf(stdout,"INFO:                                                       Stacking adds transposed copies to the fragment, synchronised around the envelope peak.\n");
			fprintf(stdout,"INFO:                                                       With a Depth of 2, the Stack value is 1: The 1st transposed element is added at full level,\n");
			fprintf(stdout,"INFO:                                                       With a Depth of 1.5, the Stack value is .5: the transposed element is added at 1/2 level,\n");
			fprintf(stdout,"INFO:                                                       With a Depth of 2.5, the Stack value is 1.5: The first element is added at full level, the 2nd at 1/2 level\n");
			fprintf(stdout,"INFO:                                                       and so on.\n");
			fprintf(stdout,"INFO: STACKING INTERVAL ........ Interval of (upward) transposition in the stack, in semitones (0-12).\n");
			fprintf(stdout,"INFO:                                                       The (Default) zero value is read as an octave (12). Zeros MUST NOT BE USED in stack brkpoint files.\n");
			fprintf(stdout,"INFO: CENTRE OF IMAGE .......... Channel from which stereo image radiates (must be an integer).\n");
			fprintf(stdout,"INFO: FRONT POSITION ............ Position of stereo image in surround-space.\n");
			fprintf(stdout,"INFO:                                                       1 : front at centre lspkr.     -1: front at lspkr opposite to centre      0 : front at midline of surround-space.\n");
			fprintf(stdout,"INFO:                                                       2 : front infinitely far away in direction of centre lspkr.     -(2+(depth*2)) : front infinitely far away in direction opposite to centre lspkr.\n");
			fprintf(stdout,"INFO: DEPTH BEHIND FRONT ...... Fraction of total channels activated behind spreading front.\n");
			fprintf(stdout,"INFO: LEVEL ROLLOFF WITH ADDED CHANNELS .... Level compensation for addition of new output channels.\n");
			fprintf(stdout,"INFO:                                                       0, No rolloff, all channels play at full-current-level as they are added.\n");
			fprintf(stdout,"INFO:                                                       1, Full rolloff, levels fall to 1/N of full-current-level when Nth channels is added.\n");
			fprintf(stdout,"INFO:                                                       Intermediate values are possible.\n");
			fprintf(stdout,"INFO: READ RANDOMISATION .... Randomisation of the fragment read-time in the source. Range 0-1.\n");
			fprintf(stdout,"INFO: PULSE RANDOMISATION ... Randomisation of the pulse duration. Range 0-1.\n");
			fprintf(stdout,"INFO:                                                       In both cases, maximum random scatter scatters within range +- half the duration of the fragment.\n");
			fprintf(stdout,"INFO: STREAM DISPERSAL ........ Scattering of the output timings amongst different streams.\n");
			fprintf(stdout,"INFO:                                                       If pulse(+randomisation) generates a timing \"P\",\n");
			fprintf(stdout,"INFO:                                                       With Dispersal 0 : all fragments start at \"P\".\n");
			fprintf(stdout,"INFO:                                                       With Dispersal 1 : fragments are scattered within a range of +- half the duration of the fragment.\n");
			fprintf(stdout,"INFO:                                                       Intermediate values scattered fragment start-times to various extents around the time \"W\".\n");
			fprintf(stdout,"INFO: LEVEL RANDOMISATION .... Randomisation of the levels of the fragments. Range  0 - 1.\n");
			fprintf(stdout,"INFO:                                                       With value 0: All fragments are at full level. Value 1 produces random levels between 0 & full level.\n");
			fprintf(stdout,"INFO: ENVELOPE RANDOMISATION .. Randomisation of the choice of source envelope.\n");
			fprintf(stdout,"INFO:                                                       This is a time-range between 0 and \"now\".\n");
			fprintf(stdout,"INFO:                                                       If set (>0) the time in the envelope data file at which the envelope is selected\n");
			fprintf(stdout,"INFO:                                                       is set randomly between \"now\" and \"now minus time-range\".\n");
			fprintf(stdout,"INFO: STACK RANDOMISATION .. Randomisation of the stacking depth.\n");
			fprintf(stdout,"INFO:                                                       If set to zero, stacking depth is determined completely by the depth parameter (S = D - 1).\n");
			fprintf(stdout,"INFO:                                                       If set to one, stacking depth is selected at random between 0 and the given value.\n");
			fprintf(stdout,"INFO:                                                       Intermediate values give intermediate random-selection ranges.\n");
			fprintf(stdout,"INFO: PITCH RANDOMISATION IN CENTS .. Randomisation of the transposition of the fragments.\n");
			fprintf(stdout,"INFO:                                                       If set to \"P\", Fragments are randomly transposed in pitch between +P and -P.\n");
			fprintf(stdout,"INFO: RANDOM SEED .............. If the seed value is set as ZERO, and randomising parameters are used,\n");
			fprintf(stdout,"INFO:                                                       running the process again with IDENTICAL parameters will produce DIFFERENT output (due to the the variable randomisation).\n");
			fprintf(stdout,"INFO:                                                       With a POSITIVE seed value, re-running the process with IDENTICAL randomising parameters produces IDENTICAL (randomised) output.\n");
			fprintf(stdout,"INFO: MINIMUM FRAGMENT DURATION .... Minimum duration of any fragment in any stream.\n");
			fprintf(stdout,"INFO: MAXIMUM FRAGMENT DURATION ... Maximum duration of any fragment in any stream.\n");
			fprintf(stdout,"INFO: ATTENUATION FACTOR .......... Rapidity of attenuation of level of front, with distance from ring,\n");
			fprintf(stdout,"INFO:                                                       or during intrinsic fade-out of sound which doesn't recede into far distance.\n");
			fprintf(stdout,"INFO:                                                       1 = linear fade.\n");
			fprintf(stdout,"INFO: SUBTEND ZERO POINT ......... Point at which image becomes mono as it retreats from circle, or ceases being mono as it approaches the circle of loudspeakers.\n");
			fprintf(stdout,"INFO:                                                       Ratio of the required-distance(time)-to-the-subtend-zero-point to the total-distance(time)-to-infinity.\n");
			fprintf(stdout,"INFO: CONTRACTION FACTOR ...... Rate of contraction of image :  1 = linear.\n");
			fprintf(stdout,"INFO: MAX FILTER POINT ............ Point at which image becomes entirely lo-pass filtered as it retreats from circle, or begins to de-filter as it approaches the circle of loudspeakers.\n");
			fprintf(stdout,"INFO:                                                       Ratio of the required-distance(time)-to-the-max-filter-point to the total-distance(time)-to-infinity.\n");
			fprintf(stdout,"INFO: FILTER MIX FACTOR ............ Rate of replacement by filtered image :  1 = linear.\n");
			fprintf(stdout,"INFO: FILTER LOPASS FREQUENCY.. Low-pass cut-off frequency of distance-filter.\n");
			fprintf(stdout,"INFO: FADE IN ........................... Proportion of total duration over which event fades in from zero (independently of any fade associated with distance).\n");
			fprintf(stdout,"INFO: FADE OUT ......................... Proportion of total duration over which event decays to zero (independently of any fade associated with distance).\n");
			fprintf(stdout,"INFO: OVERALL GAIN ................. Overall gain: rare possibility that very rapid contraction with very low attenuation rate may cause overload in mixing to mono.\n");
			fprintf(stdout,"INFO:                                                       In case of overload, turn down inputs with \"Overall Gain\".\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PERMIT SHORT STACKS ... Normally, very sort events are not stacked (to prevent clipping). Setting this flag allows short events to be stacked.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: NB The stacking, level and repitching parameters DO NOT KICK IN until the depth reaches 1.\n");
			break;
		}
		break;
	case(SUBTRACT):
		fprintf(stdout,"INFO: SUBTRACTS A MONO FILE FROM (1 CHANNEL OF) ANOTHER FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The first file can have any number of channels.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHANNEL TO SUBTRACT .......... The number ( 1 - N ) of any channel in the 2nd file. (Setting to ZERO subtracts channel 1).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SPEKLINE):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: CREATING SPECTRUM FROM SPECTRAL LINES TEXT DATA.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: ANALYSIS CHANNELS .......................... Number of channels in output spectral file (multiple of 2).\n");
			fprintf(stdout,"INFO: SOUND SAMPLING RATE ...................... Sampling rate of sound which will eventually be generated.\n");
			fprintf(stdout,"INFO: OUTPUT DURATION .............................. Duration of output spectrum.\n");
			fprintf(stdout,"INFO: NO OF ADDED HARMONICS .................. Number of harmonics to add to basic input spctrum.\n");
			fprintf(stdout,"INFO: HARMONICS ROLLOFF(dB).................... Rolloff (in dB) proceeding from one harmonic to the next.\n");
			fprintf(stdout,"INFO: FOOT OF INPUT DATA ........................ Minimum value in input to be represented in output spectrum ( less or equal to min data value).\n");
			fprintf(stdout,"INFO: CEILING OF INPUT DATA ..................   Maximum value in input to be represented in output spectrum ( breater than or equal to max data value).\n");
			fprintf(stdout,"INFO: FOOT OF SPECTRUM IN OUTPUT ........  Frequency of minimum value represented in output spectrum.\n");
			fprintf(stdout,"INFO: CEILING OF SPECTRUM IN OUTPUT .. Frequency of maximum value represented in output spectrum.\n");
			fprintf(stdout,"INFO: OVERALL GAIN .................................... Attenuation of output spectrum.\n");
			fprintf(stdout,"INFO: SPECTRAL WARP .................................. If NOT set to 1.0, warpa the shape of the output spectrum .... \n");
			fprintf(stdout,"INFO:                               Warp greater than 1 causes spectrum to be squeezed into the lower frequencies.\n");
			fprintf(stdout,"INFO:                               Warp less than 1 causes spectrum to be squeezed into the higher frequencies.\n");
			fprintf(stdout,"INFO: AMPLITUDE RANGE FLATTENING ........ If NOT set to 1.0 changes range of amplitudes of spectral lines.... \n");
			fprintf(stdout,"INFO:                               As value increases, amplitude range is increasingly flattened.\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(1):
			fprintf(stdout,"INFO: CREATING FILTER DATA FILE FROM SPECTRAL LINES TEXT DATA.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SOUND SAMPLING RATE ...................... Sampling rate of sound which will eventually be generated.\n");
			fprintf(stdout,"INFO: OUTPUT DURATION .............................. Duration of output spectrum.\n");
			fprintf(stdout,"INFO: FOOT OF INPUT DATA ........................ Minimum value in input to be represented in output spectrum ( less or equal to min data value).\n");
			fprintf(stdout,"INFO: CEILING OF INPUT DATA ..................   Maximum value in input to be represented in output spectrum ( breater than or equal to max data value).\n");
			fprintf(stdout,"INFO: FOOT OF SPECTRUM IN OUTPUT ........  Frequency of minimum value represented in output spectrum.\n");
			fprintf(stdout,"INFO: CEILING OF SPECTRUM IN OUTPUT .. Frequency of maximum value represented in output spectrum.\n");
			fprintf(stdout,"INFO: SPECTRAL WARP .................................. If NOT set to 1.0, warpa the shape of the output spectrum .... \n");
			fprintf(stdout,"INFO:                               Warp greater than 1 causes spectrum to be squeezed into the lower frequencies.\n");
			fprintf(stdout,"INFO:                               Warp less than 1 causes spectrum to be squeezed into the higher frequencies.\n");
			fprintf(stdout,"INFO: AMPLITUDE RANGE FLATTENING ........ If NOT set to 1.0 changes range of amplitudes of spectral lines.... \n");
			fprintf(stdout,"INFO:                               As value increases, amplitude range is increasingly flattened.\n");
			fprintf(stdout,"INFO: \n");
			break;
		}
		break;
	case(SPECMORPH):
		switch(mode) {
		case(6):
			fprintf(stdout,"INFO: MORPH, IN STEPS, BETWEEN TWO DISSIMILAR SPECTRA.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Spectral peaks of 2 files are matched and, at each output step, move away from 1st and closer to 2nd.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: NUMBER OF PEAKS TO MAP ..................... Number of peaks to look for.\n");
			fprintf(stdout,"INFO: NUMBER OF INTERMEDIATE FILES ... Number of output files with peaks in between the 1st and 2nd input files.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: RETAIN LOUDNESS ENVELOPE OF 1st SND The loudness contour of the 1st sound is retained, even as its spectrum is changed.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: INTERP PEAKS ONLY .................... Retain file1 content of all non-peak channels.\n");
			fprintf(stdout,"INFO:                                   (In default case, non-peak channels interpolate towards file2 values).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: INTERP PEAK FREQUENCIES ONLY .. Amplitudes of peak channels are determined by peak amplitudes of sound 1 only.\n");
			fprintf(stdout,"INFO: \n");
			break;
		default:
			fprintf(stdout,"INFO: MORPH BETWEEN TWO DISSIMILAR SPECTRA.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Spectral peaks are matched, and pitch-glide towards one another.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Modes 1 and 2: Calculate the channels of the spectral peaks as an average over the whole sound.\n");
			fprintf(stdout,"INFO: Modes 3 and 4: Calculate the channels of the spectral peaks on a window by window basis.\n");
			fprintf(stdout,"INFO: Modes 5 and 6: Uses harmonic field of the average peaks in the 2nd sound to tune the spectrum of the 1st.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: 2nd FILE ENTRY TIME ........... Entry of 2nd sound may be delayed (but morph can only begin oce it has entered).\n");
			fprintf(stdout,"INFO: INTERPOLATION START ........ Start time of the morph.\n");
			fprintf(stdout,"INFO: INTERPOLATION END ........... End time of the morph.\n");
			fprintf(stdout,"INFO: INTERPOLATION EXPONENT ... Determines the shape of the interpolation.\n");
			fprintf(stdout,"INFO:                      In modes 1 and 3\n");
			fprintf(stdout,"INFO:                                   exponent 1 gives a linear interpolation.\n");
			fprintf(stdout,"INFO:                                   exponent more than 1 interpolates slower at the start and faster at the end.\n");
			fprintf(stdout,"INFO:                                   exponent less than 1 interpolates faster at the start and slower at the end.\n");
			fprintf(stdout,"INFO:                      In modes 2 and 4\n");
			fprintf(stdout,"INFO:                                   exponent 1 gives a cosinusiodal interpolation.\n");
			fprintf(stdout,"INFO:                                   exponent more than 1 forces the cosinusiodal transition towards the midpoint-time.\n");
			fprintf(stdout,"INFO:                                   exponent less than 1 speeds up the initial and final interpolation-rate.\n");
			fprintf(stdout,"INFO:                                   exponent .85 approaches the linear case.\n");
			fprintf(stdout,"INFO:                                   Below .85 the interpolation lingers longer around its half-way point.\n");
			fprintf(stdout,"INFO: NUMBER OF PEAKS TO MAP ..................... Number of peaks to look for.\n");
			fprintf(stdout,"INFO: RANDOMISATION OF GOAL PEAK FRQ ... Randomisation of goal peak-frequencies (can vary over time).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: RETAIN LOUDNESS ENVELOPE OF 1st SND The loudness contour of the 1st sound is retained, even as its spectrum morphs.\n");
			fprintf(stdout,"INFO:                                   In this case, output will cease once the 1st sound ends.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: INTERP PEAKS ONLY .................... Retain file1 content of all non-peak channels.\n");
			fprintf(stdout,"INFO:                                   (In default case, non-peak channels interpolate towards file2 values).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: INTERP PEAK FREQUENCIES ONLY .. Peak channel amplitudes are determined by 1st sound peak amplitudes only.\n");
			fprintf(stdout,"INFO: \n");
			break;
		}
		break;
	case(SPECMORPH2):
		fprintf(stdout,"INFO: EXTRACT OR MORPH SPECTRAL PEAKS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Spectral peaks are made to glide to new values.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Mode 1:  Extract average frequencies of the peaks  (in order of decreasing prominence).\n");
		fprintf(stdout,"INFO: Mode 2: Uses peak-frequencies specified in textfile (in order of decreasing prominence) to gradually tune the spectrum.\n");
		fprintf(stdout,"INFO: Mode 3: Ditto, using cosinusoidal morph.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NUMBER OF PEAKS TO LOOK FOR ..... Number of peaks to look for.\n");
		fprintf(stdout,"INFO: INTERPOLATION START ........ Start time of the morph.\n");
		fprintf(stdout,"INFO: INTERPOLATION END ........... End time of the morph.\n");
		fprintf(stdout,"INFO: INTERPOLATION EXPONENT ... Determines the shape of the interpolation.\n");
		fprintf(stdout,"INFO:                      In modes 1 and 3\n");
		fprintf(stdout,"INFO:                                   exponent 1 gives a linear interpolation.\n");
		fprintf(stdout,"INFO:                                   exponent more than 1 interpolates slower at the start and faster at the end.\n");
		fprintf(stdout,"INFO:                                   exponent less than 1 interpolates faster at the start and slower at the end.\n");
		fprintf(stdout,"INFO:                      In modes 2 and 4\n");
		fprintf(stdout,"INFO:                                   exponent 1 gives a cosinusiodal interpolation.\n");
		fprintf(stdout,"INFO:                                   exponent more than 1 forces the cosinusiodal transition towards the midpoint-time.\n");
		fprintf(stdout,"INFO:                                   exponent less than 1 speeds up the initial and final interpolation-rate.\n");
		fprintf(stdout,"INFO:                                   exponent .85 approaches the linear case.\n");
		fprintf(stdout,"INFO:                                   Below .85 the interpolation lingers longer around its half-way point.\n");
		fprintf(stdout,"INFO: RANDOMISATION OF GOAL PEAK FRQ ... Randomisation of goal peak-frequencies (can vary over time).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(NEWDELAY):
		fprintf(stdout,"INFO: DELAY WITH FEEDBACK, GENERATING PITCHED OUTPUT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIDI_PITCH ......................... MIDI pitch generated by delayed feedback\n");
		fprintf(stdout,"INFO: DELAYED_SIGNAL_IN_MIX .. Level of delayed signal in the output\n");
		fprintf(stdout,"INFO: FEEDBACK............................... Feedback level (Feedback generates pitch effect)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FILTRAGE):
		fprintf(stdout,"INFO: GENERATE RANDOM FILTER-SETTINGS FOR VARIBANK FILTER.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Mode 1: Make fixed-values filter.\n");
		fprintf(stdout,"INFO: Mode 2: Make time-varying filter.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION ...................... Duration of filter.\n");
		fprintf(stdout,"INFO: NUMBER OF FILTERS .......... Number of separate pitch-streams defined in output filter data.\n");
		fprintf(stdout,"INFO: MIN MIDIPITCH OF FILTERS .. Minimum MIDI pitch in any specified pitchstream.\n");
		fprintf(stdout,"INFO: MAX MIDIPITCH OF FILTERS .. Maximum MIDI pitch in any specified pitchstream\n");
		fprintf(stdout,"INFO: PITCH DISTRIBUTION ........ 1 gives linear pitch-distribution,\n");
		fprintf(stdout,"INFO:                                           greater than 1 squeezes pitches towards lower values.\n");
		fprintf(stdout,"INFO:                                           less than 1 squeezes pitches towards higher values.\n");
		fprintf(stdout,"INFO: PITCH RANDOMISATION ......... Randomisation of pitches. 1 gives maximum randomisation.\n");
		fprintf(stdout,"INFO: MINIMUM FILTER AMPLITUDE ... Filters will vary in amplitude between thhis MINIMUM, and the max value of 1.0\n");
		fprintf(stdout,"INFO: AMPLITUDE RANDOMISATION .. Randomisation of amplitudes.\n");
		fprintf(stdout,"INFO: AMPLITUDE DISTRIBUTION ...... 0 gives random amplitudes.\n");
		fprintf(stdout,"INFO:                                           1 gives increasing amplitude with pitch.\n");
		fprintf(stdout,"INFO:                                           -1 gives decreasing amplitude with pitch.\n");
		fprintf(stdout,"INFO:                                           Intermediate values give increasing degrees of randomisation, as zero is approached.\n");
		if(mode == 1) {
			fprintf(stdout,"INFO: TIMESTEP BETWEEN FILTER SETS .. (Average) timestep between each pitch-set specification, for time-changing filters,\n");
			fprintf(stdout,"INFO: RANDOMISATION OF TIMESTEP ........ Randomisation of timesteps.\n");
		}
		fprintf(stdout,"INFO: RANDOM SEED .................... If seed value is NOT zero, random values used in process will be reproduced on next pass with SAME parameters.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ITERLINE):
	case(ITERLINEF):
		if(process == ITERLINE)
			fprintf(stdout,"INFO: EXTEND SOURCE BY ITERATION, FOLLOWING A DEFINED TRANSPOSITION LINE.\n");
		else {
			fprintf(stdout,"INFO: EXTEND BY ITERATION A SET OF SOUNDS WHICH ARE TRANSPOSITIONS OF A SOURCE, FOLLOWING A DEFINED TRANSPOSITION LINE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The aim here is to effect a line which changes in pitch without altering the formant character of a source.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: There must be 25 input files, being semitone transpositions of an original source.\n");
			fprintf(stdout,"INFO: The first 12 sounds are transpositions downward by 12 semitones, 11 semitones, 10 semitones etc\n");
			fprintf(stdout,"INFO: File 13 is the original, untransposed source.\n");
			fprintf(stdout,"INFO: Files 14-25 are transpositions upwards by 1 semitone, 2 semitones, 3 semitones etc\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: The transpositions should be duration and formant preserving.\n");
			fprintf(stdout,"INFO: \n");
		}
		fprintf(stdout,"INFO: MODES----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Mode 1: Interpolate timewise between transposition values.\n");
		fprintf(stdout,"INFO: Mode 2: Step between transposition values.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TRANSPOSITION DATA.....Textfile of pairs of time/transposition values. Times must start at 0, and increase.\n");
		fprintf(stdout,"INFO:                                       Transposition valueds are in (possibly fractional) semitones, in range +- 24 (2 octaves up or down)\n");
		fprintf(stdout,"INFO: DELAY..................(average) delay between iterations.\n");
		fprintf(stdout,"INFO: PITCH SCATTER..........max of randomisation of pitchshift of each iteration: (possibly fractional) semitones.\n");
		fprintf(stdout,"INFO: AMPLITUDE SCATTER......max of random amp-reduction on each iteration.\n");
		fprintf(stdout,"INFO: OVERALL GAIN...........(special) value 0, gives best guess for no distortion.\n");
		fprintf(stdout,"INFO: SEED RANDOM GENERATOR..same number produces identical output on rerun,\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SPECRAND):
		fprintf(stdout,"INFO: TIME-RANDOMISE SPECTRAL DATA.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RANDOMISATION TIMESCALE .......... Timescale over which spectral data are randomised.\n");
		fprintf(stdout,"INFO: WINDOW GROUPING .................. Spectral windows are grouped into sets of time-adjacent windows, and these sets are time-randomised,\n");
		fprintf(stdout,"INFO:                                          This parameter determines the number of windows in each set.\n");
		fprintf(stdout,"INFO:                                          The duration of the window-group cannot exceed (half of) the Randomisation Timescale.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SPECSQZ):
		fprintf(stdout,"INFO: SQUEEZE THE FREQUENCY-SECTRUM.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CENTRE FREQUENCY ............. Frequency around which other values are squeezed.\n");
		fprintf(stdout,"INFO: SQUEEZE FACTOR ............... Contraction of the frequency data range (less than 1).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HOVER2):
		fprintf(stdout,"INFO: ZIGZAG READ A SOURCE AT A GIVEN FREQUENCY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: At any specified location, process searches for nearby zero-crossing,\n");
		fprintf(stdout,"INFO: then reads forwards from the zero, then back to the zero, producing a wave half-cycle,\n");
		fprintf(stdout,"INFO: then writes the inversion of those samples, producing symmetrical 2nd-half of wave-cycle.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RATE OF HOVER (Hz) .... slow rate: reads lots of samples forwards, backwards, forwards.\n");
		fprintf(stdout,"INFO:                         fast rate: reads fewer samples forwards, backwards, forwards.\n");
		fprintf(stdout,"INFO: LOCATION OF HOVERING .. Time in input sound where samples are read.\n");
		fprintf(stdout,"INFO: RANDOMISATION OF RATE (0-1)\n");
		fprintf(stdout,"INFO: RANDOMISATION OF LOCATION (0-1)\n");
		fprintf(stdout,"INFO: OUTPUT DURATION ....... Total Duration of output file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ADVANCE LOCATIONS STEPWISE ..... If a brkpoint table is used for LOCATION\n");
		fprintf(stdout,"INFO:                         then the location read at any time-value remains the read-location\n");
		fprintf(stdout,"INFO:                         until a new time-value in the file is reached.\n");
		fprintf(stdout,"INFO:                         (The default read mode is to INTERPOLATE between locations specified at the time-values in the file).\n");
		fprintf(stdout,"INFO: NORMALISE OUTPUT ..... Normalise the level of all wavecycles generated.\n");
		break;
	case(SELFSIM):
		fprintf(stdout,"INFO: MAKE SPECTRUM MORE SELF-SIMILAR.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SELF SIMILARITY INDEX ............. Number of similar windows to replace.\n");
		fprintf(stdout,"INFO:                         Value 1 uses loudest window to replace the most similar window.\n");
		fprintf(stdout,"INFO:                         then the next loudest window to replace window most similar to it\n");
		fprintf(stdout,"INFO:                         and so on, with appropriate overall-loudness scaling.\n");
		fprintf(stdout,"INFO:                         With value 2, loudest windows replaces the TWO windows most similar to it.\n");
		fprintf(stdout,"INFO:                         and so on.\n");
		fprintf(stdout,"INFO:                         If two windows are to be replaced by A, and A first replaces B,\n");
		fprintf(stdout,"INFO:                         and D is more similar to B, than C is to A, then A replaces D rather than C.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ITERFOF):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: GENERATE PITCHED LINE FROM SMALL SOUND PACKET OR FOF.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Treat source as a wavelength sized FOF, and use transposition data, to guide pitch of output line.\n");
			fprintf(stdout,"INFO: With any transposition breakpoint file, interpolate between values, so pitch glides from one value to next.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE WHOLE EVENT ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SEMITONE TRANSPOSITION OF LINE Assumes duration of input = wavelength of the fundamental pitch to be transposed.\n");
			fprintf(stdout,"INFO: DURATION ............................... (Minimum) duration of the entire output sound.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE ELELEMTS ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SEGMENT PITCH RANDOMISATION ... Randomises pitch of individual segments themselves.\n");
			fprintf(stdout,"INFO: MAX OF RANDOM AMP REDUCTION .. If greater than 0, amplitude of successive segments are randomly reduced\n");
			fprintf(stdout,"INFO:                                                                          up to a maximum of the value input here.\n");
			fprintf(stdout,"INFO: TRIMMED DURATION OF ELEMENTS . If elements are to be shortened, this is Duration to trim to\n");
			fprintf(stdout,"INFO:                                                                          and will be equal to or less than (possibly transposed) source duration.\n");
			fprintf(stdout,"INFO:                                                                          A ZERO value means the elements are NOT trimmed.\n");
			fprintf(stdout,"INFO: FADE DURATION OF ELEMENTS ...... Duration of any fade on end of elements.\n");
			fprintf(stdout,"INFO: FADE SLOPE ............................. Slope of any fade on end of elements.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE LINE ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PITCH ROUGHNESS ....................... Randomisation of instantaneous pitch.\n");
			fprintf(stdout,"INFO: MIN VIBRATO FREQUENCY .......... Minimum frequency of line vibrato.\n");
			fprintf(stdout,"INFO: MAX VIBRATO FREQUENCY .......... Maximum frequency of line vibrato. Frequnecy varies at random between min and max.\n");
			fprintf(stdout,"INFO: MIN VIBRATO DEPTH ................. Minimum depth of line vibrato in semitones.\n");
			fprintf(stdout,"INFO: MAX VIBRATO DEPTH  ................ Maximum depth of line vibrato. Depth varies at random between min and max.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: GENERAL PARAMETERS ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: RANDOM SEED ......... ............. Setting a particular seed value will produce similar output when same seed applied again.\n");
			break;
		case(1):
			fprintf(stdout,"INFO: GENERATE STEPPED PITCHED LINE FROM SMALL SOUND PACKET OR FOF.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Treat source as a wavelength sized FOF, and use transposition data, to set pitches of output line.\n");
			fprintf(stdout,"INFO: With any transposition breakpoint file, STEP between values, so that pitch steps from one timed-event to next.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE WHOLE EVENT ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SEMITONE TRANSPOSITION OF LINE Assumes duration of input = wavelength of the fundamental pitch to be transposed.\n");
			fprintf(stdout,"INFO: DURATION ............................... (Minimum) duration of the entire output sound.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE ELELEMTS ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SEGMENT PITCH RANDOMISATION ... Randomises pitch of individual segments themselves.\n");
			fprintf(stdout,"INFO: MAX OF RANDOM AMP REDUCTION .. If greater than 0, amplitude of successive segments are randomly reduced\n");
			fprintf(stdout,"INFO:                                                                          up to a maximum of the value input here.\n");
			fprintf(stdout,"INFO: TRIMMED DURATION OF ELEMENTS . If elements are to be shortened, this is Duration to trim to\n");
			fprintf(stdout,"INFO:                                                                          and will be equal to or less than (possibly transposed) source duration.\n");
			fprintf(stdout,"INFO:                                                                          A ZERO value means the elements are NOT trimmed.\n");
			fprintf(stdout,"INFO: FADE DURATION OF ELEMENTS ...... Duration of any fade on end of elements.\n");
			fprintf(stdout,"INFO: FADE SLOPE ............................. Slope of any fade on end of elements.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE LINE ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PITCH ROUGHNESS ....................... Randomisation of instantaneous pitch.\n");
			fprintf(stdout,"INFO: MIN VIBRATO FREQUENCY .......... Minimum frequency of line vibrato.\n");
			fprintf(stdout,"INFO: MAX VIBRATO FREQUENCY .......... Maximum frequency of line vibrato. Frequnecy varies at random between min and max.\n");
			fprintf(stdout,"INFO: MIN VIBRATO DEPTH ................. Minimum depth of line vibrato in semitones.\n");
			fprintf(stdout,"INFO: MAX VIBRATO DEPTH  ................ Maximum depth of line vibrato. Depth varies at random between min and max.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS FOR ANY DISTINCT PITCHES ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MIN LEVEL NOTES ..................... Minimum note loudness.\n");
			fprintf(stdout,"INFO: MAX LEVEL NOTES ..................... Maximum note loudness. Notes vary in loudness between min and max\n");
			fprintf(stdout,"INFO: NOTE INFADE DURATION ............ Duration of any fade-in of notes.\n");
			fprintf(stdout,"INFO: NOTE OUTFADE DURATION ......... Duration of any fade-out of notes.\n");
			fprintf(stdout,"INFO: GAP BETWEEN NOTES ................. Relative length of any gap between notes, as proportion of note duration.\n");
			fprintf(stdout,"INFO: PORTAMENTO TYPE ................... 0 = none  :  1 = rising  :  -1 = falling  :  2 = randomly rising or falling.\n");
			fprintf(stdout,"INFO: PORTAMENTO INTERVAL ............. Interval rise(fall) of any portamento, in semitones, attained only by the start-time of next note.\n");
			fprintf(stdout,"INFO:                                                            (If there are gaps between notes, maximum interval will not be reached).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: GENERAL PARAMETERS ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: RANDOM SEED ......... ............. Setting a particular seed value will produce similar output when same seed applied again.\n");
			break;
		case(2):
			fprintf(stdout,"INFO: GENERATE PITCHED LINE FROM INPUT SOUND.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MIDI-pitch data determines pitch of output line.\n");
			fprintf(stdout,"INFO: With any pitch breakpoint file, interpolate between timed values, so that pitch glides from one timed-event to next.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE WHOLE EVENT ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MIDI-PITCH OF LINE ...................\n");
			fprintf(stdout,"INFO: DURATION ............................... (Minimum) duration of the entire output sound.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE ELELEMTS ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SEGMENT PITCH RANDOMISATION ... Randomises pitch of individual segments themselves.\n");
			fprintf(stdout,"INFO: MAX OF RANDOM AMP REDUCTION .. If greater than 0, amplitude of successive segments are randomly reduced\n");
			fprintf(stdout,"INFO:                                                                          up to a maximum of the value input here.\n");
			fprintf(stdout,"INFO: TRIMMED DURATION OF ELEMENTS . If elements are to be shortened, this is Duration to trim to\n");
			fprintf(stdout,"INFO:                                                                          and will be equal to or less than (possibly transposed) source duration.\n");
			fprintf(stdout,"INFO:                                                                          A ZERO value means the elements are NOT trimmed.\n");
			fprintf(stdout,"INFO: FADE DURATION OF ELEMENTS ...... Duration of any fade on end of elements.\n");
			fprintf(stdout,"INFO: FADE SLOPE ............................. Slope of any fade on end of elements.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:                                                            (If there are gaps between notes, maximum interval will not be reached).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE LINE ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PITCH ROUGHNESS ....................... Randomisation of instantaneous pitch.\n");
			fprintf(stdout,"INFO: MIN VIBRATO FREQUENCY .......... Minimum frequency of line vibrato.\n");
			fprintf(stdout,"INFO: MAX VIBRATO FREQUENCY .......... Maximum frequency of line vibrato. Frequnecy varies at random between min and max.\n");
			fprintf(stdout,"INFO: MIN VIBRATO DEPTH ................. Minimum depth of line vibrato in semitones.\n");
			fprintf(stdout,"INFO: MAX VIBRATO DEPTH  ................ Maximum depth of line vibrato. Depth varies at random between min and max.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: GENERAL PARAMETERS ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: RANDOM SEED ......... ............. Setting a particular seed value will produce similar output when same seed applied again.\n");
			break;
		case(3):
			fprintf(stdout,"INFO: GENERATE STEP-PITCHED LINE FROM INPUT SOUND.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MIDI-pitch data determines pitches of output line.\n");
			fprintf(stdout,"INFO: With any pitch breakpoint file, step between timed values, so pitch steps from one timed-event to next.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE WHOLE EVENT ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MIDI-PITCHES OF LINE ...............\n");
			fprintf(stdout,"INFO: DURATION ............................... (Minimum) duration of the entire output sound.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE ELELEMTS ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: SEGMENT PITCH RANDOMISATION ... Randomises pitch of individual segments themselves.\n");
			fprintf(stdout,"INFO: MAX OF RANDOM AMP REDUCTION .. If greater than 0, amplitude of successive segments are randomly reduced\n");
			fprintf(stdout,"INFO:                                                                          up to a maximum of the value input here.\n");
			fprintf(stdout,"INFO: TRIMMED DURATION OF ELEMENTS . If elements are to be shortened, this is Duration to trim to\n");
			fprintf(stdout,"INFO:                                                                          and will be equal to or less than (possibly transposed) source duration.\n");
			fprintf(stdout,"INFO:                                                                          A ZERO value means the elements are NOT trimmed.\n");
			fprintf(stdout,"INFO: FADE DURATION OF ELEMENTS ...... Duration of any fade on end of elements.\n");
			fprintf(stdout,"INFO: FADE SLOPE ............................. Slope of any fade on end of elements.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS OF THE LINE ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PITCH ROUGHNESS ....................... Randomisation of instantaneous pitch.\n");
			fprintf(stdout,"INFO: MIN VIBRATO FREQUENCY .......... Minimum frequency of line vibrato.\n");
			fprintf(stdout,"INFO: MAX VIBRATO FREQUENCY .......... Maximum frequency of line vibrato. Frequnecy varies at random between min and max.\n");
			fprintf(stdout,"INFO: MIN VIBRATO DEPTH ................. Minimum depth of line vibrato in semitones.\n");
			fprintf(stdout,"INFO: MAX VIBRATO DEPTH  ................ Maximum depth of line vibrato. Depth varies at random between min and max.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: PARAMETERS FOR ANY DISTINCT PITCHES (Modes 2 and 4) ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: MIN LEVEL NOTES ..................... Minimum note loudness.\n");
			fprintf(stdout,"INFO: MAX LEVEL NOTES ..................... Maximum note loudness. Notes vary in loudness between min and max\n");
			fprintf(stdout,"INFO: NOTE INFADE DURATION ............ Duration of any fade-in of notes.\n");
			fprintf(stdout,"INFO: NOTE OUTFADE DURATION ......... Duration of any fade-out of notes.\n");
			fprintf(stdout,"INFO: GAP BETWEEN NOTES ................. Relative length of any gap between notes, as proportion of note duration.\n");
			fprintf(stdout,"INFO: PORTAMENTO TYPE ................... 0 = none  :  1 = rising  :  -1 = falling  :  2 = randomly rising or falling.\n");
			fprintf(stdout,"INFO: PORTAMENTO INTERVAL ............. Interval rise(fall) of any portamento, in semitones, attained only by the start-time of next note.\n");
			fprintf(stdout,"INFO:                                                            (If there are gaps between notes, maximum interval will not be reached).\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: GENERAL PARAMETERS ----------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: RANDOM SEED ......... ............. Setting a particular seed value will produce similar output when same seed applied again.\n");
			break;
		}
		break;
	case(PULSER):
	case(PULSER2):
	case(PULSER3):
		switch(mode) {
		case(0):
			switch(process) {
			case(PULSER):
				fprintf(stdout,"INFO: CREATE A STREAM OF PITCHED PACKETS FROM A MONO SOURCE.\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: (NB: Only the spectral brightness of the source is reflected in the output sound.)\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
				fprintf(stdout,"INFO: \n");
				break;
			case(PULSER2):
				fprintf(stdout,"INFO: CREATE A STREAM OF PITCHED PACKETS FROM MONO SOURCES.\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: (NB: Only the spectral brightness of the sources is reflected in the output sound.)\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
				fprintf(stdout,"INFO: \n");
				break;
			case(PULSER3):
				fprintf(stdout,"INFO: CREATE A STREAM OF SYNTHESIZED PACKETS FROM PARTIAL-NUMBER DATA.\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARTIAL NUMBERS AND LEVELS ......... Textfile list of paired items: Each pair is a partial number and a level.\n");
				fprintf(stdout,"INFO:                                                                                  Partial number range 1 - 64 (can be fractional) : level range -1 to 1.\n");
				break;
			}
			fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
			fprintf(stdout,"INFO: MIDI PITCH ................................. Midi pitch of output packets.\n");
			break;
		case(1):
			switch(process) {
			case(PULSER):
				fprintf(stdout,"INFO: CREATE A STREAM OF PACKETS FROM A MONO SOURCE, USING THE START OF THE SOURCE ONLY.\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
				break;
			case(PULSER2):
				fprintf(stdout,"INFO: CREATE A STREAM OF PACKETS FROM MONO SOURCES, USING THE START OF THE SOURCES ONLY.\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
				break;
			case(PULSER3):
				fprintf(stdout,"INFO: CREATE A STREAM OF SYNTHESIZED PACKETS WHOSE SPECTRA CHANGE WITH TIME.\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARTIAL NUMBERS AND LEVELS ......... Textfile is of list of lines of format \"Time  partialno level [partialno2 level2 ......]\"\n");
				fprintf(stdout,"INFO:                                                                                  Partial number range 1 - 64 (can be fractional) : level range -1 to 1.\n");
				fprintf(stdout,"INFO:                                                                                  Timers must start at zero, and increase.\n");
				fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
				fprintf(stdout,"INFO: MIDI PITCH ................................. Midi pitch of output packets.\n");
				break;
			}
			break;
		case(2):
			switch(process) {
			case(PULSER):
				fprintf(stdout,"INFO: CREATE A STREAM OF PACKETS FROM A MONO SOURCE, SELECTING RANDOM CHUNKS FROM INSIDE THE SOURCE.\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
				break;
			case(PULSER2):
				fprintf(stdout,"INFO: CREATE A STREAM OF PACKETS FROM MONO SOURCES, SELECTING RANDOM CHUNKS FROM INSIDE THE SOURCES.\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
				break;
			case(PULSER3):
				fprintf(stdout,"INFO: CREATE A STREAM OF SYNTHESIZED PACKETS WHOSE SPECTRA CHANGE AT RANDOM.\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
				fprintf(stdout,"INFO: \n");
				fprintf(stdout,"INFO: PARTIAL NUMBERS AND LEVELS ......... Textfile is of list of lines of format \"Time  partialno level [partialno2 level2 ......]\"\n");
				fprintf(stdout,"INFO:                                                                                  Partial number range 1 - 64 (can be fractional) : level range -1 to 1.\n");
				fprintf(stdout,"INFO:                                                                                  Timers must start at zero, and increase.\n");
				fprintf(stdout,"INFO:                                                                                  Lines are read in RANDOM order (TIMES ARE IGNORED).\n");
				fprintf(stdout,"INFO: DURATION .................................. Duration of output.\n");
				fprintf(stdout,"INFO: MIDI PITCH ................................. Midi pitch of output packets.\n");
				break;
			}
			break;
		}
		fprintf(stdout,"INFO: RISE-TIME MINIMUM/MAXIMUM ......... Minimum and maximum duration of risetime of packets.\n");
		fprintf(stdout,"INFO: SUSTAIN-TIME MINIMUM/MAXIMUM .. Minimum and maximum duration of sustain time of packets.\n");
		fprintf(stdout,"INFO: DECAY-TIME MINIMUM/MAXIMUM ...... Minimum and maximum duration of decaytime of packets.\n");
		fprintf(stdout,"INFO:                                                                                  Actual rise, sustain and decay times are set at random, between the limits given.\n");
		fprintf(stdout,"INFO: TIME STEP BETWEEN PACKETS .......... Timestep between packets in output stream.\n");
		fprintf(stdout,"INFO: PACKET TIME RANDOMISATION ........ Randomisation of timestep between packets.\n");
		fprintf(stdout,"INFO: SLOPE OF ATTACK,SLOPE OF DECAY .. 1 is linear : greater than 1 is steep : less than 1 is less steep.\n");
		fprintf(stdout,"INFO: PITCH SCATTER (SEMITONES) .......... Random scattering of packet pitches.\n");
		fprintf(stdout,"INFO: AMPLITUDE SCATTER ..................... Random scattering of packet amplitudes.\n");
		fprintf(stdout,"INFO: OCTAVIATION ............................. Octaviation (suggestion of lower octave in output stream).\n");
		fprintf(stdout,"INFO: PACKET PITCH BEND ...................... Bending of pitches of packets.\n");
		fprintf(stdout,"INFO: RANDOM SEED ............................. Setting a particular seed value will produce similar output when same seed applied again.\n");
		if(process == PULSER2) {
			fprintf(stdout,"INFO: TOTALLY RANDOM SRC SEQUENCE .... Source sound to produce next packet is chosen totally at random.\n");
			fprintf(stdout,"INFO:                                                                                  Default:  all srcs are used once, in a random order, before proceeding to the next random ordering.\n");
		} else if(process == PULSER3) {
			fprintf(stdout,"INFO: SAMPLING RATE ............................ Sampling rate of sythesized output.\n");
			fprintf(stdout,"INFO: PARTIAL COUNT ............................ Number of partials actually activated (time-variable).\n");
			fprintf(stdout,"INFO:                                                                                  Fractional values can be used: e.g. 2.4 means use 1st and 2nd partials, and 3rd partial attenuated by 0.4.\n");
		}
		fprintf(stdout,"INFO: \n");
		if(process == PULSER3)
			fprintf(stdout,"INFO: All parameters except DURATION, RISE/SUSTAIN/DECAY limits, SEED and SAMPLE RATE can vary through time.\n");
		else
			fprintf(stdout,"INFO: All parameters except DURATION, RISE/SUSTAIN/DECAY limits, and SEED can vary through time.\n");
		break;
	case(CHIRIKOV):
		fprintf(stdout,"INFO: GENERATE SOUND OR PITCHLINE BASED ON CHIRIKOV STANDARD MAP, OR CIRCULAR MAP.\n");
		fprintf(stdout,"INFO: \n");
		switch(mode) {
		case(0):	fprintf(stdout,"INFO: GENERATE SOUND BASED ON ITERATION OF CHIRIKOV STANDARD MAP.\n");		break;
		case(1):	fprintf(stdout,"INFO: GENERATE PITCH LINE BASED ON ITERATION OF CHIRIKOV STANDARD MAP.\n");	break;
		case(2):	fprintf(stdout,"INFO: GENERATE SOUND BASED ON ITERATION OF CIRCULAR MAP.\n");				break;
		case(3):	fprintf(stdout,"INFO: GENERATE PITCH LINE BASED ON ITERATION OF CIRCULAR MAP.\n");			break;
		}
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		switch(mode) {
		case(0):	
		case(1):	fprintf(stdout,"INFO: DURATION .................... Duration of the output sound.\n");	break;
		case(2):
		case(3):	fprintf(stdout,"INFO: DURATION .................... Duration of the output breakpoint file.\n");	break;
		}
		fprintf(stdout,"INFO: FREQUENCY ................... Frequency of the forcing oscillation (can vary through time).\n");
		fprintf(stdout,"INFO: DAMPING ..................... Damping coeeficient (can vary through time).\n");
		switch(mode) {
		case(0):	
		case(1):	
			fprintf(stdout,"INFO: SAMPLE RATE .......... Sampling rate of the synthesized sound.\n");	
			fprintf(stdout,"INFO: SPLICE LENGTH (mS) ... Splice length (in milliseconds) of the onset and end of the output sound.\n");	
			break;
		case(2):	
		case(3):	
			fprintf(stdout,"INFO: MINIMUM_MIDI PITCH .. Bottom of MIDI pitch range of output data.\n");	
			fprintf(stdout,"INFO: MAXIMUM_MIDI PITCH .. Top of MIDI pitch range of output data.\n");	
			fprintf(stdout,"INFO: TIME STEP ....................... Time step between entries in output brkpoint file.\n");	
			fprintf(stdout,"INFO: TIME RANDOMISATION .. Randomisation of times in output brkpoint file.\n");	
			break;
		}
		break;
	case(MULTIOSC):
		fprintf(stdout,"INFO: GENERATE INTERACTING OSCILLATORS.\n");
		fprintf(stdout,"INFO: \n");
		switch(mode) {
		case(0):	fprintf(stdout,"INFO: OSCILLATION OF OSCILLATION.\n");								 break;
		case(1):	fprintf(stdout,"INFO: OSCILLATION OF OSCILLATION OF OSCILLATION.\n");				 break;
		case(2):	fprintf(stdout,"INFO: OSCILLATION OF OSCILLATION OF OSCILLATION OF OSCILLATION.\n"); break;
		}
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION .................... Duration of the output sound.\n");
		fprintf(stdout,"INFO: FREQUENCY ................... Oscillator frequency.\n");
		fprintf(stdout,"INFO: FREQUENCY TWO................ Frequency of oscillation of oscillation.\n");
		fprintf(stdout,"INFO: AMPLITUDE TWO................ Amplitude of oscillation of oscillation.\n");
		if(mode >= 1) {
			fprintf(stdout,"INFO: FREQUENCY THREE................ Frequency of oscillation of oscillation of oscillation.\n");
			fprintf(stdout,"INFO: AMPLITUDE THREE................ Amplitude of oscillation of oscillation of oscillation.\n");
		}
		if(mode == 2) {
			fprintf(stdout,"INFO: FREQUENCY FOUR................ Frequency of oscillation of oscillation of oscillation of oscillation.\n");
			fprintf(stdout,"INFO: AMPLITUDE FOUR................ Amplitude of oscillation of oscillation of oscillation of oscillation.\n");
		}
		fprintf(stdout,"INFO: SAMPLE RATE .......... Sampling rate of the synthesized sound.\n");	
		fprintf(stdout,"INFO: SPLICE LENGTH (mS) ... Splice length (in milliseconds) of the onset and end of the output sound.\n");	
		break;
	case(SYNFILT):
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO: GENERATE BAND OF FILTERED NOISE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: REQUIRED DATAFILE-------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TIMELIST OF PITCHES OF FILTS .... a textfile of lines with time-pitch pairs on each line. \n");
			fprintf(stdout,"INFO: \n");
			break;
		case(1):
			fprintf(stdout,"INFO: GENERATE BAND OF MULTIPITCHED FILTERED NOISE.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: REQUIRED DATAFILE-------------------------------------------------------\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: TIMELIST OF PICHS&AMPS OF FILTS .... a textfile with lines of data for filter bands at successive times.\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Each line contains the following items\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO:           Time   Pitch1 Amp1   [Pitch2 Amp2    etc....].\n");
			fprintf(stdout,"INFO: \n");
			fprintf(stdout,"INFO: Where pitch and Amp values must be paired: and any number of pairs can be used in a line,\n");
			fprintf(stdout,"INFO: BUT each line must have SAME number of pairs on it.\n");
			fprintf(stdout,"INFO: Amp values may be numeric, or dB values (e.g. -4.1dB).\n");
			fprintf(stdout,"INFO: (To eliminate a band in any line(s), set its amplitude to 0.0).\n");
			break;
		}
		fprintf(stdout,"INFO: Time values (in secs) must be in ascending order (and >=0.0), with the maximum time being greater than 0.03 seconds.\n");
		fprintf(stdout,"INFO: Pitch vals are MIDI values (but may be fractional).\n");
		fprintf(stdout,"INFO: (Comment-lines may be used: start these with ';').\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OTHER PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SAMPLE RATE ............. Sample rate of output sound.\n");
		fprintf(stdout,"INFO: CHANNEL COUNT ......... Mono or stereo output.\n");
		fprintf(stdout,"INFO: FILTER Q .................. Q (tightness) of filter.\n");
		fprintf(stdout,"INFO: NUMBER OF HARMONICS.. No of harmonics (of each pitch) to use: Default 1.\n");
		fprintf(stdout,"INFO:                                                Very high harmonics of high pitches may be too high to calculate. (check with Max Harmonic button)\n");
		fprintf(stdout,"INFO:                                                No-of-pitches times no-of-harmonics determines program speed.\n");
		fprintf(stdout,"INFO: ROLL OFF................. Level drop (in dB) from one harmonic to next.\n");
		fprintf(stdout,"INFO: RANDOM SEED .......... Any set value gives reproducible output.\n");
		fprintf(stdout,"INFO: DOUBLE FILTERING .... More sharply defined filter frequencies.\n");
		fprintf(stdout,"INFO: DROP OUT ON OVERFLOW   The filter is designed to adjust its internal level to prevent numerical overflow from\n");
		fprintf(stdout,"INFO:                                                setting this flag will cause the filter to stop calculating if any overflow is detected.\n");
		fprintf(stdout,"INFO:                                                The filter gain can then be turned down, and the filter launched again.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB: USING VERY LARGE NUMBERS OF HARMONICS MAY PRODUCE NUMERICAL INSTABILITY (OUTPUT WILL FAIL)\n");
		fprintf(stdout,"INFO: NB: USING RAPID PITCH SHIFTS AT THE SOUND'S END (ESPECIALLY WITH LOW PITCH & FEW HARMONICS) MAY GIVE TAIL ARTEFACTS.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(STRANDS):
		switch(mode) {
		case(0):
		case(2):
			fprintf(stdout,"INFO: GENERATE PITCHBAND DATA EXHIBITING  LAMINAR,  TAYLOR_COUETTE, AND  TURBULENT  FLOW.\n");
			break;
		case(1):
			fprintf(stdout,"INFO: GENERATE PITCHBANDED SOUND EXHIBITING  LAMINAR,  TAYLOR_COUETTE, AND  TURBULENT  FLOW.\n");
			break;
		}
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Generates pitch threads distributed over a specified range, which can \"flow\" in the following ways ....\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         (a)  LAMINAR FLOW (threads do not cross).\n");
		fprintf(stdout,"INFO:         (b)  TWISTED FLOW (threads are grouped in pitch-adjacent bands, and the threads in each band cycle around one another).\n");
		fprintf(stdout,"INFO:         (c)  TWISTED FLOW WITH WAVY BOUNDARIES.\n");
		fprintf(stdout,"INFO:         (d)  BANDED FLOW WITH TURBULENCE (threads cross indiscriminately within the bands).\n");
		fprintf(stdout,"INFO:         (e)  TURBULENT FLOW (threads cross indiscriminately across the entire range).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Transitions to (and from) twisting, and to (and from) turbulence are managed by the process, and timed by the input parameters supplied.\n");
		fprintf(stdout,"INFO: \n");
		if(mode==0) {
			fprintf(stdout,"INFO: Data is output as a set of time-pitch breakkpoint files which define the pitch-evolution of each stream.\n");
			fprintf(stdout,"INFO: (Level data may also be output: see the \"3D\" option below).\n");
			fprintf(stdout,"INFO: \n");
		}
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		if(mode==2)
			fprintf(stdout,"INFO: THREADCOUNT IN EACH BAND ........... Number of pitch-threads in each band, listed in a textfile.\n");
		switch(mode) {
		case(0):
		fprintf(stdout,"INFO: DURATION .................................. Duration of the output data.\n");
		break;
		case(1):
		fprintf(stdout,"INFO: DURATION .................................. Duration of the output sound.\n");
		break;
		}
		fprintf(stdout,"INFO: NUMBER OF BANDS ........................ Number of pitch-bands in the output.\n");
		if(mode != 2)
			fprintf(stdout,"INFO: NUMBER OF THREADS PER BAND ........ Number of pitch-threads in each band.\n");
		fprintf(stdout,"INFO: TIMESTEP BETWEEN OUTPUT VALUES .. Timestep (in mS) between the pitch-data values in the output.\n");
		fprintf(stdout,"INFO: BOTTOM OF PITCH RANGE ................ Lowest pitch of all output.\n");
		fprintf(stdout,"INFO: TOP OF PITCH RANGE ..................... Highest pitch of all output.\n");
		fprintf(stdout,"INFO: FREQUENCY OF BAND ROTATION ....... Rate (in Hz) at which the pitches twist aroud one another within the bands.\n");
		fprintf(stdout,"INFO:                                     (1)  If two successive times in the input data have ZERO frequency,\n");
		fprintf(stdout,"INFO:                                               the flow between those times is LAMINAR.\n");
		fprintf(stdout,"INFO:                                     (2)  If two successive times have NON-ZERO freqency,\n");
		fprintf(stdout,"INFO:                                               the flow between those times is TWISTED.\n");
		fprintf(stdout,"INFO:                                     (3)  If two successive times have zero and non-zero freqencies,\n");
		fprintf(stdout,"INFO:                                               the flow gradually changes between laminar and twisted.\n");
		fprintf(stdout,"INFO: RANDOM DIVERSITY OF BAND FREQUENCIES\n");
		fprintf(stdout,"INFO:                                     (1) With LAMINAR FLOW : Amount of random divergence of thread pitches from steady pitch.\n");
		fprintf(stdout,"INFO:                                     (2) With TWISTED FLOW : Amount of random divergence of twist of individual bands\n");
		fprintf(stdout,"INFO:                                               from the specified twist frequency.\n");
		fprintf(stdout,"INFO: RANDOM WARPING OF THREAD OSCILLATIONS\n");     
		fprintf(stdout,"INFO:                                     (1) With LAMINAR FLOW : If the flow is 3D (see below),\n");
		fprintf(stdout,"INFO:                                               amount of scattering of the loudness random of each stream.\n");
		fprintf(stdout,"INFO:                                               (If the flow is NOT 3D, this parameter is ignored during laminar flow).\n");
		fprintf(stdout,"INFO:                                     (2) With TWISTED FLOW : Random timewarp (acceleration or decelleration)\n");
		fprintf(stdout,"INFO:                                               of the twisting of individual threads in the same band.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BAND BOUNDARY WAVINESS ............ Amount that the band-boundaries wander away from fixed pitches.\n" );
		fprintf(stdout,"INFO: WAVINESS MIN FREQUENCY ............. Minimum rate of oscillation of the band boundaries.\n");
		fprintf(stdout,"INFO: WAVINESS MAX FREQUENCY ............ Maximum rate of oscillation of the band boundaries.\n");
		fprintf(stdout,"INFO:                                     Actual oscillation rates are selected at random (for each band boundary) between these limits.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TURBULENCE ............................... Turbulence destroys the laminar or twisting pattern of the threads.\n");
		fprintf(stdout,"INFO:                                     Value ZERO creates no turbulence.\n"); 
		fprintf(stdout,"INFO:                                     Values UP TO 1.0 create increasingly turbulent paths WITHIN the  band boundaries.\n");
		fprintf(stdout,"INFO:                                     Values BETWEEN 1.0 and 2.0 create increasingly turbulent paths over the entire pitch-range.\n");
		fprintf(stdout,"INFO:                                     Note that turbulence can ONLY be non-zero when the flow is (fully) twisted.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEED ..................................... Seed for random generators in process. Set same side on 2 runs to get identical randomisation.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MINIMUM PITCH INTERVAL BETWEEN BANDS Minimum pitch-interval separating the pitch-bands.\n");
		fprintf(stdout,"INFO: MINIMUM PITCH WIDTH OF BANDS ...... Minimum width of bands (especially when subjected to wavyiness).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ROTATION IN 3D ........................... 2 more tranches of values are created to control 3d asepcts of the flow.\n");
		switch(mode) {
		case(0):
			fprintf(stdout,"INFO:                                     The 1st tranche can be used to generate relative level values for the streams,\n");
			fprintf(stdout,"INFO:                                     or to control the number of partials in the stream with changes in pitch.\n");
			fprintf(stdout,"INFO:                                     The 2nd tranche can be used to control the level of a modified version of the source\n");
			fprintf(stdout,"INFO:                                     (e.g. reverbd or filtered), in a mix with the unmodified source.\n");
			fprintf(stdout,"INFO:                                     BOTH processes might indicate the instantaneous distance of each stream from the listener.\n");
			fprintf(stdout,"INFO:                                     This data output as 2 FURTHER sets of textfiles, AFTER all pitch data files have been output.\n");
			break;
		case(1):
			fprintf(stdout,"INFO:                                     This data is used to modify the relative level of the streams in the output.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT BANDS SEQUENTIALLY ......... Outputs each band separately, in sequence, rather than all superimposed.\n");
		fprintf(stdout,"INFO: \n");
			break;
		}
		fprintf(stdout,"INFO: \n");
		break;
	case(REFOCUS):
		fprintf(stdout,"INFO: GENERATE ENVELOPES TO CHANGE THE FOCUS (LOUDNESS) BETWEEN CO-EXISTING SOUNDS (e.g. IN A SET OF SOUNDS TO BE MIXED).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES-----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  Randomly permute which band is currently in focus.\n");
		fprintf(stdout,"INFO: 2)  Bring bands into focus consecutively in 'rising' sequences, starting at the lowest, rising to the highest.\n");
		fprintf(stdout,"INFO: 3)  Bring bands into focus consecutively in 'falling' sequences, starting at the highest, falling to the lowest.\n");
		fprintf(stdout,"INFO: 4)  Bring bands into focus in a rising/falling/rising... cycle, starting at the lowest.\n");
		fprintf(stdout,"INFO: 5)  Bring bands into focus in a falling/rising/falling.. cycle, starting at the highest.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION .................................. Duration of output envelope files.\n");
		fprintf(stdout,"INFO: NUMBER OF BANDS ........................ Number of sounds to envelope.\n");
		fprintf(stdout,"INFO: FOCUSING RATIO .......................... Ratio of loudness of in-focus sound to out of focus sounds.\n");
		fprintf(stdout,"INFO: TIMESTEP TO NEXT REFOCUS............. Time between refocusings.\n");
		fprintf(stdout,"INFO: TIMESTEP RANDOMISATION .............. Randomisation of this these times.\n");
		fprintf(stdout,"INFO: OFFSET BEFORE REFOCUSING BEGINS .. Refocusing does not start until after the \"offset\" time\n");
		fprintf(stdout,"INFO: TIME AT WHICH REFOCUSING ENDS ..... Refocusing ends at this time, unless it is set to zero.\n");
		fprintf(stdout,"INFO: NO FOCUS ON EXTREMAL BAND .......... The upper (1) or lower (-1) band gets no special focus.\n");
		fprintf(stdout,"INFO: RANDOM SEED .............................. Seend for random value generation: identical seed gives identical output.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT IS A SET OF ENVELOPE TEXTFILES which can be used to modify the levels of the sounds in the set of sounds.\n");
		break;
	case(CHANPHASE):
		fprintf(stdout,"INFO: INVERT THE PHASE OF A SPECIFIED CHANNEL OF AN INPUT FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHANNEL TO INVERT  .................................. Channel whose phase is to be inverted.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SILEND):
		fprintf(stdout,"INFO: PAD END OF SOUND WITH EXTRA SILENCE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS-----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODE 1: ................. Duration of silence to add.\n");
		fprintf(stdout,"INFO: MODE 2: ................. Total Duration of new output sound (must be greater than duration of input sound).\n");
		fprintf(stdout,"INFO: \n");
		break;
	default:
		fprintf(stdout,"ERROR: Unknown PROCESS\n");
		fprintf(stdout,"INFO: \n");
		break;
	}
	return 0;
}

void RoomReverbFormat(void)
{
	fprintf(stdout,"INFO: DELAY TIMES AMPS (& POSITIONS). A Text Datafile.\n");
	fprintf(stdout,"INFO:       Each line has either 2 vals (TIME , AMP of one of delays) or 3 (3rd is spatial POSITION in stereo space).\n");
	fprintf(stdout,"INFO:       TIMES (seconds) must be increasing. Duplicate times are ignored.\n");
	fprintf(stdout,"INFO:       A zero time (no delay) overrides the mix parameter, and determines the level and pan of the (effectively mono) input.\n");
	fprintf(stdout,"INFO:       AMP values must be in the range 0.0 to 1.0\n");
	fprintf(stdout,"INFO:       Empty lines and lines starting with a semi-colon (e.g. comments) are permitted.\n");
	fprintf(stdout,"INFO:       If a Position value is used in any line, outfile will be stereo.\n");
	fprintf(stdout,"INFO:       POSITION values are nominally in the range -1 to +1:     0 = centre.  If all position values are 0, the output will be mono.\n");
	fprintf(stdout,"INFO:       Values beyond these limits result in attenuation according to the inverse-square law, to suggest distance beyond the speakers.\n");
}