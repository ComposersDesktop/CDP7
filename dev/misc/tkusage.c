/*
 * Copyright (c) 1983-2013 Trevor Wishart and Composers Desktop Project Ltd
 * http://www.trevorwishart.co.uk
 * http://www.composersdesktop.com
 *
 This file is part of the CDP System.

    The CDP System is free software; you can redistribute it
    and/or modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    The CDP System is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with the CDP System; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA
 *
 */



/*
 * SOUND LOOM Release 9: November 2: 2004
 */

#include <stdio.h>
#include <structures.h>
#include <processno.h>
#include <edit.h>
#include <house.h>
#include <string.h>

#define TE_1	-1
#define TE_2	-2
#define TE_3	-3
#define TE_4	-4
#define TE_5	-5
#define TE_6	-6
#define TE_7	-7
#define TE_8	-8
#define TE_9	-9
#define TE_10	-10
#define TE_11	-11
#define TE_12	-12
#define TE_13	-13
#define TE_14	-14
#define TE_15	-15
#define TE_16	-16
#define TE_17	-17
#define TE_18	-18
#define TE_19	-19
#define TE_20	-20
#define TE_21	-21
#define TE_22	-22
#define TE_23	-23
#define TE_24	-24
#define TE_25	-25
#define TE_26	-26
#define TE_27	-27
#define TE_28	-28
#define TE_29	-29
#define TE_30	-30
#define TE_31	-31
const char* cdp_version = "6.1.0";

/******************************** TKUSAGE ********************************/

int main(int argc, char *argv[])
{
	int process;
	if(argc==2 && (strcmp(argv[1],"--version") == 0)) {
		fprintf(stdout,"%s\n",cdp_version);
		fflush(stdout);
		return 0;
	}
	if(argc!=2) {
		fprintf(stdout,"ERROR: Error in usage program tkusage\n");
		return -1;
	}
	if(sscanf(argv[1],"%d",&process)!=1) {
		fprintf(stdout,"ERROR: Failed to read process number in tkusage\n");
		return -1;
	}
	switch(process) {
	case(GAIN):
		fprintf(stdout,"INFO: AMPLIFY OR ATTENUATE THE SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GAIN may vary over time.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(LIMIT):
		fprintf(stdout,"INFO: ELIMINATE CHANNEL DATA BELOW A THRESHOLD AMP\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: THRESHOLD AMPLITUDE may vary over time.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(BARE):
		fprintf(stdout,"INFO: ZERO THE DATA IN CHANNELS WHICH DO NOT CONTAIN HARMONICS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Process needs TWO INPUT FILES,\n");
		fprintf(stdout,"INFO: an Analysis File, and a Pitchfile you have derived from it.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The PITCHFILE should normally be extracted\n");
		fprintf(stdout,"INFO: using KEEP PITCH ZEROS flag to mark any unpitched material.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CLEAN):
		fprintf(stdout,"INFO: REMOVE NOISE FROM PVOC ANALYSIS FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXTRA FILE REQUIRED-------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In all MODES except BY COMPARISON METHOD, ONE extra input file required.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Extra file is an analysis file cut from the 1st infile\n");
		fprintf(stdout,"INFO: to show typical noise (only) component of main signal.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BY COMPARISON METHOD, TWO extra input files required.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Extra files are both analysis files cut from 1st infile\n");
		fprintf(stdout,"INFO: to show typical noise (1st) & typical good signal (2nd).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FROM SPECIFIED TIME\n");
		fprintf(stdout,"INFO:     Deletes channel (after skiptime) FROM THE TIME its level falls below\n");
		fprintf(stdout,"INFO:     (noisgain adjusted) max level seen for that channel in comparison file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ANYWHERE\n");
		fprintf(stdout,"INFO:     Deletes channel (after skiptime) ANYWHERE its level falls below\n");
		fprintf(stdout,"INFO:     (noisgain adjusted) max level seen for that channel in comparison file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ABOVE SPECIFED FRQ\n");
		fprintf(stdout,"INFO:     Deletes channel as in 'ANYWHERE'\n");
		fprintf(stdout,"INFO:     but ONLY for channels of frq > LOW FRQ LIMIT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BY COMPARISON METHOD\n");
		fprintf(stdout,"INFO:     Deletes channel EVERYWHERE, whose level in GFILE is ALWAYS below\n");
		fprintf(stdout,"INFO:     (noisgain adjusted) max level seen for same channel in NFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SKIPTIME.......may be set to time where good src. signal level established.\n");
		fprintf(stdout,"INFO: NOISE PREGAIN..multiplies noiselevels found in comparison files\n");
		fprintf(stdout,"INFO: before they are used for comparison with main signal.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CUT):
		fprintf(stdout,"INFO: CUT SECTION OUT OF ANALYSIS FILE, BETWEEN STARTTIME & ENDTIME (SECS)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAB):
		fprintf(stdout,"INFO: GRAB A SINGLE ANALYSIS WINDOW\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: at time FREEZE MOMENT.\n");
		fprintf(stdout,"INFO: A time beyond end of file will grab last window in file,\n");
		fprintf(stdout,"INFO: (window at time zero is always uninteresting).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MAGNIFY):
		fprintf(stdout,"INFO: MAGNIFY A SINGLE ANALYSIS WINDOW\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: at time FREEZE MOMENT, to duration OUTFILE DURATION.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(STRETCH):
		fprintf(stdout,"INFO: STRETCH THE FREQUENCIES IN THE SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FRQ DIVIDE...............frq above or below which stretching takes place.\n");
		fprintf(stdout,"INFO: TOP OF SPECTRUM STRETCH..transposition ratio for topmost spectral components.\n");
		fprintf(stdout,"INFO: STRETCH EXPONENT.........specifies the type of stretching required.\n");
		fprintf(stdout,"INFO: PROCESS DEPTH............controls effect on source (from no effect to full),\n");
		fprintf(stdout,"INFO: .........................0 gives no stretching, 1 gives full stretching.\n");
		fprintf(stdout,"INFO: .........................Use to change the stretching from moment to moment.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TSTRETCH):
		fprintf(stdout,"INFO: TIME-STRETCHING OF INFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: without changing the pitch.\n");
		fprintf(stdout,"INFO: In mode GET OUTPUT LENGTH, program calculates length of output, only.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ALT):
		fprintf(stdout,"INFO: DELETE ALTERNATE HARMONICS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Requires TWO INPUT FILES, an Analysis file and a Pitch data file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Additional pitchfile must be derived from input analysis file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Mode DELETE ODD HARMONICS\n");
		fprintf(stdout,"INFO: can produces octave up transposition with NO formant change.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(OCT):
		fprintf(stdout,"INFO: OCTAVE TRANSPOSE WITHOUT FORMANT SHIFT\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Requires TWO INPUT FILES, an Analysis file and a Pitch data file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Additional pitchfile must be derived from input analysis file.\n");
		fprintf(stdout,"INFO: TRANSPOSITION RATIO..is integer: 2 is an octave, 3 is a 12th etc.\n");
		fprintf(stdout,"INFO:                      as in the harmonic series.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SHIFTP):
		fprintf(stdout,"INFO: SHIFT PITCH OF (PART OF) SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FRQ DIVIDE...... is freq above or below which transposition takes place.\n");
		fprintf(stdout,"INFO: TRANSPOSITION....is transposition above or below FRQ DIVIDE.\n");
		fprintf(stdout,"INFO: TRANSPOSITION 1..is transposition above FRQ DIVIDE. (semitones)\n");
		fprintf(stdout,"INFO: TRANSPOSITION 2..is transposition below FRQ DIVIDE. (semitones)\n");
		fprintf(stdout,"INFO: DEPTH............is effect on source (from no effect to full)).\n");
		fprintf(stdout,"INFO: .................0 gives no shift, 1 gives full shift.\n");
		fprintf(stdout,"INFO: .................Use to change the shifting from moment to moment.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TUNE):
		fprintf(stdout,"INFO: REPLACE SPECTRAL FRQS BY HARMONICS OF SPECIFIED PITCH(ES)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Data required is a pitch, or a textfile containing pitches.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FOCUS..........degree of focusing of partial pitches onto template.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CLARITY........degree to which non-template partials are suppressed.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TRACE..........number of (window_by_window) most prominent channels\n");
		fprintf(stdout,"INFO: ...............to be replaced by template frqs. (default, all channels)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW FRQ LIMIT..frqs below this are ignored.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PICK):
		fprintf(stdout,"INFO: RETAIN ONLY CHANNELS WHICH MIGHT HOLD SPECIFIED PARTIALS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FUNDAMENTAL FRQ..of harmonic series, (or of calculation).\n");
		fprintf(stdout,"INFO: FRQ STEP.........Frequency step to be added to another frequency.\n");
		fprintf(stdout,"INFO: CLARITY..........extent to which data in other channels is suppressed.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CHORD):
		fprintf(stdout,"INFO: TRANSPOSITIONS OF SPECTRUM SUPERIMPOSED WITHIN EXISTING SPECTRAL ENVELOPE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Data required is file of (possibly fractional) semitone transposition values.\n");
		fprintf(stdout,"INFO: BOTTOM FRQ..frqs below this are filtered out.\n");
		fprintf(stdout,"INFO: TOP FRQ.....frqs above this are filtered out.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MULTRANS):
		fprintf(stdout,"INFO: TRANSPOSED VERSIONS OF SPECTRUM SUPERIMPOSED ON ORIGINAL\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Data required is file of (possibly fractional) semitone transposition values.\n");
		fprintf(stdout,"INFO: BOTTOM FRQ..frqs below this are filtered out.\n");
		fprintf(stdout,"INFO: TOP FRQ.....frqs above this are filtered out.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FILT):
		fprintf(stdout,"INFO: FILTER THE SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FILTER EDGE(S) WIDTH.....is the width of filter skirts, in Hz.\n");
		fprintf(stdout,"INFO: GAIN..is overall amplification of resulting sound.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GREQ):
		fprintf(stdout,"INFO: GRAPHIC EQ ON SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STANDARD BANDWIDTH\n");
		fprintf(stdout,"INFO: ....Data file has ONE bandwidth (octaves)\n");
		fprintf(stdout,"INFO: ....followed by centre frqs of all filter bands (Hz).\n");
		fprintf(stdout,"INFO: VARIOUS BANDWIDTHS\n");
		fprintf(stdout,"INFO: ....Data file has a pair of values for EVERY filter band,\n");
		fprintf(stdout,"INFO: ....representing centre frq of the band (Hz) followed by bandwidth (octaves).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SPLIT):
		fprintf(stdout,"INFO: SPLIT SPECTRUM INTO BANDS & PROCESS THESE INDIVIDUALLY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is a textfile of lines each with the following data..\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: lofrq   hifrq   bitflag   [amp1   amp2   [+]transpose]\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOFRQ and HIFRQ define the limits of a frequency band in the spectrum\n");
		fprintf(stdout,"INFO:            which you wish to modify.\n");
		fprintf(stdout,"INFO:            These bands should NOT OVERLAP one another.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BITFLAG has 4 bits (e.g. '0101' or '1000')\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If bit 1 (on the left) is set: There is an amplitude change to the whole band.\n");
		fprintf(stdout,"INFO:            Put an amplitude multiplier ('amp1') in the line.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If bit 2 is set: The amplitude of the band ramps from amp1 to amp2.\n");
		fprintf(stdout,"INFO:            Put the start and end amplitude multipliers ('amp1' and 'amp2') in the line.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If bit 3 is set: The band is transposed, or shifted.\n");
		fprintf(stdout,"INFO:            To transpose, put a frequency multiplier ('transpose') in the line,\n");
		fprintf(stdout,"INFO:            To shift, put in a frequency shift value in Hz, BUT precede it with a '+' sign.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If bit 4 (on the right) is set: the transposed partials are ADDED to the original spectrum.\n");
		fprintf(stdout,"INFO:            (Normally they will REPLACE the originals.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 'amp1', 'amp2' &/or 'transpose' MUST be present, where required by the preceding bitflag.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ARPE):
		fprintf(stdout,"INFO: ARPEGGIATE THE SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES--------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ON...........Play components inside arpeggiated band ONLY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BOOST........Amplify snds in band. Others play unamplified.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BELOW_BOOST..INITIALLY Play components in & below band ONLY.\n");
		fprintf(stdout,"INFO: .............THEN amplify snds in band. Others play unamplified.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ABOVE_BOOST..INITIALLY Play components in & above band ONLY.\n");
		fprintf(stdout,"INFO: .............THEN amplify snds in band. Others play unamplified.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BELOW........Play components in & below arpeggiated band ONLY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ABOVE........Play components in & above arpeggiated band ONLY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ONCE_BELOW...INITIALLY Play components in and below band ONLY.\n");
		fprintf(stdout,"INFO: .............THEN play whole sound as normal.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ONCE_ABOVE...INITIALLY Play components in and above arpeggiated band ONLY.\n");
		fprintf(stdout,"INFO: .............THEN play whole sound as normal.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WAVETYPE..............1=downramp : 2=sin : 3=saw : 4=upramp\n");
		fprintf(stdout,"INFO: RATE OF SWEEP.........arpeggio sweeps per second.\n");
		fprintf(stdout,"INFO: START PHASE...........start_phase of arpeggio sweep.\n");
		fprintf(stdout,"INFO: LOFRQ LIMIT...........lowest freq arpeg sweeps down to.\n");
		fprintf(stdout,"INFO: HIFRQ LIMIT...........highest freq arpeg sweeps up to.\n");
		fprintf(stdout,"INFO: BANDWIDTH.............bandwidth of sweep band (in Hz).\n");
		fprintf(stdout,"INFO: AMPLIFICATION.........amplification of arpegiated components.\n");
		fprintf(stdout,"INFO: NONLINEAR DECAY.......Nonlinear decay of arpegtones. >1 faster, <1 slower.\n");
		fprintf(stdout,"INFO: SUSTAIN WINDOWS.......Number of windows over which arpegtones sustained.\n");
		fprintf(stdout,"INFO: TRACK FRQ CHANGE.... .Amplified tones track changing frq of src.\n");
		fprintf(stdout,"INFO: SUSTAINS RUN TO ZERO..Amplified tones allowed to decay to zero\n");
		fprintf(stdout,"INFO: ......................before new arpegtone attack initiated\n");
		fprintf(stdout,"INFO: ......................(Default: Re-attack once decayed below input level)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PLUCK):
		fprintf(stdout,"INFO: EMPHASISE SPECTRAL CHANGES (use e.g. with HILITE ARPEG)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GAIN...amplitude gain applied to newly prominent spectral components.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(S_TRACE):
		fprintf(stdout,"INFO: RETAIN THE N LOUDEST PARTIALS ONLY (ON A WINDOW-BY-WINDOW BASIS)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(BLTR):
		fprintf(stdout,"INFO: TIME-AVERAGE, AND TRACE, THE SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BLURRING FACTOR..is number of windows over which to average the spectrum.\n");
		fprintf(stdout,"INFO: TRACING INDEX....is number of (loudest) channels to retain, in each window.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ACCU):
		fprintf(stdout,"INFO: SUSTAIN EACH SPECTRAL BAND, UNTIL LOUDER DATA APPEARS IN THAT BAND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DECAY RATE....sutained channel data decays by DECAYRATE per sec.\n");
		fprintf(stdout,"INFO: GLISS RATE....sutained channel data glisses at GLISRATE 8vas per sec.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(EXAG):
		fprintf(stdout,"INFO: EXAGGERATE SPECTRAL CONTOUR\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXAGGERATION >0 will widen troughs: <0 will widen peaks.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FOCUS):
		fprintf(stdout,"INFO: FOCUS SPECTRAL ENERGY ONTO PEAKS IN SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FILTER BANDWIDTH.........bandwidth of peak-centred filters, in octaves.\n");
		fprintf(stdout,"INFO: BOTTOM FRQ...............is bottom frequency to start peak search.\n");
		fprintf(stdout,"INFO: TOP FRQ..................is frequency to end peak search.\n");
		fprintf(stdout,"INFO: WINDOWCNT FOR STABILITY..Number of windows over which to scan for peak stability.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FOLD):
		fprintf(stdout,"INFO: OCTAVE-TRANSPOSE SPECTRAL COMPONENTS INTO SPECIFIED RANGE\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FREEZE):
		fprintf(stdout,"INFO: FREEZE SPECTRAL CHARACTERISTICS IN SOUND, AT GIVEN TIMES \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Requied data is a textfile of times at which spectrum is frozen.\n");
		fprintf(stdout,"INFO: These times may be preceded by character MARKERS....\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 'a' meaning, use this window as freezewindow for AFTER this time.\n");
		fprintf(stdout,"INFO: 'b' meaning, use this window as freezewindow for BEFORE this time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Otherwise, times are end-or-start of a freeze thus established.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FREEZE2):
		fprintf(stdout,"INFO: HOLD SOUND SPECTRUM, AT GIVEN TIMES \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Datafile contains times at which spectrum is held, & hold-duration.\n");
		fprintf(stdout,"INFO: These data items must be paired correctly.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(STEP):
		fprintf(stdout,"INFO: STEP-FRAME THROUGH SOUND BY FREEZING SPECTRUM AT REGULAR TIME INTERVALS\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(AVRG):
		fprintf(stdout,"INFO: AVERAGE SPECTRAL ENERGY OVER N ADJACENT CHANNELS\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(BLUR):
		fprintf(stdout,"INFO: TIME-AVERAGE THE SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BLURRING FACTOR is number of windows over which to average spectrum.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SUPR):
		fprintf(stdout,"INFO: SUPPRESS THE N LOUDEST PARTIALS (ON A WINDOW-BY-WINDOW BASIS)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CHORUS):
		fprintf(stdout,"INFO: CHORUSING BY RANDOMISING AMPLITUDES AND/OR FREQUENCIES OF PARTIALS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AMP SPREAD is maximum random scatter of partial-amps.\n");
		fprintf(stdout,"INFO: FRQ SPREAD is maximum random scatter of partial-frqs.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DRUNK):
		fprintf(stdout,"INFO: MODIFY SOUND BY DRUNKEN WALK ALONG ANALYSIS WINDOWS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RANGE IN WINDOWS...is maximum step (in windows) for drunken walk.\n");
		fprintf(stdout,"INFO: STARTTIME IN FILE..is time (in secs) in file to begin walk.\n");
		fprintf(stdout,"INFO: OUTFILE DURATION...is required duration of outfile.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SHUFFLE):
		fprintf(stdout,"INFO: SHUFFLE ORDER OF ANALYSIS WINDOWS IN FILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is 2 strings of letters, separated by a '-' or ':'\n");
		fprintf(stdout,"INFO: The first string is the DOMAIN, and the 2nd, the IMAGE.\n");
		fprintf(stdout,"INFO: e.g. 'abc-abbabcc'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DOMAIN.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Letters represent group of consecutive inputfile analysis_windows.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: e.g. 'abcd'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IMAGE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Any permutation of, or selection from, the domain letters.\n");
		fprintf(stdout,"INFO: (domain letters may be omitted or repeated in the image string).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: e.g. 'aaaaaaadaaa'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Inputfile windows are shuffled according to this same mapping.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GROUPSIZE Windows may be grouped in sets of GROUPSIZE\n");
		fprintf(stdout,"INFO: ..........before being shuffled (as groups), and in this case\n");
		fprintf(stdout,"INFO: ..........each domain-letter represents a group of GROUPSIZE windows.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(WEAVE):
		fprintf(stdout,"INFO: MODIFY SOUND BY WEAVING AMONGST ANALYSIS WINDOWS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Special data file contains a list of integers\n");
		fprintf(stdout,"INFO: which define successive steps (in windows) through the input file.\n");
		fprintf(stdout,"INFO: Steps may be forward or backwards.\n" );
		fprintf(stdout,"INFO: The step sequence is repeated until end of infile is reached.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Weave must obey the following rules....\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RULE 1:  NO step can exceed a certain limit value\n");
		fprintf(stdout,"INFO: RULE 2:  NO window reached in a weave can be BEFORE startwindow of weave.\n");
		fprintf(stdout,"INFO: RULE 3:  FINAL window must be AFTER the weave startwindow.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Otherwise, weave may be forward or backward, or remain at same window.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(NOISE):
		fprintf(stdout,"INFO: PUT NOISE IN THE SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SCAT):
		fprintf(stdout,"INFO: RANDOMLY THIN OUT THE SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FRQ-BLOCKS TO KEEP....Number of (randomly-chosen) blocks to keep, per window.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FRQ RANGE OF BLOCK....(Rounded internally to a multiple of channel width).\n");
		fprintf(stdout,"INFO: ......................(default is width of 1 analysis channel).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: KEEP RANDOM SET ONLY..Number of blocks actually kept randomised\n");
		fprintf(stdout,"INFO: ......................between 1 & FRQ-BLOCKS TO KEEP.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SPREAD):
		fprintf(stdout,"INFO: SPREAD PEAKS OF SPECTRUM, INTRODUCING CONTROLLED NOISINESS\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SHIFT):
		fprintf(stdout,"INFO: LINEAR FREQUENCY SHIFT OF (PART OF) THE SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FRQ DIVIDE...............frq at which shifting starts or stops.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW FRQ & HIGH FRQ.......define range inside or outside which shift takes place.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOG INTERP CHANGING FRQ..useful only if any input params are time-varying,\n");
		fprintf(stdout,"INFO:..........................and frqshift vals are all +ve, or all -ve.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GLIS):
		fprintf(stdout,"INFO: CREATE GLISSANDI INSIDE THE (CHANGING) SPECTRAL ENVELOPE OF ORIGINAL SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GLISS RATE.......in semitones per second (-ve val for downward gliss).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARTIAL SPACING..in Hz for partials in inharmonic glide.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: HIGH FRQ LIMIT...is top of spectrum.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(WAVER):
		fprintf(stdout,"INFO: OSCILLATE BETWEEN HARMONIC AND INHARMONIC STATE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX SPECTRAL STRETCH..is max spectral stretch in inharmonic state.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXPONENT..............defines type of stretch in inharmonic state.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INVERT):
		fprintf(stdout,"INFO: INVERT THE SPECTRUM\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GLIDE):
		fprintf(stdout,"INFO: INTERPOLATE, LINEARLY, BETWEEN 2 SINGLE ANALYSIS WINDOWS\n");
		fprintf(stdout,"INFO: EXTRACTED WITH spec grab.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(BRIDGE):
		fprintf(stdout,"INFO: MAKE A BRIDGING-INTERPOLATION BETWEEN TWO SOUND SPECTRA\n");
		fprintf(stdout,"INFO: BY INTERPOLATING BETWEEN 2 TIME-SPECIFIED WINDOWS IN THE 2 INFILES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 2ND FILE OFFSET......time infile2 starts, relative to start of file1.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FRQ INTERP AT START..fraction of 2nd sound's frq interpolated at START.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AMP INTERP AT START..fraction of 2nd sound's amp interpolated at START.\n");
		fprintf(stdout,"INFO: .....................If an OFFSET is used, when these interps NOT set to zero,\n");
		fprintf(stdout,"INFO: .....................outsound starts from point where 2nd sound enters.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FRQ INTERP AT END....fraction of 2nd sound's frq interpolated at END.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AMP INTERP AT END....fraction of 2nd sound's amp interpolated at END.\n");
		fprintf(stdout,"INFO: .....................if these are set < 1.0\n");
		fprintf(stdout,"INFO: .....................outsound ends at end of 1st sound to end.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STARTTIME IN FILE1.. of window where interpolation begins.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENDTIME IN FILE1.... of window where interpolation ends.\n");
		fprintf(stdout,"INFO: .....................if START and END are not specified\n");
		fprintf(stdout,"INFO: .....................interp runs from OFFSET to end of 1st file to end.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MORPH):
		fprintf(stdout,"INFO: MORPH ONE SPECTRUM INTO ANOTHER.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: -------------------------------------------------------\n");
		fprintf(stdout,"INFO: MODES..\n");
		fprintf(stdout,"INFO: (1) interpolate LINEARLY (exponent 1)\n");
		fprintf(stdout,"INFO:         or over a curve of increasing (exp >1) or decreasing (exp <1) slope.\n");
		fprintf(stdout,"INFO: (2) interpolate over a COSINUSOIDAL spline.\n");
		fprintf(stdout,"INFO: -------------------------------------------------------\n");
		fprintf(stdout,"INFO: PARAMETERS..\n");
		fprintf(stdout,"INFO: Start and End times for Interpolation of Channel Frequencies.\n");
		fprintf(stdout,"INFO: Start and End times for Interpolation of Channel Amplitudes.\n");
		fprintf(stdout,"INFO: Exponents of the Interpolations (see above).\n");
		fprintf(stdout,"INFO: (In COSIN mode, these skew the cosinusional interpolation).\n");
		fprintf(stdout,"INFO: 2nd FILE ENTRY TIME is time-delay of entry of 2nd file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PITCH):
		fprintf(stdout,"INFO: ATTEMPT TO EXTRACT PITCH FROM SPECTRAL DATA.\n" );
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1st OUTPUTFILE, if resynthesized, produces tone at detected pitch.\n");
		fprintf(stdout,"INFO: 2nd OUTPUTFILE contains the extracted pitch data.\n");
		fprintf(stdout,"INFO: In mode TO BINARY FILE this is a binary output file.\n");
		fprintf(stdout,"INFO: In mode TO TEXTFILE this is a brkpnt text file of time/pitch pairs.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IN-TUNE RANGE................ range within which harmonics accepted as in tune.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN WINDOWS TO CONFIRM PITCH..minimum number of adjacent windows that must be\n");
		fprintf(stdout,"INFO: ..............................pitched, for pitch-value to be registered.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SIGNAL TO NOISE RATIO........ in decibels.\n");
		fprintf(stdout,"INFO: ..............................Windows more than this below the maximum level\n");
		fprintf(stdout,"INFO: ..............................in the sound, are assumed to be noise,\n");
		fprintf(stdout,"INFO: ..............................& any detected pitch is assumed spurious.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: VALID HARMONICS COUNT........ how many of loudest peaks in spectrum must be\n");
		fprintf(stdout,"INFO: ..............................harmonics to confirm sound is pitched.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW PITCH LIMIT.............. frequency of LOWEST acceptable pitch.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: HIGH PITCH LIMIT..............frequency of HIGHEST acceptable pitch.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DATAREDUCTION................ acceptable pitch-ratio error in data reduction.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_APPROX):
		fprintf(stdout,"INFO: MAKE AN APPROXIMATE COPY OF A PITCHFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCH SCATTER RANGE...Interval over which pitch +- randomly varies from orig.\n");
		fprintf(stdout,"INFO: TIME SCATTER RANGE....Time-interval by which pitchval can stray from orig time.\n");
		fprintf(stdout,"INFO: CONTOUR SCAN RANGE....Time-interval over which pitch contour scanned.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_EXAG):
		fprintf(stdout,"INFO: EXAGGERATE PITCH CONTOUR OF A PITCH DATA FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MEANPITCH...........pitch around which intervals stretched.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_INVERT):
		fprintf(stdout,"INFO: INVERT PITCH CONTOUR OF A PITCH DATA FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is either '0' (if no mapping is required)\n");
		fprintf(stdout,"INFO: or a a textfile of paired values showing how intervals\n");
		fprintf(stdout,"INFO: (in, possibly fractional, semitones) are to be mapped\n");
		fprintf(stdout,"INFO: onto their inversions.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INVERSION CENTRE...pitch around which pitchline inverted.\n");
		fprintf(stdout,"INFO: LOW PITCH LIMIT....lowest pitch permissible.\n");
		fprintf(stdout,"INFO: HIGH PITCH LIMIT...highest pitch permissible.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_QUANTISE):
		fprintf(stdout,"INFO: QUANTISE PITCHES IN A PITCH DATA FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is a textfile of (possibly fractional) MIDI pitchvals\n");
		fprintf(stdout,"INFO: over which pitch to be quantised.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DUPLICATE Q-SET IN ALL OCTAVES\n");
		fprintf(stdout,"INFO: ....causes entered pitches to be duplicated in all 8vas,\n");
		fprintf(stdout,"INFO: ....to generate actual quantisation set used.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_RANDOMISE):
		fprintf(stdout,"INFO: RANDOMISE PITCH LINE IN A PITCH DATA FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX INTERVAL OF STRAY..(semitones) is interval over which pitches can +- randomvary.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIMESTEP...............is max timestep between random pitch fluctuations.\n");
		fprintf(stdout,"INFO:........................Actual timesteps are random values less than this.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RANGE SLEW.............e.g. 2: upward variation range twice that of downward.\n");
		fprintf(stdout,"INFO: .......................e.g -3: downward variation range 3 times that of upward.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_SMOOTH):
		fprintf(stdout,"INFO: SMOOTH PITCH CONTOUR IN A PITCH DATA FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIMEFRAME..over which to interpolate pitch values.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MEANPITCH..is pitch from which peaks measured for interpolation\n");
		fprintf(stdout,"INFO: ...........between PEAK value in each timeframe block of pitch values.\n");
		fprintf(stdout,"INFO: ...........(and must be within pitch range, in every timeframe block).\n");
		fprintf(stdout,"INFO: ...........Peak is maximum displacement from mean (up or down).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_SYNTH):
		fprintf(stdout,"INFO: SYNTHESIZE SPECTRUM OF A SOUND FOLLOWING PITCH IN INPUT PITCHFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARTIAL LEVELS......level of each partial, in turn, starting from 1st.\n");
		fprintf(stdout,"INFO: Use as many or as few partials as required.\n");
		fprintf(stdout,"INFO: Levels must lie beween 0 and 1.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_GEN):
		fprintf(stdout,"INFO: CREATE A BINARY PITCHDATA FILE FROM INFORMATION IN A TEXTFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCH DATA......A file of pitch values and associated times, as time-value pairs.\n");
		fprintf(stdout,"INFO: ......................These may be note names (A-G), possibly followed by '#'(sharp) or 'b' (flat),\n");
		fprintf(stdout,"INFO: ......................all followed by an octave value (where 0 is octave starting at middle C).\n");
		fprintf(stdout,"INFO: ......................ALTERNATIVELY these may be numeric MIDI values (possibly fractional).\n");
		fprintf(stdout,"INFO: SAMPLE RATE OF GOAL SNDFILE.\n");
		fprintf(stdout,"INFO: ......................Typical use would be to generate a synthesized vowel stream,\n");
		fprintf(stdout,"INFO: ......................and this parameter specifies the sample rate of the output SOUND\n");
		fprintf(stdout,"INFO: ......................of any such subsequent process.\n");
		fprintf(stdout,"INFO: ANALYSIS POINTS.......(2-32768 (power of 2)): default 1024\n");
		fprintf(stdout,"INFO: ......................More points give better freq resolution\n");
		fprintf(stdout,"INFO: ......................but worse time-resolution (e.g. rapidly changing spectrum).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OVERLAP...............Filter overlap factor (1-4): default 3\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_INTERP):
		fprintf(stdout,"INFO: REMOVE UNPITCHED OR SILENT WINDOWS, BY INTERPOLATING BETWEEN EXISTING PITCHES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) GLIDE ............ interpolated pitch moves smoothly from pitch\n");
		fprintf(stdout,"INFO: ..................... before noise-or-silence to pitch after it.\n");
		fprintf(stdout,"INFO: 1) SUSTAIN........... pitch before noise-or-silence is sustained\n");
		fprintf(stdout,"INFO: ..................... until a new pitch occurs.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_VOWELS):
		fprintf(stdout,"INFO: SYNTHESIZE (POSSIBLY CHANGING) VOWEL SPECTRUM OF SOUND FOLLOWING PITCHFILE PITCH.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: VOWELS......file containing paired times and vowels, where vowels can be....\n");
		fprintf(stdout,"INFO: ee    as in 'heat'               i     as in 'hit'                e     as in 'pet'                ai    as in 'hate'\n");
		fprintf(stdout,"INFO: a     as in 'pat'                ar    as in 'heart'              o     as in 'hot'                or    as in 'taught'\n");
		fprintf(stdout,"INFO: oa    as in 'boat'               u     as in 'hood'               oo    as in 'mood'\n");
		fprintf(stdout,"INFO: xx    as in Southern English 'hub'\n");
		fprintf(stdout,"INFO: x     neutral vowel as in 'herb' or 'the'\n");
		fprintf(stdout,"INFO: aii   as in Scottish educAted    uu    as in Scottish edUcated    ui     as in Scottish cOUld\n");
		fprintf(stdout,"INFO: n     as in 'Now'                m     as in 'Make'               r      as in 'Raw'               th    as in 'THe'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Times must start at zero, and increase.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FORMANT HALF-WIDTH ........half-width of formant peaks, in Hz, as a fraction of formant centre-frq.\n");
		fprintf(stdout,"INFO: FORMANT PEAK STEEPNESS ....is steepness of the formant peaks.\n");
		fprintf(stdout,"INFO: FORMANT PEAK RANGE ........is the ratio of (max) peak range to (max) total range.\n");
		fprintf(stdout,"INFO: EMPHASIS ON FUNDAMENTAL ...is (relative) amplitude of fundamental, if it falls outside a formant.\n");
		fprintf(stdout,"INFO: HOARSENESS .........is extent of (random) variation of partial frqs from frequency of true harmonics.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(VFILT):
		fprintf(stdout,"INFO: IMPOSE (POSSIBLY CHANGING) VOWEL SPECTRUM ON A SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: VOWELS......file containing paired times and vowels, where vowels can be....\n");
		fprintf(stdout,"INFO: ee    as in 'heat'               i     as in 'hit'                e     as in 'pet'                ai    as in 'hate'\n");
		fprintf(stdout,"INFO: a     as in 'pat'                ar    as in 'heart'              o     as in 'hot'                or    as in 'taught'\n");
		fprintf(stdout,"INFO: oa    as in 'boat'               u     as in 'hood'               oo    as in 'mood'\n");
		fprintf(stdout,"INFO: xx    as in Southern English 'hub'\n");
		fprintf(stdout,"INFO: x     neutral vowel as in 'herb' or 'the'\n");
		fprintf(stdout,"INFO: aii   as in Scottish educAted    uu    as in Scottish edUcated    ui     as in Scottish cOUld\n");
		fprintf(stdout,"INFO: n     as in 'Now'                m     as in 'Make'               r      as in 'Raw'               th    as in 'THe'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Times must start at zero, and increase.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FORMANT HALF-WIDTH .......half-width of formant peaks, in Hz, as a fraction of formant centre-frq.\n");
		fprintf(stdout,"INFO: FORMANT PEAK STEEPNESS ...is steepness of the formant peaks.\n");
		fprintf(stdout,"INFO: FORMANT PEAK RANGE .......is the ratio of (max) peak range to (max) total range.\n");
		fprintf(stdout,"INFO: THRESHOLD ................spectral window only affected if its level exceeds a proportion of vowel envelope level for window\n");
		fprintf(stdout,"INFO: ..........................Threshold is this proportion.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_INSERT):
		fprintf(stdout,"INFO: MARK AS UNPITCHED THOSE WINDOWS IN BINARY PITCHFILE BETWEEN GIVEN TIME-PAIRS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INSERTION TIMEPAIRS.......Times between which data is marked as unpitched.\n");
		fprintf(stdout,"INFO: Time can be given in seconds, or as sample-cnt in the corresponding soundfile.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_SINSERT):
		fprintf(stdout,"INFO: MARK AS SILENT THOSE WINDOWS IN BINARY PITCHFILE BETWEEN GIVEN TIME-PAIRS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INSERTION TIMEPAIRS.......Times between which data is marked as silent.\n");
		fprintf(stdout,"INFO: Time can be given in seconds, or as sample-cnt in the corresponding soundfile.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_PTOSIL):
		fprintf(stdout,"INFO: IN A BINARY PITCHFILE, CONVERT ALL PITCHED WINDOWS TO SILENCE.\n");
		break;
	case(P_NTOSIL):
		fprintf(stdout,"INFO: IN A BINARY PITCHFILE, CONVERT ALL UNPITCHED WINDOWS TO SILENCE.\n");
		break;
	case(ANALENV):
		fprintf(stdout,"INFO: EXTRACT THE WINDOW-LOUDNESS ENVELOPE OF AN ANALYSIS FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Extract the total loudness of each window\n");
		fprintf(stdout,"INFO: in format compatible with pitch or formant data taken from same analysis file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MAKE2):
		fprintf(stdout,"INFO: GENERATE SPECTRUM FROM PITCH, FORMANT AMD ENVELOPE DATA.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: outfile is analysis file which must be resynthesized to hear.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_TRANSPOSE):
		fprintf(stdout,"INFO: TRANSPOSES PITCHES IN PITCHDATA FILE BY CONSTANT NO OF SEMITONES.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_VIBRATO):
		fprintf(stdout,"INFO: ADD VIBRATO TO PITCH IN A PITCH DATA FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: VIBRATO FRQ....frequency of vibrato itself (Hz).\n");
		fprintf(stdout,"INFO: VIBRATO RANGE..max interval vibrato moves from central pitch.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_CUT):
		fprintf(stdout,"INFO: CUT OUT AND KEEP A SEGMENT OF A BINARY PITCH-DATAFILE.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_FIX):
		fprintf(stdout,"INFO: MASSAGE PITCH DATA IN A BINARY PITCHFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If NOT in Instrument-Create or Bulk-Process mode,\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: This is a GRAPHIC EDITOR FOR PITCH DATA.\n");
		fprintf(stdout,"INFO: and HELP is provided on the window which appears.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OTHERWISE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Pitchdata should first be viewed with PITCH VIEW (PITCH INFO menu)....\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: THEN THE FOLLOWING RULES SHOULD BE OBSERVED.........\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (1)\n");
		fprintf(stdout,"INFO: When pitches are removed they are replaced by a 'no-pitch' indicator.\n");
		fprintf(stdout,"INFO: These (and any already existing unpitched windows in the file) can be\n");
		fprintf(stdout,"INFO: converted to pitch-data (by interpolation between adjacent pitches)\n");
		fprintf(stdout,"INFO: using the INTERPOLATE flag.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (2)\n");
		fprintf(stdout,"INFO: With multiple flags, ORDER of operations inside program is....\n");
		fprintf(stdout,"INFO: REMOVE-TIMEWISE, REMOVE-FRQWISE, SMOOTH, FORCE-ENDVALS, INTERP\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(REPITCH):
		fprintf(stdout,"INFO: GENERATE TRANSPOSITION DATA FROM 2 SETS OF PITCH DATA,\n" );
		fprintf(stdout,"INFO: OR TRANSPOSE PITCH DATA WITH TRANSPOSITION DATA,\n" );
		fprintf(stdout,"INFO: OR COMBINE 2 SETS OF TRANSPOSITION DATA TO FORM NEW TRANSPOSITION DATA,\n");
		fprintf(stdout,"INFO: PRODUCING BINARY DATAFILE OUTPUT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Input files may be binary files, or text brkpnt files BUT...\n");
		fprintf(stdout,"INFO: It's IMPOSSIBLE to generate binary outfile from exclusively brkpnt infiles.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(REPITCHB):
		fprintf(stdout,"INFO: GENERATE TRANSPOSITION DATA FROM 2 SETS OF PITCH DATA,\n" );
		fprintf(stdout,"INFO: OR TRANSPOSE PITCH DATA WITH TRANSPOSITION DATA,\n" );
		fprintf(stdout,"INFO: OR COMBINE 2 SETS OF TRANSPOSITION DATA TO FORM NEW TRANSPOSITION DATA,\n");
		fprintf(stdout,"INFO: PRODUCING A TIME/VAL BRKPNT TEXTFILE OUTPUT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Input files may be binary files, or text brkpnt files.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DATAREDUCTION..is acceptable pitch error in brkpntfile data-reduction.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TRNSF):
		fprintf(stdout,"INFO: TRANSPOSE SPECTRUM : BUT RETAIN ORIGINAL SPECTRAL ENVELOPE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODE names refer to the type of data which is to be used.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MINFRQ...minimum frq, below which data is filtered out.\n");
		fprintf(stdout,"INFO: MAXFRQ...maximum frq, above which data is filtered out.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TRNSP):
		fprintf(stdout,"INFO: TRANSPOSE SPECTRUM (SPECTRAL ENVELOPE ALSO MOVES)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODE names refer to the type of data which is to be used.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MINFRQ...minimum frq, below which data is filtered out.\n");
		fprintf(stdout,"INFO: MAXFRQ...maximum frq, above which data is filtered out.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FORMANTS):
		fprintf(stdout,"INFO: EXTRACT EVOLVING FORMANT ENVELOPE FROM AN ANALYSIS FILE.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FORM):
		fprintf(stdout,"INFO: IMPOSE SPECTRAL ENVELOPE IN A FORMANTFILE\n");
		fprintf(stdout,"INFO: ON SPECTRUM IN AN ANALYSIS FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REPLACE FORMANTS......New formants REPLACE existing formant envelope.\n");
		fprintf(stdout,"INFO: SUPERIMPOSE FORMANTS..New formants IMPOSED ON TOP OF existing formants.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW FRQ LIMIT...frq, below which spectrum is set to zero.\n");
		fprintf(stdout,"INFO: HIGH FRQ LIMIT..frq, above which spectrum is set to zero.\n");
		fprintf(stdout,"INFO: GAIN............adjustment to spectrum loudness (normally < 1.0).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(VOCODE):
		fprintf(stdout,"INFO: IMPOSE SPECTRAL ENVELOPE OF 2nd SOUND, ON 1st SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW FRQ LIMIT...frq below which data is filtered out.\n");
		fprintf(stdout,"INFO: HIGH FRQ LIMIT..frq above which data is filtered out.\n");
		fprintf(stdout,"INFO: GAIN............adjustment to output level (normally < 1.0).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FMNTSEE):
		fprintf(stdout,"INFO: CONVERT FORMANT DATA IN A BINARY FORMANTDATA FILE TO 'SNDFILE' FOR VIEWING.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The resulting logarithmically scaled display indicates formant shapes,\n");
		fprintf(stdout,"INFO: but NOT the absolute amplitude values.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DISPLAY FORMANTBAND DATA....displays information about formant banding used.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WARNING: DO NOT ATTEMPT TO PLAY THE RESULTING 'SOUNDFILE'\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FORMSEE):
		fprintf(stdout,"INFO: EXTRACT FORMANTS FROM ANALFILE AND WRITE AS 'SNDFILE' FOR VIEWING.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The resulting logarithmically scaled display indicates formant shapes,\n");
		fprintf(stdout,"INFO: but NOT the absolute amplitude values.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DISPLAY IN SEMITONE BANDS does just that (Default: equal hz bands).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WARNING: DO NOT ATTEMPT TO PLAY THE RESULTING 'SOUNDFILE'\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MAKE):
		fprintf(stdout,"INFO: GENERATE SPECTRUM FROM PITCH & FORMANT DATA ONLY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: outfile is analysis file which must be resynthesized to hear.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SUM):
		fprintf(stdout,"INFO: FIND SUM OF TWO SPECTRA.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CROSSOVER is amount of 2nd spectrum added to 1st\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DIFF):
		fprintf(stdout,"INFO: FIND DIFFERENCE OF TWO SPECTRA.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CROSSOVER is amount of 2nd spectrum subtracted from 1st.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(LEAF):
		fprintf(stdout,"INFO: INTERLEAVE WINDOWS FROM INFILES, LEAFSIZE WINDOWS PER LEAF.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MAX):
		fprintf(stdout,"INFO: IN EACH CHANNEL, IN EACH WINDOW, TAKE MAX VAL AMONGST INPUT FILES.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MEAN):
		fprintf(stdout,"INFO: GENERATE SPECTRAL 'MEAN' OF 2 SOUNDS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW FRQ LIMIT...... .of channels to average.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: HIGH FRQ LIMIT.......of channels to average.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHANNELS TO COMPARE..Number of significant chans to compare.\n");
		fprintf(stdout,"INFO: .....................Default: All within range.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CROSS):
		fprintf(stdout,"INFO: REPLACE CHANNEL AMPLITUDES OF 1st FILE WITH THOSE OF 2nd.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INTERPOLATION is degree of replacement.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(WINDOWCNT):
		fprintf(stdout,"INFO: RETURNS NUMBER OF ANALYSIS WINDOWS IN INFILE.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CHANNEL):
		fprintf(stdout,"INFO: RETURNS CHANNEL NUMBER CORRESPONDING TO FREQUENCY GIVEN.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FREQUENCY):
		fprintf(stdout,"INFO: RETURNS CENTRE FRQ OF CHANNEL SPECIFIED.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(LEVEL):
		fprintf(stdout,"INFO: CONVERTS (VARYING) LEVEL OF ANALFILE TO PSEUDO-SNDFILE\n");
		fprintf(stdout,"INFO: (1 WINDOW -> 1 SAMPLE)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: View with a sndfile display program. DO NOT ATTEMPT TO PLAY FILE!!\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(OCTVU):
		fprintf(stdout,"INFO: DISPLAY TIMEVARYING AMPLITUDE OF SPECTRUM, WITHIN OCTAVE BANDS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIMESTEP.........is timestep between viewing bands.\n");
		fprintf(stdout,"INFO: .................Band-energy is totalled over each timestep duration.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FUNDAMENTAL FRQ..Bands centered on octave transpositions of fundamental.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The reported values are RELATIVE levels only\n");
		fprintf(stdout,"INFO: and the lowest band includes all energy down to '0Hz'.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTFILE is a text file\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PEAK):
		fprintf(stdout,"INFO: LOCATE TIME-VARYING ENERGY CENTRE OF SPECTRUM.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW FRQ LIMIT..above which spectral search begins\n");
		fprintf(stdout,"INFO: TIME WINDOW....for energy averaging: in SECONDS\n");
		fprintf(stdout,"INFO: FRQ WINDOW.....for energy averaging: in SEMITONES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTFILE is a text file of lines of data in form...\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:               WINDOW starttime endtime : PEB lofrq TO hifrq'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (where 'PEB' means PEAK ENERGY BAND)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(REPORT):
		fprintf(stdout,"INFO: REPORT ON LOCATION OF FREQUENCY PEAKS IN EVOLVING SPECTRUM,\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PEAKS TO FIND.......(max) number of peaks to find.\n");
		fprintf(stdout,"INFO: LOW FRQ LIMIT.......bottom frequency to start peak search.\n");
		fprintf(stdout,"INFO: HIGH FRQ LIMIT......top frequency to stop peak search.\n");
		fprintf(stdout,"INFO: WINDOWS TO AVERAGE..number of windows over which peaks averaged.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTFILE is a textfile\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PRINT):
		fprintf(stdout,"INFO: PRINT DATA IN ANALYSIS FILE AS TEXT TO FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME.......in file at which printout begins.\n");
		fprintf(stdout,"INFO: WINDOWCNT..number of windows to print.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Outfile is a textfile.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WARNING: using more than a few windows will generate a huge textfile.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_INFO):
		fprintf(stdout,"INFO: DISPLAY INFORMATION ABOUT PITCHDATA IN PITCHFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Finds mean pitch, max and min pitch (with timings), as Hz and MIDI.\n");
		fprintf(stdout,"INFO: And displays total range, in octaves and semitones.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_ZEROS):																	 
		fprintf(stdout,"INFO: SHOWS WHETHER PITCHFILE CONTAINS UNINTERPOLATED ZEROS (UNPITCHED WINDOWS).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_SEE):																	 
		fprintf(stdout,"INFO: CONVERT BINARY PITCHFILE OR TRANSPOSITION-FILE TO PSEUDO-SNDFILE, TO VIEW.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEE PITCH\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ........SCALE FACTOR multiplies pitch vals, for ease of viewing.\n");
		fprintf(stdout,"INFO: ........Pitch data scaled by (e.g.) 100 can be read directly from 'sndfile'\n");
		fprintf(stdout,"INFO: ........(Remembering to divide numeric values by 100).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEE TRANSPOSITION\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ........Transposition data is automatically scaled to half max range,\n");
		fprintf(stdout,"INFO: ........And displayed in log format\n");
		fprintf(stdout,"INFO: ........giving a schematic idea ONLY, of transposition data.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: View with a sndfile display program. DO NOT ATTEMPT TO PLAY FILE!!\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_HEAR):
		fprintf(stdout,"INFO: CONVERT BINARY PITCHFILE TO ANALYSIS TESTTONE FILE.\n");
		fprintf(stdout,"INFO: (RESYNTHESISE TO HEAR PITCH).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_WRITE):
		fprintf(stdout,"INFO: CONVERT A BINARY PITCH-DATAFILE TO A TIME/FRQ BRKPNT TEXTFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DATA REDUCTION acceptable pitch error in brkpntfile data-reduction.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT):
		fprintf(stdout,"INFO: MODIFY SHAPE OF 'WAVECYCLES'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_ENV):
		fprintf(stdout,"INFO: IMPOSE ENVELOPE OVER EACH GROUP OF cyclecnt 'WAVECYCLES'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE-GROUP COUNT....is number of wavecycles under a single envelope.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RISE-DECAY EXPONENT..is exponent for envelope rise or decay:\n");
		fprintf(stdout,"INFO: .....................If OMMITED envelope rise/decay is linear.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TROUGHING............is trough of envelope (0-1: default 0).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: in USER-DEFINED MODE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is a textfile of time/val(0-1) pairs defining an envelope,\n");
		fprintf(stdout,"INFO: where time units are arbitrary\n");
		fprintf(stdout,"INFO: as the envelope is stretched to each cycle(set) duration.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_AVG):
		fprintf(stdout,"INFO: AVERAGE THE WAVESHAPE OVER N 'WAVECYCLES'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE-GROUP COUNT..is number of cycles to average over ( > 1)\n");
		fprintf(stdout,"INFO: MAX WAVELEN........max permissible wavelength in seconds.\n");
		fprintf(stdout,"INFO: SKIPCYCLES:........number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_OMT):
		fprintf(stdout,"INFO: OMIT A OUT OF EVERY B 'WAVECYCLES' REPLACING THEM BY SILENCE\n");
		fprintf(stdout,"INFO: B van vary in time, but cannot be > A (!)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_MLT):
		fprintf(stdout,"INFO: DISTORTION BY MULTIPLYING WAVECYCLE FREQUENCY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: try SMOOTHED flag if glitches appear.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_DIV):
		fprintf(stdout,"INFO: DISTORTION BY DIVIDING WAVECYCLE FREQUENCY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: N = divider (integer only: range 2-16)\n");
		fprintf(stdout,"INFO: INTERPOLATED........slower, but cleaner.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_HRM):
		fprintf(stdout,"INFO: HARMONIC DISTORTION BY SUPERIMPOSING 'HARMONICS' ONTO 'WAVECYCLES'.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is a textfile containing harmonic_no/amplitude pairs.\n");
		fprintf(stdout,"INFO: where amplitude of src sound is taken to be 1.0\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PRE_ATTENUATION.....is applied to input sound before processing.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_FRC):
		fprintf(stdout,"INFO: SUPERIMPOSE MINIATURE COPIES OF SRC 'WAVECYCLES' ONTO THEMSELVES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SCALING FACTOR.....(integer) division of scale of src wave.\n");
		fprintf(stdout,"INFO: RELATIVE LOUDNESS..loudness of scaled component, relative to src (1.0).\n");
		fprintf(stdout,"INFO: PRE_ATTENUATION....applied to input sound before processing.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_REV):
		fprintf(stdout,"INFO: CYCLE_REVERSAL DISTORTION.'WAVECYCLES' REVERSED IN GROUPS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE-GROUP COUNT...Number of cycles (>0) in reversed groups.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_SHUF):
		fprintf(stdout,"INFO: DISTORTION BY SHUFFLING 'WAVECYCLES'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is 2 strings of letters, separated by a '-'  or ':'\n");
		fprintf(stdout,"INFO: The first string is the DOMAIN, and the 2nd, the IMAGE.\n");
		fprintf(stdout,"INFO: e.g. 'abc-abbabcc'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DOMAIN.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Letters represent group of consecutive wavecycles.\n");
		fprintf(stdout,"INFO: e.g. 'abcd'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IMAGE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: any permutation of, or selection from, the domain letters.\n");
		fprintf(stdout,"INFO: (domain letters may be omitted or repeated in the image string).\n");
		fprintf(stdout,"INFO: e.g. 'aaaaaaadaaa'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE-GROUP COUNT..(integer) number of wavecycles in groups to operate on.\n");
		fprintf(stdout,"INFO: SKIP CYCLES .......(integer) number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_RPT):
		fprintf(stdout,"INFO: TIMESTRETCH FILE BY REPEATING 'WAVECYCLES'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MULTIPLIER:..........(integer) number of times each wavecycle(grp) repeats.\n");
		fprintf(stdout,"INFO: CYCLE-GROUP COUNT:...(integer) number wavecycles in repeated groups.\n");
		fprintf(stdout,"INFO: SKIP CYCLES:.........(integer) number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_RPT2):
		fprintf(stdout,"INFO: REPEAT 'WAVECYCLES' THEN SKIP CYCLES  TO AVOID TIMESTRETCHING FILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MULTIPLIER:..........(integer) number of times each wavecycle(grp) repeats.\n");
		fprintf(stdout,"INFO: CYCLE-GROUP COUNT:...(integer) number wavecycles in repeated groups.\n");
		fprintf(stdout,"INFO: SKIP CYCLES:.........(integer) number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_RPTFL):
		fprintf(stdout,"INFO: TIMESTRETCH FILE BY REPEATING 'WAVECYCLES' ABOVE A CERTAIN WAVELENGTH\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MULTIPLIER:..........(integer) number of times each wavecycle(grp) repeats.\n");
		fprintf(stdout,"INFO: CYCLE-GROUP COUNT:...(integer) number wavecycles in repeated groups.\n");
		fprintf(stdout,"INFO: SKIP CYCLES:.........(integer) number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: HIGH FRQ LIMIT:.......Frequency below which wavecycles are counted.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_INTP):
		fprintf(stdout,"INFO: TIMESTRETCH FILE BY REPEATING 'WAVECYCLES' & INTERPOLATING BETWEEN THEM.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MULTIPLIER: (integer) is number of times each wavecycle repeats.\n");
		fprintf(stdout,"INFO: SKIPCYCLES: (integer) is number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_DEL):
		fprintf(stdout,"INFO: TIMECONTRACT FILE BY DELETING 'WAVECYCLES'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
 		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IN GIVEN ORDER:..1 in CYCLECNT wavecycle(group)s retained\n");
		fprintf(stdout,"INFO: RETAIN LOUDEST:..Strongest 1 in CYCLECNT wavecycle(group)s retained\n");
		fprintf(stdout,"INFO: DELETE WEAKEST:..Weakest   1 in CYCLECNT wavecycle(group)s deleted\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE-GROUP COUNT..(integer) number of wavecycles in deleted groups.\n");
		fprintf(stdout,"INFO: SKIPCYCLES:........(integer) number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_RPL):
		fprintf(stdout,"INFO: STRONGEST WAVECYCLE, IN EACH WAVECYCLE GROUP, REPLACES OTHERS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE-GROUP COUNT..(integer) number of wavecycles in group of replacements.\n");
		fprintf(stdout,"INFO: SKIP CYCLES........(integer) number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_TEL):
		fprintf(stdout,"INFO: TIMECONTRACT SOUND BY TELESCOPING cyclecnt 'WAVECYCLES' TO 1\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE-GROUP COUNT....sizeof group to telescope.\n");
		fprintf(stdout,"INFO: SKIP CYCLES..........(integer) number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: TO AVERAGE CYCLELEN..telescopes to average cyclelen in group.(Default: telescope to longest.)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_FLT):
		fprintf(stdout,"INFO: TIMECONTRACT SOUND BY FILTERING OUT 'WAVECYCLES'\n");
		fprintf(stdout,"INFO: EXCLUDED BY FRQ LIMITS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SKIP CYCLES.....(integer) number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: N.B. timevarying freq1, freq2 may not cross each other, nor be equal.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_INT):
		fprintf(stdout,"INFO: TIME-DOMAIN INTERACTION OF SOUNDS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES-------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INTERLEAVE..wavecycles from the two infiles are interleaved.\n");
		fprintf(stdout,"INFO: RESIZE......wavecycle-lengths of 1st file are imposed on wavecycles of 2nd\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_CYCLECNT):
		fprintf(stdout,"INFO: COUNT 'WAVECYCLES' IN SNDFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_PCH):
		fprintf(stdout,"INFO: PITCHWARP 'WAVECYCLES' OF SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SKIP CYCLES....(integer) number of wavecycles to skip at start of file\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_OVERLOAD):
		fprintf(stdout,"INFO: CLIP THE SOUND AND ADD DISTORTION WAVEFORM OVER THE CLIPPED PORTIONS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES-------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NOISE.........peaks of signal replaced by noise.\n");
		fprintf(stdout,"INFO: WAVEFORM......peaks of signal replaced by signal of given frequency.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GATE LEVEL WHERE SIGNAL IS CLIPPED....level at which signal is clipped\n");
		fprintf(stdout,"INFO: DEPTH OF DISTORTION GLAZE....depth of distortion pattern imposed on clipped portions.\n");
		fprintf(stdout,"INFO: FREQUENCY OF DISTORT SIGNAL...(mode WAVEFORM only) frequency of distortion signal.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DISTORT_PULSED):
		fprintf(stdout,"INFO: IMPOSE AN IMPULSE STREAM OVER INPUT SOUND, OR OVER A CYCLING SEGMENT OF THAT SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES-------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IMPOSE....impose impulse stream on the input sound.\n");
		fprintf(stdout,"INFO: SYNTH......select a specified duration of wavecycles from the input src, at a specified time,\n");
		fprintf(stdout,"INFO:                  and use as a looped sound source on which the impulses are imposed.\n");
		fprintf(stdout,"INFO: SYNTH2.....the same, but specify starttime as a samplecnt,\n");
		fprintf(stdout,"INFO:                  and select a specified NUMBER of wavecycles.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS-------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IMPULSE ENVELOPE......... ...a breakpoint file describing the envelope shape of the impulse.\n");
		fprintf(stdout,"INFO:             whatever time units used will be scaled to the duration of the impulses.\n");
		fprintf(stdout,"INFO: PULSE STREAM START-TIME IN SRC SOUND ...time in src sound where impulses begin.\n");
		fprintf(stdout,"INFO: DURATION OF IMPULSE STREAM.............time for which impulses persist.\n");
		fprintf(stdout,"INFO: FREQUENCY OF IMPULSES (HZ).............frequency of the impulses\n");
		fprintf(stdout,"INFO: RANDOMISATION OF FREQUENCY OF IMPULSES........max amount of semitone wander.\n");
		fprintf(stdout,"INFO:         of the impulse are randomised, from impulse to impulse.\n");
		fprintf(stdout,"INFO: RANDOMISATION OF TIME CONTOUR OF AN IMPULSE........time-positions of amplitude peaks & troughs\n");
		fprintf(stdout,"INFO:         of the impulse are randomised, from impulse to impulse.\n");
		fprintf(stdout,"INFO: RANDOMISATION_OF_AMPLITUDE_CONTOUR_OF_AN_IMPULSE....shape created by amplitude peaks & troughs\n");
		fprintf(stdout,"INFO:         of the impulse is randomised, from impulse to impulse.\n");
		fprintf(stdout,"INFO: DURATION (or NUMBER) OF WAVECYCLES TO GRAB AS SOUND SRC INSIDE IMPULSES......(SYNTHESIS MODES ONLY)\n");
		fprintf(stdout,"INFO:         at the specified starttime, wavecycles are chosen from src sound,\n");
		fprintf(stdout,"INFO:         and used as the 'waveform' on which the impulses are imposed\n");
		fprintf(stdout,"INFO: SEMITONE TRANSPOSITION CONTOUR OF SOUND INSIDE EACH IMPULSE.....\n");
		fprintf(stdout,"INFO:         within each impulse, the sound material is pitchwarped, using the semitone contour defined here.\n");
		fprintf(stdout,"INFO: MAX SEMITONE RANGE OF RANDOMISATION OF TRANSPOSITION CONTOUR............\n");
		fprintf(stdout,"INFO:         within each impulse, the transposition contour is itself randomised, from impulse to impulse.\n");
		fprintf(stdout,"INFO: KEEP START OF SRC BEFORE IMPULSES BEGIN ... if impulses begin at a time beyond start of src sound,\n");
		fprintf(stdout,"INFO:          the opening unpulsed segment of the sound is retained in the output.\n");
		fprintf(stdout,"INFO: KEEP END OF SRC AFTER IMPULSES FINISH ... if impulses end at a time before end of src sound,\n");
		fprintf(stdout,"INFO:          the closing unpulsed segment of the sound is retained in the output.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Works on MONO files only\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ZIGZAG):
		fprintf(stdout,"INFO: READ BACK AND FORTH INSIDE SOUNDFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In mode USER SPECIFIED\n");
		fprintf(stdout,"INFO: Required data is textfile containing sequence of times to zigzag between.\n");
		fprintf(stdout,"INFO: Each step-between-times must be > (3 * splicelen).\n");
		fprintf(stdout,"INFO: Successive zigsteps moving in same (time-)direction are concatenated.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RANDOM SEED..a number to generate a replicable random sequence. (>0)\n");
		fprintf(stdout,"INFO: .............enter same number on next program run, to get same outfile.\n");
		fprintf(stdout,"INFO: .............(Default: (0) random sequence is different every time).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(LOOP):
		fprintf(stdout,"INFO: LOOP INSIDE SOUNDFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEARCHFIELD........makes step advance irregular, within timeframe of SEARCHFIELD.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FROM INFILE START..flag forces outfile to play from beginning of infile\n");
		fprintf(stdout,"INFO: ...................(even if looping doesn't begin there).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SCRAMBLE):
		fprintf(stdout,"INFO: SCRAMBLE THE SOUND BY CUTTING RANDOMLY AND REORGANISING CUT CHUNKS RANDOMLY\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: COMPLETELY RANDOM........Random chunks cut from file, and spliced end to end.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SCRAMBLE SRC:THEN AGAIN..Whole file is cut into random chunks, and these rearranged\n");
		fprintf(stdout,"INFO: .........................then this process is repeated differently.. and again..etc\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN CHUNKLEN.........minimum chunklen to cut.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX CHUNKLEN.........maximum chunklen to cut.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHUNK LENGTH.........average chunklen to cut.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SCATTER COEFFICIENT..Randomisation of chunk lengths.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEED VALUE...........same seed-number producea identical output on rerun\n");
		fprintf(stdout,"INFO: .....................(Default: (0) random sequence is different every time).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RUN FROM SND START:..wherever first randomly located chunk is\n");
		fprintf(stdout,"INFO: .....................outfile plays up to its start before scrambling.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RUN TO SND END:......wherever last randomly located chunk is\n");
		fprintf(stdout,"INFO: .....................outfile plays on to end of src sound.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ITERATE):
		fprintf(stdout,"INFO: ITERATE AN INPUT SOUND IN A FLUID MANNER\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ****  WARNING: Do NOT use with large files. ****\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DELAY..................(average) delay between iterations. Default:infile dur.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCH SCATTER..........max of random pitchshift of each iteration: semitones\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AMPLITUDE SCATTER......max of random amp-reduction on each iteration.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PROGRESSIVE FADE.......(average) amplitude fade beween iterations.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OVERALL GAIN...........(special) value 0, gives best guess for no distortion.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEED RANDOM GENERATOR..same number produces identical output on rerun,\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ITERATE_EXTEND):
		fprintf(stdout,"INFO: EXTEND A SOUND BY FREEZING A SPECIFIED PART OF IT, BY FLUID ITERATION\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ****  WARNING: Do NOT use with large files. ****\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)    Specify (minimum) duration of output.\n");     
		fprintf(stdout,"INFO: 2)    Specify number of repetitions in extended segment.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME WHEN ITERATED SEGMENT ENDS\n");
		fprintf(stdout,"INFO:       if there is portion of original sound beyond the segment to be extended,\n");
		fprintf(stdout,"INFO:       output duration will be greater than this parameter value.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DELAY..................(average) delay between iterations. Default:infile dur.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCH SCATTER..........max of random pitchshift of each iteration: semitones\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AMPLITUDE SCATTER......max of random amp-reduction on each iteration.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START OF TIME FREEZE...time at which freezing iteration begins.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: END OF TIME FREEZE.....time at which freezing iteration ends.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GAIN OF FROZEN SEGMENT.....multiplies output level of frozen segment.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEED RANDOM GENERATOR..same number produces identical output on rerun,\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DRUNKWALK):
		fprintf(stdout,"INFO: DRUNKEN-WALK THROUGH INPUT SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In mode SOBER MOMENTS input sound is read soberly at holds.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOCUS............Time in src around which drunkwalk happens(secs) CAN MOVE THRO SRC\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AMBITUS..........(half)width of region from within which sound-segments read.(secs)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STEP.............Max length of (random) step between segment-reads.\n");
		fprintf(stdout,"INFO: .................(always WITHIN ambitus: automatically adjusted where too large)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CLOCKTICK........Time between segment reads = (average) segment duration.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEGMENT OVERLAY..Mutual overlap of segments in output.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEED VALUE...... Any set value gives reproducible output.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(EQ):
		fprintf(stdout,"INFO: CUT OR BOOST, ABOVE, BELOW OR AROUND A GIVEN FRQ\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BWIDTH.... filter bandwidth in Hz\n");
		fprintf(stdout,"INFO: BOOST/CUT..is the boost or cut, in dB\n");
		fprintf(stdout,"INFO: FREQ.......is the filter frequency in Hz\n");
		fprintf(stdout,"INFO: PRESCALE...scales the INPUT to the filter.\n");
		fprintf(stdout,"INFO: DECAY TAIL...time allowed for filter resonance to decay,once source sound has finished.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(LPHP):
		fprintf(stdout,"INFO: FIXED LOW PASS OR HIGH PASS FILTER.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ATTENUATION..Gain reduction of filter, in dB.\n");
		fprintf(stdout,"INFO: .............Greater attenuation, sharper filter, but longer to calculate.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PASS-BAND....last pitch to be passed by the filter.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STOP-BAND....first pitch to be stopped by the filter.\n");
		fprintf(stdout,"INFO: .............If stop-band is above pass-band, this is a lopass filter.\n");
		fprintf(stdout,"INFO: .............If stop-band is below pass-band, this is a hipass filter.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PRESCALE.....Prescale input level: Avoid overflows.\n");
		fprintf(stdout,"INFO: DECAY TAIL...time allowed for filter resonance to decay,once source sound has finished.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FSTATVAR):
		fprintf(stdout,"INFO: LOPASS, HIGH-PASS, BANDPASS, OR NOTCH FILTER WITH VARIABLE FRQ\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ACUITY.....acuity of filter: Smaller vals give tighter filter.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GAIN.......overall gain on output:  Rule of thumb:\n");
		fprintf(stdout,"INFO: ...........if acuity = (1/3)to-power-n: gain = (2/3)-to-power-n\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FREQUENCY..frq of filter\n");
		fprintf(stdout,"INFO: DECAY TAIL...time allowed for filter resonance to decay,once source sound has finished.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FLTBANKN):
		fprintf(stdout,"INFO: BANK OF FILTERS, WITH TIME-VARIABLE Q\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Q..................Q (tightness) of filters.\n");
		fprintf(stdout,"INFO: GAIN...............overall gain.\n");
		fprintf(stdout,"INFO: LOW FRQ............lofrq limit of filter bank.\n");
		fprintf(stdout,"INFO: HIGH FRQ...........hifrq limit of filter bank.\n");
		fprintf(stdout,"INFO: FRQ RANDOMISATION..Random scatter of filter frqs.\n");
		fprintf(stdout,"INFO: DECAY TAIL...time allowed for filter resonance to decay,once source sound has finished.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FLTBANKC):
		fprintf(stdout,"INFO: GENERATE A LIST OF FREQUENCIES FOR USE AS A FILTERBANK\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You can add your own amplitudes to the textfile & use if with USERBANK\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW FRQ............lofrq limit of filter bank.\n");
		fprintf(stdout,"INFO: HIGH FRQ...........hifrq limit of filter bank.\n");
		fprintf(stdout,"INFO: FRQ RANDOMISATION..Random scatter of filter frqs.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FLTBANKU):
		fprintf(stdout,"INFO: USER-DEFINED FILTERBANK,WITH TIME-VARIABLE Q\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BANDS AS FRQ (HZ):..Filter-pitches as frq in Hz.\n");
		fprintf(stdout,"INFO: BANDS AS MIDI:......Filter-pitches as MIDI values.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Filter data is a file with Pitch & Amp of filters\n");
		fprintf(stdout,"INFO: (paired, one pair on each line).\n");
		fprintf(stdout,"INFO: where amplitude may be expressed in decibels or as a +ve number,\n");
		fprintf(stdout,"INFO: and comment-lines (starting with ';') may be used.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Q:........Q (tightness) of filter\n");
		fprintf(stdout,"INFO: GAIN......overall gain on output.\n");
		fprintf(stdout,"INFO: DECAY TAIL...time allowed for filter resonance to decay,once source sound has finished.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FLTBANKV):
		fprintf(stdout,"INFO: USER-DEFINED TIME_VARYING FILTERBANK,WITH TIME-VARIABLE Q\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REQUIRED DATAFILE-------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: a textfile with lines of data for filter bands at successive times\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Each line contains the following items\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:           Time   Pitch1 Amp1   [Pitch2 Amp2    etc....].\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Where pitch and Amp values must be paired: and any number of pairs can be used in a line,\n");
		fprintf(stdout,"INFO: BUT each line must have SAME number of pairs on it.\n");
		fprintf(stdout,"INFO: (To eliminate a band in any line(s), set its amplitude to 0.0).\n");
		fprintf(stdout,"INFO: Time values (in secs) must be in ascending order (and >=0.0)\n");
		fprintf(stdout,"INFO: Pitch vals may be EITHER frq, OR MIDI, depending on Mode.\n");
		fprintf(stdout,"INFO: Amp values may be numeric, or dB values (e.g. -4.1dB).\n");
		fprintf(stdout,"INFO: and comment-lines may be used: start these with ';'.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Q....................Q (tightness) of filter.\n");
		fprintf(stdout,"INFO: GAIN.................overall gain.\n");
		fprintf(stdout,"INFO: NUMBER OF HARMONICS..No of harmonics (of each pitch) to use: Default 1.\n");
		fprintf(stdout,"INFO: .....................Very high harmonics of high pitches may be too high to calculate. (check with Max Harmonic button)\n");
		fprintf(stdout,"INFO: .....................No-of-pitches times no-of-harmonics determines program speed.\n");
		fprintf(stdout,"INFO: ROLL OFF.............Level drop (in dB) from one harmonic to next.\n");
		fprintf(stdout,"INFO: DECAY TAIL...........Time allowed for filter resonance to decay,once source sound has finished.\n");
		fprintf(stdout,"INFO: DOUBLE FILTERING.....More sharply defined filter frequencies.\n");
		fprintf(stdout,"INFO: DROP OUT ON OVERFLOW.The filter is designed to adjust its internal level to prevent numerical overflow from\n");
		fprintf(stdout,"INFO: .....................causing runaway distortion. If you are concerned to avoid any overflows at all,\n");
		fprintf(stdout,"INFO: .....................setting this flag will cause the filter to stop calculating if any overflow is detected.\n");
		fprintf(stdout,"INFO: .....................The filter gain can then be turned down, and the filter launched again.\n");
		break;
	case(FLTBANKV2):
		fprintf(stdout,"INFO: USER-DEFINED TIME_VARYING FILTERBANK,WITH TIME-VARIABLE Q AND PARTIALS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REQUIRED DATAFILE-------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: a textfile with lines of data for filter bands at successive times & for partials similarly\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FIRST set of lines contain the following items\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:           Time   Pitch1 Amp1   [Pitch2 Amp2    etc....].\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Where pitch and Amp values must be paired: and any number of pairs can be used in a line,\n");
		fprintf(stdout,"INFO: BUT each line must have SAME number of pairs on it.\n");
		fprintf(stdout,"INFO: (To eliminate a band in any line(s), set its amplitude to 0.0).\n");
		fprintf(stdout,"INFO: Time values (in secs) must be in ascending order (and >=0.0)\n");
		fprintf(stdout,"INFO: Pitch vals may be EITHER frq, OR MIDI, depending on Mode.\n");
		fprintf(stdout,"INFO: Amp values must be numeric.\n");
		fprintf(stdout,"INFO: and comment-lines may be used: start these with ';'.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: There must then be a SEPARATING LINE starting with a '#' sign\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SECOND set of lines contain the following items\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:           Time:   PartialNo1 Amp1   [PartialNo2 Amp2    etc....].\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Where partial numbers and Amp values must be paired: and any number of pairs can be used in a line,\n");
		fprintf(stdout,"INFO: BUT each line must have SAME number of pairs on it.\n");
		fprintf(stdout,"INFO: (To eliminate a band in any line(s), set its amplitude to 0.0).\n");
		fprintf(stdout,"INFO: Time values (in secs) must be in ascending order (and >=0.0)\n");
		fprintf(stdout,"INFO: Partial numbers can be fractional but must be >= 1.0\n");
		fprintf(stdout,"INFO: Amp values may be numeric.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The first time value in each line set MUST BE ZERO.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Q....................Q (tightness) of filter.\n");
		fprintf(stdout,"INFO: GAIN.................overall gain.\n");
		fprintf(stdout,"INFO: DECAY TAIL...........Time allowed for filter resonance to decay,once source sound has finished.\n");
		fprintf(stdout,"INFO: DOUBLE FILTERING.....More sharply defined filter frequencies.\n");
		break;
	case(FLTITER):
		fprintf(stdout,"INFO: ITERATE SOUND, WITH CUMULATIVE FILTERING BY A FILTERBANK.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is a textfile with Pitch & Amp of filters\n");
		fprintf(stdout,"INFO: (paired, one pair on each line).\n");
		fprintf(stdout,"INFO: Pitch, as Hz or MIDI.\n");
		fprintf(stdout,"INFO: Amp, can be entered as dB vals or numerically.\n" );
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Q.......................Q (tightness) of filter.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GAIN....................overrall gain in filtering process.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DELAY...................(average) delay between iterations (secs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTFILE DURATION........(min) duration of output file (>infile duration).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PRESCALE................gain on the INPUT to the filtering process.\n");
		fprintf(stdout,"INFO:.........................If 0.0, Program automatically divides input level by\n");
		fprintf(stdout,"INFO:.........................the max number of sound overlays occuring in process.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX PITCH SHIFT.........max pitchshift of any segment: (fractions of) semitones\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX LOUDNESS SHIFT......max amplitude reduction of any segment. (numeric)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCH NOT INTERPOLATED..during pitch shift: (fast but dirty).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXPONENTIAL DECAY...... each seg gets quieter before next enters.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NO NORMALISATION........segs may grow or fall in level quickly.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(FLTSWEEP):
		fprintf(stdout,"INFO: FILTER WHOSE FOCUS-FREQUENCY SWEEPS OVER A RANGE OF FREQUENCIES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ACUITY......Smaller vals give tighter filter.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GAIN........overall gain on output:   Rule of thumb:\n");
		fprintf(stdout,"INFO: ............if acuity = (1/3)to-power-n: gain = (2/3)-to-power-n\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOW FRQ.....lowest frq to sweep to.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: HIGH FRQ....highest frq to sweep to.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SWEEP FRQ...frq of the sweep itself.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PHASE.......start of sweep: Range(0-1)\n");
		fprintf(stdout,"INFO: ............e.g. to sweep once over range,\n");
		fprintf(stdout,"INFO: ............set sweepfrq to infiledur/2 (default)\n");
		fprintf(stdout,"INFO: ............and set phase to 0 (upsweep) or .5(downsweep)\n");
		fprintf(stdout,"INFO: DECAY TAIL...time allowed for filter resonance to decay,once source sound has finished.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ALLPASS):
		fprintf(stdout,"INFO: PHASESHIFT SOUND, OR PRODUCE 'PHASING' EFFECT\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GAIN................ In mode PHASING EFFECT,\n");
		fprintf(stdout,"INFO: .....................effect increases as gain increases from -1\n");
		fprintf(stdout,"INFO: .....................BUT a gain of 1.0 will produce complete phase cancellation\n");
		fprintf(stdout,"INFO: .....................and the output signal will be zero.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PRESCALE.............gain on the INPUT to the filtering process.\n");
		fprintf(stdout,"INFO: DECAY TAIL...........time allowed for filter resonance to decay,once source sound has finished.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LINEAR INTERP DELAY..(default: logarithmic interp of changing delay vals)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_COUNT):
		fprintf(stdout,"INFO: COUNT GRAINS FOUND IN A SOUND (AT GIVEN GATE & MINHOLE VALUES)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_OMIT):
		fprintf(stdout,"INFO: OMIT A PROPORTION OF GRAINS FROM GRAINY-SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GRAINS TO KEEP...... .number of grains to keep from each set of 'out_of' grains\n");
		fprintf(stdout,"INFO: ......................may vary over time, but must not exceed 'out_of'.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUT OF THIS MANY.....'keep' grains kept, from each 'out_of' grains set\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_DUPLICATE):
		fprintf(stdout,"INFO: DUPLICATE GRAINS IN GRAINY-SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL...........required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_REORDER):
		fprintf(stdout,"INFO: REORDER GRAINS IN GRAINY-SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is a string such as 'adb:c' or 'adb-c'\n");
		fprintf(stdout,"INFO: indicating how grains are to be reordered.\n");
		fprintf(stdout,"INFO: The example means use grains 1 (a), 4 (d) and 2 (b) in sequence,\n");
		fprintf(stdout,"INFO: then begin this grain-jumping pattern again, BUT start at grain3 (c):\n");
		fprintf(stdout,"INFO: Then continue to advance in this fashion until no grains left in infile.\n");
		fprintf(stdout,"INFO: The ':' (or '-') is obligatory.\n" );
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_REPITCH):
		fprintf(stdout,"INFO: REPITCH GRAINS IN GRAINY-SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NO GRAIN REPEATS..Lengthen or shorten each grain in turn, without repeating any grains:\n");
		fprintf(stdout,"INFO: ..................on reaching end of stretch list, cycle back to its start.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REPEAT EACH GRAIN Play grain at each new length, before proceeding to next grain.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is textfile listing transpositions as (+ve or -ve) semitone shifts.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_RERHYTHM):
		fprintf(stdout,"INFO: CHANGE RHYTHM OF GRAINS IN GRAINY-SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NO GRAIN REPEATS..Lengthen or shorten each grain in turn, without repeating any grains:\n");
		fprintf(stdout,"INFO: ..................on reaching end of stretch list, cycle back to its start.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REPEAT EACH GRAIN Play grain at each new length, before proceeding to next grain.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is a textfile listing duration-multipliers.\n");
		fprintf(stdout,"INFO: if any inter-grain time reduced below MINGRAINTIME\n");
		fprintf(stdout,"INFO: it will be set to MINGRAINTIME.\n" );
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_REMOTIF):
		fprintf(stdout,"INFO: CHANGE PITCH AND RHYTHM OF GRAINS IN GRAINY-SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NO GRAIN REPEATS..Lengthen or shorten each grain in turn, without repeating any grains:\n");
		fprintf(stdout,"INFO: ..................on reaching end of stretch list, cycle back to its start.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REPEAT EACH GRAIN Play grain at each new length, before proceeding to next grain.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is a textfile containing transposition-timemultiplier PAIRS.\n");
		fprintf(stdout,"INFO: Transpositions are (+ve or -ve) semitone shifts.\n");
		fprintf(stdout,"INFO: Time-multipliers change the grain duration.\n");
		fprintf(stdout,"INFO: if any inter-grain time reduced below MINGRAINTIME\n");
		fprintf(stdout,"INFO: it will be set to MINGRAINTIME.\n" );
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_TIMEWARP):
		fprintf(stdout,"INFO: STRETCH (OR SHRINK) DURATION OF GRAINY-SOUND\n");
		fprintf(stdout,"INFO: WITHOUT STRETCHING GRAINS THEMSELVES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIMESTRETCH-RATIO.....is degree of stretching/shrinking of intergrain time.\n");
		fprintf(stdout,"INFO: ......................a value of 2 doubles the intergrain time.\n");
		fprintf(stdout,"INFO: ......................a value of .5 halves the intergrain time.\n");
		fprintf(stdout,"INFO: ......................if any inter-grain time reduced below a certain MINGRAINTIME,\n");
		fprintf(stdout,"INFO: ......................it will be set to MINGRAINTIME.\n" );
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_REVERSE):
		fprintf(stdout,"INFO: REVERSE ORDER OF GRAINS IN A GRAINY-SOUND\n");
		fprintf(stdout,"INFO: WITHOUT REVERSING GRAINS THEMSELVES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_GET):
		fprintf(stdout,"INFO: LOCATE TIMINGS OF GRAIN-ONSETS IN A GRAINY-SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUT-TEXTFILE will contain a list of grain-onset timings, in seconds.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_POSITION):
		fprintf(stdout,"INFO: REPOSITION GRAIN-ONSETS IN A GRAINY-SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is a textfile containing a list of grain-onset timings, in seconds.\n");
		fprintf(stdout,"INFO: (Which might be obtained with GRAIN GET)\n");
		fprintf(stdout,"INFO: if any inter-grain time reduced below MINGRAINTIME\n");
		fprintf(stdout,"INFO: it will be set to MINGRAINTIME.\n" );
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GRAINTIME OFFSET......added to ALL grain timings.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME....min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE..track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: ......................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GRAIN_ALIGN):
		fprintf(stdout,"INFO: SYNCHRONISE GRAIN-ONSETS IN 2nd GRAINY-SOUND\n");
		fprintf(stdout,"INFO: WITH THOSE IN THE 1st.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1st infile provides grain-onset times.\n");
		fprintf(stdout,"INFO: 2nd infile provides the actual grains to be retimed.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GRAINTIME OFFSET.........added to ALL output grain timings.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX TIME BETWEEN GRAINS..if program sends a warning that it has found grain too large for buffer.\n");
		fprintf(stdout,"INFO:                                                   increase this value until no warning is sent.\n");
		fprintf(stdout,"INFO: GATE LEVEL...............required signal level for grain to be seen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GATE LEVEL FOR 2nd FILE..is separate gate for file 2.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GRAIN-OFF TIME.......min duration of inter-grain holes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW-SIZE.....track signal level, with this windowsize (secs)\n");
		fprintf(stdout,"INFO: .........................0 value turns off tracking.\n");
		fprintf(stdout,"INFO: \n");					 
		break;
	case(MIX):
		fprintf(stdout,"INFO: MIX SOUNDS AS INSTRUCTED IN A MIXFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIXING STARTTIME...starttime in mix (to start mixing later than zero).\n");
		fprintf(stdout,"INFO: MIXING ENDTIME.....endtime in mix (to stop mix before its true end).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Note that the START and END params intended for mix TESTING purposes only.\n");
		fprintf(stdout,"INFO: If you want to keep output from such a testmix, you should TOPNTAIL it.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ATTENUATION.......reduce the mix level, if necessary.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ALTERNATIVE MIX....slower,but may avoid clipping in special circumstances.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXTEST):
		fprintf(stdout,"INFO: TEST THE SYNTAX OF A MIXFILE\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXMAX):
		fprintf(stdout,"INFO: TEST THE MAXIMUM LEVEL OF A MIX, DEFINED IN A MIXFILE\n");
		fprintf(stdout,"INFO: AND SUGGEST A GAIN FACTOR TO AVOID OVERLOAD, IF NECESSARY\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIXING STARTTIME..starttime in mix (to start mixing later than zero).\n");
		fprintf(stdout,"INFO: MIXING ENDTIME....endtime in mix (to stop mix before its true end).\n");
		fprintf(stdout,"INFO: OUTTEXTFILE.......stores clipping locations (& maxlevel, in mode MAXLEVEL & CLIPTIMES).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You can alter the overall level of a mix with 'SUBMIX ATTENUATE'.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXFORMAT):
		fprintf(stdout,"INFO: MIXFILES CONSIST OF LINES WITH ONE OF THE FOLLOWING FORMATS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: sndname   starttime_in_mix    chans     level\n");
		fprintf(stdout,"INFO: sndname   starttime_in_mix    1         level        pan\n");
		fprintf(stdout,"INFO: sndname   starttime_in_mix    2         leftlevel    leftpan    rightlevel    rightpan\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SNDNAME....name of MONO or STEREO sndfile: ALL MUST HAVE SAME SAMPLING RATE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHANS......number of channels in this soundfile (1 or 2 ONLY)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LEVEL......loudness, as number (1 = unity gain) or dB (0dB = unity gain)\n" );
		fprintf(stdout,"INFO: ...........Mono & stereo files MAY have SINGLE level param (NO pan data).\n");
		fprintf(stdout,"INFO: ...........In this case, MONO files in STEREO mixes are panned centrally.\n");
		fprintf(stdout,"INFO: ...........OTHERWISE....\n");
		fprintf(stdout,"INFO: ...........MONO files   MUST have 1 level & 1 pan parameter (ONLY).\n");
		fprintf(stdout,"INFO: ...........STEREO files MUST have 2 level & 2 pan params(1 for each channel)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PAN........is spatial positioning of file (or file channel) in output mix.\n");
		fprintf(stdout,"INFO: ...........-1 Hard Left : 0 Centre : 1 Hard Right\n");
		fprintf(stdout,"INFO: ...........< -1 hard left & attenuated : > 1 hard right & attenuated.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ALSO\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  The mixfile list need NOT be in starttime order.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 2)  Silence at start of mix IGNORED.(splice on afterwards if needed).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 3)  With exclusively mono inputs, with NO pan information, OR \n");
		fprintf(stdout,"INFO:        when ALL panned hard left, or ALL hard right, output is MONO.\n");
		fprintf(stdout,"INFO:        All other situations produce stereo output.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TAKE CARE WHEN PANNING BOTH CHANNELS OF A STEREO FILE.\n");
		fprintf(stdout,"INFO: 4)  The channel contributions sum, so e.g. if both channels are\n");
		fprintf(stdout,"INFO:        panned to same position without attenuation, overload possible.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 5)  You may test for max level in your mix output with SUBMIX GETLEVEL.\n");
		fprintf(stdout,"INFO:        Reduce the mixfile level, if necessary, using SUBMIX ATTENUATE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 6)  You may put comment lines in mixfiles : Start such line with a ';'\n");
		fprintf(stdout,"INFO:       Blank lines are ignored.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXDUMMY):
		fprintf(stdout,"INFO: CONVERT A LIST OF SNDFILES INTO A BASIC MIXFILE (FOR EDITING)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIX_ON_GRID):
		fprintf(stdout,"INFO: CONVERT A LIST OF SNDFILES INTO A BASIC MIXFILE (FOR EDITING) ON A GRID OF TIMES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIX GRID .... is a list of times (in ascending order) at which sounds are to be placed.\n");
		fprintf(stdout,"INFO: ................ OR a list where times-to-be-used are marked by 'x' (before time, with no space)\n");
		fprintf(stdout,"INFO: ................ to indicate which grid points are to be used for successive input sounds.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ................ The number of (marked) times must be equal to the number of input sounds.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ................ Times may be followed (on the same line only) by comments e.g. grid numbering.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(AUTOMIX):
		fprintf(stdout,"INFO: MIX SEVERAL MONO OR STEREO FILES USING A TIME-CHANGING BALANCE-FUNCTION\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIX BALANCE FUNCTION .... is a list of value sets.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: .....Each set consists of a time, followed by the RELATIVE level of each file in the mix, at that time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: .....The values WITHIN A LINE are used to set the RELATIVE levels of the sounds at that time.\n");
		fprintf(stdout,"INFO: .....Whatever set of numbers you use, THESE ARE SCALED so the total set of levels used adds up to 1.0.\n");
		fprintf(stdout,"INFO: .....(This means that if all signals are at max level, the output will never exceed max level:\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: .....YOU CANNOT USE THIS DATA TO VARY THE OVERALL LEVEL FROM LINE TO LINE.\n");
		fprintf(stdout,"INFO: .....and, in particular, the values cannot ALL be zero.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: .....(Apply an envelope function (with ENVEL) to change the overall level of the mix output sound).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIX ENVELOPE FUNCTION ....Defines (possibly time-varying) gain to be apply to output AFTER BALANCING.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXTWARP):
		fprintf(stdout,"INFO: TIMEWARP THE DATA IN A MIXFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START LINE...mixfile-line at which warping begins (default: 1st in file)\n");
		fprintf(stdout,"INFO: END LINE.....mixfile-line at which warping ends  (default: last in file).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SORT ENTRY TIMES              sorts mixfile so lines are in time-order of entry.\n");
		fprintf(stdout,"INFO: REVERSE TIMING PATTERN:  e.g. rit. of sound entries becomes an accel.\n");
		fprintf(stdout,"INFO: REVERSE TIMING & NAMES  e.g. rit starting from file A to file Z becomes accel from file Z to A.\n");
		fprintf(stdout,"INFO: FREEZE TIMEGAPS               all timegap between sound entries become same as FIRST timegap.\n");
		fprintf(stdout,"INFO: FREEZE TIMEGAPS & NAMES  ditto, and all files take firstfile name.\n");
		fprintf(stdout,"INFO: SCATTER ENTRY TIMES         in intervals between original entry times. SCATTER is degree of scattering, from none to max, Range(0-1).\n");
		fprintf(stdout,"INFO: SHUFFLE UP ENTRY TIMES   shuffle times in file forward by time DISPLACEMENT secs (e.g from a specified line).\n");
		fprintf(stdout,"INFO: ADD TO TIMEGAPS                 add fixed val PARAMETER secs, to timegaps between sounds.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: THE CREATE & ENLARGE MODES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If the parameter value is X, then\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CREATE FIXED TIMEGAPS 1..between all sounds,timegap = X secs\n");
		fprintf(stdout,"INFO: CREATE FIXED TIMEGAPS 2..startval+X,startval+2X etc\n");
		fprintf(stdout,"INFO: CREATE FIXED TIMEGAPS 3..startval*X startval*2X etc\n");
		fprintf(stdout,"INFO: CREATE FIXED TIMEGAPS 4..startval*X     startval*X*X    etc\n");
		fprintf(stdout,"INFO: ENLARGE TIMEGAPS 1.......multiply them by X.\n");
		fprintf(stdout,"INFO: ENLARGE TIMEGAPS 2.......by +X, +2X,+3X  etc\n");
		fprintf(stdout,"INFO: ENLARGE TIMEGAPS 3.......by *X *2X *3X\n");
		fprintf(stdout,"INFO: ENLARGE TIMEGAPS 4.......by *X, *X*X, *X*X*X  etc. (CARE!!)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXSHUFL):
		fprintf(stdout,"INFO: SHUFFLE THE DATA IN A MIXFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) DUPLICATE LINES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 2) REVERSE ORDER FILENAMES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 3) SCATTER ORDER FILENAMES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 4) FIRST FILENAME TO ALL.....and hence first sound in all lines.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 5) OMIT LINES................(closing up timegaps appropriately).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 6) OMIT ALTERNATE LINES......(closing up timegaps appropriately).\n");
		fprintf(stdout,"INFO: .............................In modes 5 & 6 mix must be in correct time-order.\n");
		fprintf(stdout,"INFO: .............................mixfiles can be time-ordered using timewarp mode 1\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) DUPL LINES, NEW FILENAME..duplicate each line with new sound, newname.\n");
		fprintf(stdout,"INFO: .............................Program checks 'newname' is compatible sndfile,BUT\n");
		fprintf(stdout,"INFO: .............................NO SNDNAME CHECK turns OFF this checking.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START LINE..line at which shuffling begins (default: 1st in file)\n");
		fprintf(stdout,"INFO: END LINE....line at which shuffling ends  (default: last in file).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXGAIN):
		fprintf(stdout,"INFO: ALTER THE OVERALL LEVEL OF A MIXFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START LINE..line at which attenuation begins (default: 1st in file)\n");
		fprintf(stdout,"INFO: END LINE....line at which attenuation ends  (default: last in file).\n");
		fprintf(stdout,"INFO: GAINVAL.....must be > 0.0\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You can test the overall level of a mix with 'SUBMIX GETLEVEL'\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXSWARP):
		fprintf(stdout,"INFO: ALTER THE SPATIAL DISTRIBUTION OF A MIXFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: THE FOLLOWING MODES ARE TO BE UNDERSTOOD THUS----------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SCATTER ALTERNATING..gives random positions but alternating\n");
		fprintf(stdout,"INFO: .....................to left/right of centre of spatial range specified.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TWIST WHOLE MIX......Invert stereo in alternate lines of mixfile.\n");
		fprintf(stdout,"INFO: .....................(Can be used to avoid clipping).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TWIST A LINE.........Invert stereo in specified line of mixfile.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START LINE...........line at which warping begins (default: 1st in file)\n");
		fprintf(stdout,"INFO: END LINE.............line at which warping ends  (default: last in file).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXSYNC):
		fprintf(stdout,"INFO: SYNCHRONISE SOUNDFILES IN A MIXFILE,\n");
		fprintf(stdout,"INFO: OR GENERATE SUCH A MIXFILE FROM A LIST OF SNDFILES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INTEXTFILE......is list of sndfiles OR an existing mixfile.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXSYNCATT):
		fprintf(stdout,"INFO: SYNCHRONISE ATTACKS OF SOUNDFILES, IN A MIXFILE,\n");
		fprintf(stdout,"INFO: OR GENERATE SUCH A MIXFILE FROM A LIST OF SNDFILES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Input file is a list of sndfiles OR an existing mixfile.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: With a sndfilelist (only), each sndname MAY be followed by 2 times,\n");
		fprintf(stdout,"INFO: which delimit the search area for the sound's attack.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WINDOW DIVIDER..is factor shortening window which scans for the attack.\n");
		fprintf(stdout,"INFO: ................It can be 2,4,8,16, or 32 ONLY.\n");
		fprintf(stdout,"INFO: POWER METHOD....finds peak-power segment, before locating its max sample.\n");
		fprintf(stdout,"INFO: ................Default: program looks purely for maxsample.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The program estimates output levels required to prevent clipping,\n");
		fprintf(stdout,"INFO: But estimate may be over-cautiously low: adjust with 'SUBMIX ATTENUATE'.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXTWO):
		fprintf(stdout,"INFO: QUICK MIX OF 2 SNDFILES (HAVING SAME NUMBER OF CHANNELS)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STAGGER FILE2 ENTRY..2nd file enters, 'stagger' secs after first.\n");
		fprintf(stdout,"INFO: SKIP INTO 2ND FILE...by 'skip' secs, before starting to mix.\n");
		fprintf(stdout,"INFO: AMPLITUDE SKEW.......1st sound has 'skew' times more gain than 2nd.\n");
		fprintf(stdout,"INFO: START MIX AT.........Start the mix at the time specified.\n");
		fprintf(stdout,"INFO: CUT OFF MIX AT.......Stop the mix at the time specified.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Both files are halved in level\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXMANY):
		fprintf(stdout,"INFO: QUICK MIX OF SEVERAL SNDFILES (HAVING SAME NUMBER OF CHANNELS)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXBALANCE):
		fprintf(stdout,"INFO: MIX BETWEEN 2 SNDFILES USING A BALANCE FUNCTION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BALANCE FUNCTION...Describes the relative level of the two sounds.\n");
		fprintf(stdout,"INFO: ............................File 1 level is multiplied by the balance value.\n");
		fprintf(stdout,"INFO: ............................File 2 level is multiplied by (1.0 minus the balance value).\n");
		fprintf(stdout,"INFO: START OF MIX....\n");
		fprintf(stdout,"INFO: END OF MIX......Use these to make just part of the mix.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXCROSS):
		fprintf(stdout,"INFO: QUICK CROSSFADE BETWEEN SNDFILES (WITH SAME NUMBER OF CHANNELS).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Crossfade is from sndfile1 towards sndfile2.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STAGGER FILE2 ENTRY..2nd file starts 'stagger' secs. after 1st.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CROSSFADE SKEW.......f 1, cosinusoidal-crossfade is normal.\n");
		fprintf(stdout,"INFO: .....................below 1, cosin-fade begins rapidly then slows.\n");
		fprintf(stdout,"INFO: .....................above 1, cosin-fade begins slowly, then speeds up.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: Stagger approximated in c. hundredths of a sec. For more precise stagger,\n" );
		fprintf(stdout,"INFO: splice silence to start of sndfile2 & use stagger 0 (or use SUBMIX MIX).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (Only spectral morphing will create true morph between 2 sounds).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXINTERL):
		fprintf(stdout,"INFO: INTERLEAVE MONO FILES TO MAKE MULTICHANNEL OUTFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: First sndfile goes to left channel of stereo, (or channel 1 of 4), etc.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIXINBETWEEN):
		fprintf(stdout,"INFO: GENERATE A SET OF SOUNDS IN-BETWEEN THE 2 INPUT SOUNDS\n");
		fprintf(stdout,"INFO: THROUGH WEIGHTED MIXES OF THE INPUT SOUNDS,\n");
		fprintf(stdout,"INFO: FROM MOSTLY SOUND1 TO MOSTLY SOUND2.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is your GENERIC name for the output sndfiles.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: New soundfiles will be called name001 name002 etc\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: AUTOMATIC......program generates amplitude ratios for the new sounds automatically\n");
		fprintf(stdout,"INFO: ...............and FILES BETWEEN is number of inbetween outfiles to produce.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIXING RATIOS..Mixing Ratios is a ratio, or a list of ratios in a textfile.\n");
		fprintf(stdout,"INFO: ...............These are the level of file2 RELATIVE to file 1,for each new outfile,\n");
		fprintf(stdout,"INFO: ...............as FRACTIONS (Range 0-1)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Ensure NONE of the files to be created already exists!!\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_CREATE):
		fprintf(stdout,"INFO: CREATE AN ENVELOPE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In mode BINARY OUTPUT....If you specify starttime > 0,\n");
		fprintf(stdout,"INFO: .........................envelope values from 0 to starttime hold your startlevel.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In mode TEXTFILE OUTPUT..File starts at time you specify.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required Data is a textfile with the following format:\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:            time [e]level time [e]level ......\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: where time-level pairs can be repeated as often as desired.\n");
		fprintf(stdout,"INFO: Level is a number between 0 and 1, or a dB value between -96 and 0\n");
		fprintf(stdout,"INFO: (you must write 'dB' if you want dB).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If preceded by an 'e', envelope rises[falls] exponentially to that level.\n");
		fprintf(stdout,"INFO: Default is linear rise[fall].\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Times are in seconds, must increase through the file,\n");
		fprintf(stdout,"INFO: and be separated by a minimum amount to accomodate splices\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_EXTRACT):
		fprintf(stdout,"INFO: EXTRACT ENVELOPE FROM AN INPUT SOUNDFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DATA REDUCTION determines quantity v. accuracy of data written to brkfile\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_PROPOR):
		fprintf(stdout,"INFO: IMPOSE ENVELOPE, PROPORTIONALLY, ON AN INPUT SOUNDFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE IN TEXTFILE (envelope level values 0 - 32767)\n");
		fprintf(stdout,"INFO:        the time values are scaled to run from time 0 to the duration of the soundfile.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_IMPOSE):
		fprintf(stdout,"INFO: IMPOSE AN ENVELOPE ON AN INPUT SOUNDFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ABOUT THE MODES----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENV FROM OTHER SNDFILE\n");
		fprintf(stdout,"INFO: ENV IN BINARY FILE......In these modes the whole sndfile is enveloped.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENV IN TEXTFILE\n");
		fprintf(stdout,"INFO: ENV IN DB TEXTFILE......In these modes, brkpnt may start (and end) at any time in file,\n");
		fprintf(stdout,"INFO: ........................effectively editing it. Must have at least 2 brkpnt pairs.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_REPLACE):
		fprintf(stdout,"INFO: REPLACE THE EXISTING ENVELOPE OF AN INPUT SOUNDFILE\n");
		fprintf(stdout,"INFO: WITH A DIFFERENT ENVELOPE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In all cases, the entire sndfile is enveloped\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Especially useful for restoring the amplitude contour of a sound\n");
		fprintf(stdout,"INFO: after filtering with time-varying Q-value.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_BRKTOENV):
		fprintf(stdout,"INFO: CONVERT A (TEXT) BRKPNT ENVELOPE TO A BINARY ENVELOPE FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If brkpnt starttime > zero, new envelope will start from zero,\n");
		fprintf(stdout,"INFO: holding the brktable startval as far as first brktable time.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_ENVTOBRK):
		fprintf(stdout,"INFO: CONVERT A BINARY ENVELOPE FILE TO A (TEXT) BRKPNT ENVELOPE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DATA REDUCTION determines quantity v. accuracy of data written to brkfile\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_ENVTODBBRK):
		fprintf(stdout,"INFO: CONVERT BINARY ENVELOPE FILE TO (TEXT) BRKPNT ENVELOPE WITH dB VALUES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DATA REDUCTION determines quantity v. accuracy of data written to brkfile\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_DOVETAILING):
		fprintf(stdout,"INFO: DOVETAIL SNDFILE BY ENVELOPING THE START AND END OF IT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STANDARD         linear or exponential fades\n");
		fprintf(stdout,"INFO: DOUBLE STRENGTH  doubly exponential fades\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INFADE-DUR.......is duration of start-of-file fade-in.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTFADE-DUR......is duration of end-of-file fade-out.\n");
		fprintf(stdout,"INFO: .................Infade-dur and Outfade-dur must not overlap each another.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INFADE LINEAR....sets start fade to be linear: (default: exponential fade).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTFADE LINEAR....sets end fade to be linear: (default: exponential fade).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME TYPE ........ 0 takes param values in SECONDS: (default)\n");
		fprintf(stdout,"INFO:                                    1 takes param values in SAMPLES:\n");
		fprintf(stdout,"INFO:                                    2 takes param values in GROUPED_SAMPLES:\n");
		fprintf(stdout,"INFO:                                    (e.g. in stereo, each sample-pair counts as 1 item)\n");
		fprintf(stdout,"INFO: \n");			 
		break;
	case(ENV_CURTAILING):
		fprintf(stdout,"INFO: CURTAIL SNDFILE BY FADING TO ZERO AT SOME TIME WITHIN IT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START AND END : Give start and end times of fade.\n");
		fprintf(stdout,"INFO: START AND DUR : Give start time of fade, and its duration.\n");
		fprintf(stdout,"INFO: START OF FADE TO END : Give start time of fade only (fade proceeds to end of file).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The other modes are similar, with more pronounced fades...\n");
		fprintf(stdout,"INFO: START AND END, DOUBLE STRENGTH\n");
		fprintf(stdout,"INFO: START AND DUR, DOUBLE STRENGTH\n");
		fprintf(stdout,"INFO: START OF FADE TO END, DOUBLE STRENGTH\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LINEAR FADE...sets fade to be linear: (default: exponential fade).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME TYPE ........ 0 takes param values in SECONDS: (default)\n");
		fprintf(stdout,"INFO:                                    1 takes param values in SAMPLES:\n");
		fprintf(stdout,"INFO:                                    2 takes param values in GROUPED_SAMPLES:\n");
		fprintf(stdout,"INFO:                                    (e.g. in stereo, each sample-pair counts as 1 item)\n");
		break;
	case(ENV_WARPING):
	case(ENV_RESHAPING):
	case(ENV_REPLOTTING):
		switch(process) {
		case(ENV_WARPING):
			fprintf(stdout,"INFO: MODIFY THE ENVELOPE OF A SOUNFILE\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(ENV_RESHAPING):
			fprintf(stdout,"INFO: MODIFY THE ENVELOPE OF A BINARY ENVELOPE FILE\n");
			fprintf(stdout,"INFO: \n");
			break;
		case(ENV_REPLOTTING):
			fprintf(stdout,"INFO: MODIFY THE ENVELOPE OF A (TEXT) BRKPNT ENVELOPE FILE\n");
			fprintf(stdout,"INFO: \n");
			break;
		}
		fprintf(stdout,"INFO: --------------------------- MODES ----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NORMALISE----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Expand envelope so that highest point has max possible value.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME-REVERSE-------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Reverse the timing of the envelope.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXAGGERATE---------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Exaggerate the envelope contour.\n");
		fprintf(stdout,"INFO: Exaggeration less than 1, Low envelope vals boosted\n");
		fprintf(stdout,"INFO: Exaggeration greater than 1, High envelope vals boosted.\n");
		fprintf(stdout,"INFO: Value 1, gives no change.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ATTENUATE----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Change level of envelope by the specified multiplier.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LIFT ALL-----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Lift entire envelope level by the specified amount.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME-STRETCH-------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Timestretch the envelope by the specified multiplier.\n");
		fprintf(stdout,"INFO: Note that a timestretch of less than 1 timeshrinks the envelope.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FLATTEN------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Flatten envelope contour.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GATE---------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Envelope values below the gate value are set to zero.\n");
		fprintf(stdout,"INFO: Smoothing zeroes low-level envelope chunks less than 'smoothing' windows long.\n");
		fprintf(stdout,"INFO: A value of zero turns off the smoothing effect.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INVERT-------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Levels below Gate-level are set to zero. All other levels,\n");
		fprintf(stdout,"INFO: above & below Mirror value, are inverted to other side of mirror.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LIMIT--------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Levels above Threshold value squeezed down so envelope maxamp becomes Limit.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CORRUGATE----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Take all troughs in the envelope to zero.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXPAND-------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Levels below Gate are set to zero. Other levels squeezed upwards\n");
		fprintf(stdout,"INFO: so minimum level becomes Threshold value.\n");
		fprintf(stdout,"INFO: Smoothing zeroes low-level envelope chunks less than 'smoothing' windows long.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TRIGGER BURSTS-----------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Create a new envelope of sudden on-bursts, from existing envelope,\n");
		fprintf(stdout,"INFO: triggered by the rate of rise of the current envelope.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Data file is a breakpoint envelope for the (triggered) bursts themselves.\n");
		fprintf(stdout,"INFO: To trigger, average-level must be greater than Gate level,\n");
		fprintf(stdout,"INFO: loudness-step must be greater than Min Trigger Level-rise,\n");
		fprintf(stdout,"INFO: and it must have duration less than Max Trigger Duration\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TO CEILING---------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Force envelope up to its maximum level, everywhere.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DUCKED-------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Create ducking envelope from existing envelope.\n");
		fprintf(stdout,"INFO: This can be used to create an envelope to apply to another sound\n");
		fprintf(stdout,"INFO: which is to be mixed with the original sound.\n");
		fprintf(stdout,"INFO: With Envelope WARPING:\n");
		fprintf(stdout,"INFO: When input envelope exceeds Threshold, output envelope is reduced\n");
		fprintf(stdout,"INFO: to Gate level. Elsewhere it is unchanged.\n");
		fprintf(stdout,"INFO: With Envelope RESHAPING or REPLOTTING:\n");
		fprintf(stdout,"INFO: When input envelope exceeds Threshold, output envelope takes\n");
		fprintf(stdout,"INFO: Gate level. Elsewhere it gives unity gain.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: COUNT PEAKS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Count peaks in the envelope.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_DBBRKTOENV):
		fprintf(stdout,"INFO: CONVERT (TEXT) BRKPNT FILE WITH dB VALS TO BINARY ENVELOPE FILE\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_DBBRKTOBRK):
		fprintf(stdout,"INFO: CONVERT (TEXT) BRKPNT FILE WITH dB VALS TO GAIN VALS (0-1)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_BRKTODBBRK):
		fprintf(stdout,"INFO: CONVERT A (TEXT) BRKPNT FILE WITH GAIN (0-1) VALS TO dB VALS\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_SWELL):
		fprintf(stdout,"INFO: CAUSE SOUND TO FADE IN TO AND OUT FROM A PEAK MOMENT\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LINEAR FADE causes fades in and out to be linear: (default exponential).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_ATTACK):
		fprintf(stdout,"INFO: EMPHASIZE THE ATTACK OF A SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GAIN................Amplification of attack point.\n");
		fprintf(stdout,"INFO: ....................For strong attack,\n");
		fprintf(stdout,"INFO: ....................reduce overall level of src before processing.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ATTACK ONSET DUR....Attack onset duration (MS).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ATTACK DECAY DUR....Attack decay duration (MS).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LINEAR SLOPES.......sets fades to be linear (default exponential).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: and in various MODES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GATE LEVEL..........Level for attack point to be recognised.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: APPROX ATTACK TIME..Approx time in sound of attack point,in secs.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXACT ATTACK TIME...Exact time in sound of attack point,in secs.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_PLUCK):
		fprintf(stdout,"INFO: PLUCK START OF SOUND (MONO FILES ONLY)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STARTSAMP..Sample, in src sound, at which pluck will END:\n");
		fprintf(stdout,"INFO: ...........must be a sample AT A ZERO_CROSSING...\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: WAVELEN....no of (absolute) samples in pluck wavelen: \n");
		fprintf(stdout,"INFO: ...........set to same as src_signal's wavelen immediately after STARTSAMP\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ATKCYCLES..no of wavecycles in pluck-attack.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DECAYRATE..rate of decay of the pluck_attack.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ENV_TREMOL):
		fprintf(stdout,"INFO: TREMOLO A SOUND\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FRQWISE....Interpolate linearly between frqs in any frq brktable (default).\n");
		fprintf(stdout,"INFO: PITCHWISE..Interpolate logarithmically (like pitch). (Care with zero frqs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TREMOLO FREQUENCY..is frequency of the tremolo vibration itself.\n");
		fprintf(stdout,"INFO: TREMOLO DEPTH......amplitude depth of tremolo.\n");
		fprintf(stdout,"INFO: OVERALL GAIN.......Overall signal gain, or envelope.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SIMPLE_TEX):
	case(GROUPS):
	case(DECORATED):
	case(PREDECOR):
	case(POSTDECOR):
	case(ORNATE):
	case(PREORNATE):
	case(POSTORNATE):
	case(MOTIFS):
	case(MOTIFSIN):
	case(TIMED):
	case(TGROUPS):
	case(TMOTIFS):
	case(TMOTIFSIN):
		fprintf(stdout,"INFO: TEXTURE MADE FROM ONE OR SEVERAL INPUT SOUND FILES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: TYPES OF TEXTURE--------------------------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Texture can be SIMPLE,GROUPED,DECORATED,PREDECORATED,POSTDECORATED,\n");
		fprintf(stdout,"INFO: ORNATE,PREORNATE,POSTORNATE, or made up of MOTIFS\n");
		fprintf(stdout,"INFO: OR\n");
		fprintf(stdout,"INFO: a texture where sound-entries are SPECIFICALLY TIMED\n");
		fprintf(stdout,"INFO: and either simple,grouped, or made from motifs.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ORNAMENTS & MOTIFS........have user-specified pitch-shapes.\n");
		fprintf(stdout,"INFO: DECORATIONS & GROUPS......have random pitch-shapes.\n");
		fprintf(stdout,"INFO: DECORATIONS & ORNAMENTS...decorate the user-specified pitch-sequence.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: HARMONIC TYPES OF TEXTURE------------------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Textures are specified WITHIN A (possibly varying) RANGE OF PITCHES\n");
		fprintf(stdout,"INFO: and within that range, the chosen pitches may be\n");
		fprintf(stdout,"INFO: entirely RANDOM, on a HARMONIC SET (using pitches given),\n");
		fprintf(stdout,"INFO: on a HARMONIC FIELD (uses 8va transpositions of pitches given),\n");
		fprintf(stdout,"INFO: or on HARMONIC SETS, OR FIELDS, WHICH CHANGE THROUGH TIME.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: First note (only) of motifs are guaranateed to be on a harmonic set(field) note\n");
		fprintf(stdout,"INFO: except in MOTIFS IN HF, where motifs notes are forced onto set (field) notes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: PARAMETERS FOR TEXTURE---------------------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (** starred items CANNOT vay in time)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT DURATION...........**.(min) duration of outfile\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- TIMING PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EVENT PACKING ...............(average) time between event onsets.\n");
		fprintf(stdout,"INFO: SKIPTIME BETWEEN GROUP,MOTIF ONSETS..(average) time between group,motif onsets.\n");
		fprintf(stdout,"INFO: EVENT SCATTER................randomisation of event, group or motif onsets.\n");
		fprintf(stdout,"INFO: PAUSE BEFORE LINE REPEATS....time between last event of line & start of repetition.\n");
		fprintf(stdout,"INFO: TIME GRID UNIT...............minstep(MS) quantised timegrid (for event starttimes)\n");
		fprintf(stdout,"INFO: TIME GRID FOR NOTEGROUPS.....a timegrid (MS) applying WITHIN groups (for grouped textures)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- SOUND PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1ST SND-IN-LIST TO USE,LAST..1st,last snd to use,from listed input sounds.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- LOUDNESS PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN EVENT GAIN, MAX..........min & max level of input events\n");
		fprintf(stdout,"INFO: MIN EVENT SUSTAIN, MAX.......min & max sustain-time of events.\n");
		fprintf(stdout,"INFO: OVERALL ATTENUATION..........overall attenuation of the output\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: and for grouped textures\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GROUP AMPLITUDE CHANGE.......amplitude change within grouped-events\n");
		fprintf(stdout,"INFO: GROUP AMPCONTOUR TYPE.....**.amplitude contour within grouped-events\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- PITCH PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN PITCH, MAX...............min & max pitch(MIDI): (gives transposition of input)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- SPATIAL PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB: If STEREO source files are USED, SPATIALISATION parameters are IGNORED\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPATIAL POSITION.............centre of output sound-image.\n");
		fprintf(stdout,"INFO: SPATIAL SPREAD...............spatial-spread of texture events.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: and for grouped textures\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GROUP SPATIALISATION TYPE.**.spatialisation of event within groups\n");
		fprintf(stdout,"INFO: GROUP SPATIALISATION RANGE...spatial range within event-groups\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- OTHER GROUP PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN GROUP-PACKING-TIME,MAX...smallest,largest number of events in groups\n");
		fprintf(stdout,"INFO: MIN GROUP PITCHRANGE, MAX....min,max pitchrange, in semitones, of events in groups\n");
		fprintf(stdout,"INFO: MIN HFIELD NOTES RANGE,MAX...min,max number of hfield-notes range in groups\n");
		fprintf(stdout,"INFO: MIN MOTIF-DUR-MULTIPLIER,MAX min,max multiplier of input duration of motif\n");
		fprintf(stdout,"INFO: PITCH CENTRING............**.how decor pitches centre on line pitches\n");
		fprintf(stdout,"INFO: FIXED TIMESTEP IN GROUP......notes in a group run at a fixed tempo.\n");
		fprintf(stdout,"INFO: FIXED NOTE-SUSTAIN IN MOTIFS all notes in motif have same sustain-time as first.\n");
		fprintf(stdout,"INFO: SCATTER DECOR INSTRS.........orns not confined to instr of ornd-note.\n");
		fprintf(stdout,"INFO: DECORS TO HIGHEST NOTE.......orns on highest note of any chord: default,1st note\n");
		fprintf(stdout,"INFO: DECORS ON EVERY NOTE.........ornaments on all notes of any chord.\n");
		fprintf(stdout,"INFO: DISCARD ORIGINAL LINE........after decoration\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------- OTHER PARAMETERS -----------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEED.........................same seed-number: reproducible output (0: not so)\n");
		fprintf(stdout,"INFO: PLAY ALL OF INSOUND..........always play whole input-sound (ignoring dur vals).\n");
		fprintf(stdout,"INFO: PLAY FILES CYCLICALLY........play sounds in input order (always uses ALL input sounds).\n");
		fprintf(stdout,"INFO: RANDOMLY PERMUTE EACH CYCLE..permute order of sounds, in each complete cycle.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: SOME SPECIAL PARAMETER VALUES---------------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GROUP SPATIALISATION TYPE VALUES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 0:still.................1:scattered(default)........2:towards-texture-centre\n");
		fprintf(stdout,"INFO: 3:away-from-centre......4:follow-texmotion..........5:contrary-to-motion\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 4 & 5 only function if spatial position varies in time..\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GROUP AMPCONTOUR TYPE VALUES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 0:mixed(default)\n");
		fprintf(stdout,"INFO: 1:cresc..............2:flat...............3:decresc..............4:cresc_or_flat\n");
		fprintf(stdout,"INFO: 5:cresc_or_decresc...6:decresc_or_flat....[7:directed_to_event....8:directed_or_flat]\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCH CENTRING VALUES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: how decoration pitches centre on decorated line pitches\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 0: centred(default)\n");
		fprintf(stdout,"INFO: 1: above.................2: below...............3: centred_and_above\n");
		fprintf(stdout,"INFO: 4: centred_and_below.....5: above_and_below.....6: all_types\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In all cases except 0, pitchrange shifts to tally with line pitch\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: NOTEDATA IS A TEXTFILE CONTAINING-----------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LINE 1: list of (possibly fictional) MIDI pitch of each input snd.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Then, where motifs, or event timings, or harmonic sets (fields) are required,\n");
		fprintf(stdout,"INFO: or a pitchline is required for ornamenting or decorating..\n");
		fprintf(stdout,"INFO: each subsequent group of lines specifies a NOTELIST\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: NOTELISTS MUST BE IN THIS ORDER-------------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Notelist of notes in any timing set\n");
		fprintf(stdout,"INFO: Notelist of notes in any line TO BE ornamented or decorated\n"); 
		fprintf(stdout,"INFO: Notelist of notes in any harmonic set(s) or field(s) specified.\n");
		fprintf(stdout,"INFO: Notelist(s) of notes in any ornament(s) or motif(s) specified.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: For more than one harmonic set (field),\n");
		fprintf(stdout,"INFO: data should specify chords, placed at appropriate times (see below).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: NOTELISTS HAVE THE FOLLOWING FORMAT---------------------------------------------\n");
		fprintf(stdout,"INFO: --------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: first line:  #N\n");
		fprintf(stdout,"INFO: other lines: time(SECS)     infile_no      pitch(MIDI)      amp(MIDI)     dur(SECS)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: where N = number of notes (and therefore lines) in notelist to follow,\n");
		fprintf(stdout,"INFO: and times in notelist must never decrease.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MOD_LOUDNESS):
		fprintf(stdout,"INFO: ADJUST LOUDNESS OF A SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GAIN:.............adjust level by factor GAIN.\n");
		fprintf(stdout,"INFO: GAINdB:...........adjust level by factor GAIN dB.\n");
		fprintf(stdout,"INFO: NORMALISE:.. .....force level (if necessary) to given value.\n");
		fprintf(stdout,"INFO: FORCE LEVEL:......force level to given value.\n");
		fprintf(stdout,"INFO: BALANCE:..........force max level of file1 to max level of file 2.\n");
		fprintf(stdout,"INFO: INVERT PHASE:...Invert phase of file.\n");
		fprintf(stdout,"INFO: LOUDEST:..........Find loudest sound, and its level.\n");
		fprintf(stdout,"INFO: EQUALISE:..........Force level of all sounds to that of loudest.\n");
		fprintf(stdout,"INFO: PROPORTIONAL:......adjust level following envelope, which is stretched to match duration of infile.\n");
		fprintf(stdout,"INFO: PROPORTIONAL dB:...adjust level following dB envelope, which is stretched to match duration of infile.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MOD_SPACE):
		fprintf(stdout,"INFO: CREATE OR ALTER DISTRIBUTION OF SOUND IN STEREO SPACE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PAN:.........Position or move mono sound in a stereo field.\n");
		fprintf(stdout,"INFO: .............-1 Hard Left : 0 Centre : 1 Hard Right\n");
		fprintf(stdout,"INFO: .............< -1 hard left & attenuated : > 1 hard right & attenuated.\n");
		fprintf(stdout,"INFO: .............Prescale reduces input level to avoid clipping.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIRROR:......Invert stereo positions in a stereo file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIRROR PAN:..Invert stereo positions in a pan data file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NARROW:......Narrow the stereo image of a sound.\n");
		fprintf(stdout,"INFO: .............     1   leaves stereo image as it is.\n");
		fprintf(stdout,"INFO: .............    .5  narrows stereo image by half.\n");
		fprintf(stdout,"INFO: .............     0   converts stereo image to mono.\n");
		fprintf(stdout,"INFO: .............     -ve vals work similarly, but also invert stereo image.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SCALED_PAN):
		fprintf(stdout,"INFO: DISTRIBUTE SOUND IN STEREO SPACE, WITH BREAKPOINT DATA TIME_SCALED TO SOUNDFILE DURATION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PAN:.........-1 Hard Left : 0 Centre : 1 Hard Right\n");
		fprintf(stdout,"INFO: .............< -1 hard left & attenuated : > 1 hard right & attenuated.\n");
		fprintf(stdout,"INFO: PRESCALE .....reduces input level to avoid clipping.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SIN_TAB):
		fprintf(stdout,"INFO: GENERATE A SINUSOIDALLY PANNING PAN-CONTROL FILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE LENGTH....is duration of one complete sinusoidal pan cycle\n");
		fprintf(stdout,"INFO: PAN WIDTH.......is the width of the pan, from 0 to full width,1\n");
		fprintf(stdout,"INFO: DURATION........is the duration of the output data file.\n");
		fprintf(stdout,"INFO: QUANTISATION....is time step between successive space-positions specified in datafile.\n");
		fprintf(stdout,"INFO: STARTPHASE......is the angular position at which the pan starts.\n");
		fprintf(stdout,"INFO:                    0   starts at centre and moves right.\n");
		fprintf(stdout,"INFO:                    90  starts at right.\n");
		fprintf(stdout,"INFO:                    180 starts at centre and moves left.\n");
		fprintf(stdout,"INFO:                    270 starts at left.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CYCLE LENGTH and PAN WIDTH may vary over time\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MOD_PITCH):
		fprintf(stdout,"INFO: CHANGE THE SPEED & PITCH OF THE SRC SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) SPEED CHANGE...............also changing sound pitch.\n");
		fprintf(stdout,"INFO: 2) SPEED CHANGE IN SEMITONES..speed shift given in semitones.\n");
		fprintf(stdout,"INFO: 3) VARISPEED INFO.............see how outtimes relate to intimes.\n");
		fprintf(stdout,"INFO: 4) VARISPEED SEMITONES INFO...see how outtimes relate to intimes.\n");
		fprintf(stdout,"INFO: 5) ACCELERATE.................cause sound to accelerate.\n");
		fprintf(stdout,"INFO: 6) VIBRATO....................add vibrato to sound.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In MODES 1-4 brkpnt times are infiletimes, unless flagged as outfiletimes.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In MODE 5....Acceleration is multiplication of speed reached at goaltime.\n");
		fprintf(stdout,"INFO: .............If infile not exhausted by goaltime, outfile continues to accelerate.\n");
		fprintf(stdout,"INFO: .............If infile finishes before goaltime, outfile won't reach accel val.\n");
		fprintf(stdout,"INFO: ............ Starttime is time in input/output file at which acceleration begins.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: In MODE 6....Cycles-per-second is rate of vibrato shaking,\n");
		fprintf(stdout,"INFO: .............and Depth is vibrato depth in (possibly fractional) semitones.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MOD_REVECHO):
		fprintf(stdout,"INFO: CREATE ECHO OR REVERBERATION OR RESONANCE AROUND A SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DELAY..........with feedback.\n");
		fprintf(stdout,"INFO: VARYING DELAY..low frequency oscillator varying delay time.\n");
		fprintf(stdout,"INFO: STADIUM ECHO...create echos like stadium P.A.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DELAYED SIGNAL IN MIX.....0 gives 'dry' result.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FEEDBACK..................gives resonance related to delay time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOFRQ MODULATION DEPTH....is the depth of delay-variation sweep.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODULATION FRQ............freq of sweep:\n");
		fprintf(stdout,"INFO: ..........................-ve frqs give random sweeping.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PHASE OF MODULATION.......determines where (high,low) sweep begins.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DELAY OF MODULATION...... determines when sweep begins.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LENGTH OF TAIL............to allow delayed signal to decay to zero.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INPUT PRESCALING..........prescales input level, to avoid overload.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RANDOM SEED...............Nonzero value gives reproducible output\n");
		fprintf(stdout,"INFO: ..........................(with same seed) for random oscillations.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INVERT DELAYED SIGNAL.....for phasing effects.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ------------------ AND FOR STADIUM ---------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INPUT GAIN................Attenuates signal input to stadium.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LEVEL LOSS WITH DISTANCE..across stadium.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STADIUM SIZE MULTIPLIER...Multiplies average time between echos.\n");
		fprintf(stdout,"INFO: ..........................(Default average echo time = 0.1 secs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NUMBER OF ECHOS...........Number of stadium echos produced.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MOD_RADICAL):
		fprintf(stdout,"INFO: RADICAL CHANGES TO THE SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REVERSE: Sound plays backwards.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SHRED:  Shred sound within its existing duration.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        NUMBER OF SHREDS. ...number of repeats of shredding process.\n");
		fprintf(stdout,"INFO:        AVERAGE CHUNKLENGTH..average length of chunks to cut & permute.\n");
		fprintf(stdout,"INFO:        CUT SCATTER..........randomisation of cuts (0 to K): default 1.\n");
		fprintf(stdout,"INFO:        .....................where K = total number of chunks (snd-duration/chunklen).\n");
		fprintf(stdout,"INFO:        .....................If scatter = 0: snd reordered without shredding.\n");
 		fprintf(stdout,"INFO:        .....................NB:  chunklen*scatter MUST be smaller than snd buffer.\n");
		fprintf(stdout,"INFO:        .....................NB2: If Input sound > internal buffer len,\n");
		fprintf(stdout,"INFO:        .....................each buffer of sound shredded independently.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SCRUB: BACK & FORTH, AS IF HANDWINDING OVER A TAPE-HEAD.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        MINIMUM OUTPUT DURATION........min duration of outfile required.\n");
		fprintf(stdout,"INFO:        LOWEST DOWNWARD TRANSPOSITION..(semitones).\n");
		fprintf(stdout,"INFO:        HIGHEST UPWARD TRANSPOSITION...(semitones).\n");
		fprintf(stdout,"INFO:        SCRUBS START NO LATER THAN.....start before time 'start' secs.\n");
		fprintf(stdout,"INFO:        SRCUBS END NO EARLIER THAN.....end after time 'end' secs.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOSE RESOLUTION: CONVERT TO LOWER SRATE, OR BIT-RESOLUTION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        BIT_RESOLUTION....range(1 - 16): default 16-bit.\n");
		fprintf(stdout,"INFO:        SRATE_DIVISION....range(1-256): default 1 (normal)\n");
		fprintf(stdout,"INFO:        entered svalue will be rounded to a power of 2.\n");
		fprintf(stdout,"INFO:        Works on MONO FILES ONLY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: RING MODULATE AGAINST GIVEN FREQUENCY, CREATING SIDEBANDS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CROSS MODULATE TWO INFILES CREATING COMPLEX SIDEBANDS.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(BRASSAGE):
		fprintf(stdout,"INFO: GRANULAR RECONSTITUTION OF SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIMESHRINK..............Speed of advance in infile, relative to outfile. (>=0)\n");
		fprintf(stdout,"INFO: ........................Inverse of timestretch, (& permits infinite timestretch).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DENSITY.................Amount of grain overlap (>0 : <1 leaves intergrain silence)\n");
		fprintf(stdout,"INFO: ........................Extremely small values will cease to perform predictably.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GRAINSIZE...............grainsize in MS (must be > 2 * splicelen)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCHSHIFT..............is pitchshift of grains in +|- (fractions of) semitones.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOUDNESS RANGE..........is range of gain on grains.\n");
		fprintf(stdout,"INFO: ........................Use only if amp is to vary (over range &/or through time)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STARTSPLICE.............length of startsplices on grains,in MS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENDSPLICE...............length of endsplices on grains,in MS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPATIAL POSITION........stereo position in outputfile. 0=L,1=R.\n");
		fprintf(stdout,"INFO: ........................Space flag on MULTICHANNEL input, mixes it to mono before acting.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEARCHRANGE.............for nextgrain, before current 'now' in infile (Default 0 MS).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SCATTER.................Randomisation of grain position (Range 0-1).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT LENGTH...........max outfile length (if end of data not reached).\n");
		fprintf(stdout,"INFO: ........................Set to ZERO (Default) for this parameter to be IGNORED.\n");
		fprintf(stdout,"INFO: ........................BUT if TIMESHRINK is ANYWHERE 0: OUTLENGTH must be given.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHANNEL TO EXTRACT......Positive value is channel to extract, and process.\n");
		fprintf(stdout,"INFO: ........................Zero (Default) processes all channels.\n");
		fprintf(stdout,"INFO: ........................Negative values create spatialisation > stereo.\n");
		fprintf(stdout,"INFO: ........................e.g. -5 creates a 5-channel spatialised output.\n");
		fprintf(stdout,"INFO: ........................NB spatialisation only happens if \"spatial position\" is itself non-zero.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCH NOT INTERPOLATED..No interpolation for transpose,(quick, dirty).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIMESHRINK LIMIT,\n");
		fprintf(stdout,"INFO: DENSITY LIMIT, ETC..... allow range of values to be specified for any of these params.\n");
		fprintf(stdout,"INFO: ........................e.g. With Density & Density Limit set\n");
		fprintf(stdout,"INFO: ........................random density chosen between these values.\n");
		fprintf(stdout,"INFO: ........................Density & Density Limit can THEMSELVES vary through time.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SAUSAGE):
		fprintf(stdout,"INFO: GRANULAR RECONSTITUTION OF SEVERAL SOUNDFILES, SCRAMBLED TOGETHER.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIMESHRINK..............Speed of advance in infiles, relative to outfile. (>=0)\n");
		fprintf(stdout,"INFO: ........................Inverse of timestretch, (& permits infinite timestretch).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DENSITY.................Amount of grain overlap (>0 : <1 leaves intergrain silence)\n");
		fprintf(stdout,"INFO: ........................Extremely small values will cease to perform predictably.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GRAINSIZE...............grainsize in MS (must be > 2 * splicelen)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCHSHIFT..............is pitchshift of grains in +|- (fractions of) semitones.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LOUDNESS RANGE..........is range of gain on grains.\n");
		fprintf(stdout,"INFO: ........................Use only if amp is to vary (over range &/or through time)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STARTSPLICE.............length of startsplices on grains,in MS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENDSPLICE...............length of endsplices on grains,in MS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPATIAL POSITION........stereo position in outputfile. 0=L,1=R.\n");
		fprintf(stdout,"INFO: ........................Space flag on MULTICHANNEL input, mixes it to mono before acting.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEARCHRANGE.............for nextgrain, before current 'now' in infile (Default 0 MS).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SCATTER.................Randomisation of grain position (Range 0-1).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT LENGTH...........max outfile length (if end of data not reached).\n");
		fprintf(stdout,"INFO: ........................Set to zero (Default) for this parameter to be ignored.\n");
		fprintf(stdout,"INFO: ........................BUT if TIMESHRINK is ANYWHERE 0: OUTLENGTH must be given.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHANNEL TO EXTRACT......Causes process to work on just 1 specified channel\n");
		fprintf(stdout,"INFO: ........................of a multichannel snd. Zero (Default) processes all channels.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCH NOT INTERPOLATED..No interpolation for transpose,(quick, dirty).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIMESHRINK LIMIT,\n");
		fprintf(stdout,"INFO: DENSITY LIMIT ETC.......allow range of values to be specified for any of these params.\n");
		fprintf(stdout,"INFO: ........................e.g. With Density & Density Limit set\n");
		fprintf(stdout,"INFO: ........................random density chosen between these values.\n");
		fprintf(stdout,"INFO: ........................Density & Density Limit can THEMSELVES vary through time.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PVOC_ANAL):
		fprintf(stdout,"INFO: CONVERT SOUNDFILE TO SPECTRAL FILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STANDARD ANALYSIS\n");
		fprintf(stdout,"INFO: OUTPUT SPECTRAL ENVELOPE VALS ONLY\n");
		fprintf(stdout,"INFO: OUTPUT SPECTRAL MAGNITUDE VALS ONLY\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ANALYSIS POINTS..(2-32768 (power of 2)): default 1024\n");
		fprintf(stdout,"INFO: .................More points give better freq resolution\n");
		fprintf(stdout,"INFO: .................but worse time-resolution (e.g. rapidly changing spectrum).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OVERLAP..........Filter overlap factor (1-4): default 3\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PVOC_SYNTH):
		fprintf(stdout,"INFO: CONVERT SPECTRAL FILE TO SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(PVOC_EXTRACT):
		fprintf(stdout,"INFO: ANALYSE THEN RESYNTHESIZE SOUND WITH VARIOUS OPTIONS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ANALYSIS POINTS......(2-32768 (power of 2)): default 1024\n");
		fprintf(stdout,"INFO: .....................More points give better freq resolution\n");
		fprintf(stdout,"INFO: .....................but worse time-resolution (e.g. rapidly changing spectrum).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ANALWINDOW OVERLAP...Range (1-4): default 3\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SELECT A CHANNEL.....resynthesizes odd (1) or even (2) channels only\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BOTTOM RESYNTH CHAN..ignore analysis chans below this in resynth (default: 0)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TOP RESYNTH CHANNEL..ignore chans above this in resynth (dflt: highest channel)\n");
		fprintf(stdout,"INFO: .....................There is 1 channel for every 2 analysis points.\n");
		fprintf(stdout,"INFO: .....................hence Top Resynth Channel should not be > ANALYSIS POINTS/2\n");
		fprintf(stdout,"INFO: .....................To default to topmost channel, set it to ZERO.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB If no parameters are set, the output sound will be the same as the input.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(EDIT_CUT):
		fprintf(stdout,"INFO: CUT & KEEP A SEGMENT OF A SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME IN SECONDS..........Specify time in seconds.\n");
		fprintf(stdout,"INFO: TIME AS SAMPLE COUNT.....Specify time as sample count (rounded to multiples of channel-cnt).\n");
		fprintf(stdout,"INFO: TIME AS GROUPED SAMPLES..Specify time as grouped-sample count (e.g. 3 = 3 stereo-pairs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME OF STARTCUT..is time in infile where segment to keep begins.\n");
		fprintf(stdout,"INFO: TIME OF ENDCUT....is time in infile where segment to keep ends.\n");
		fprintf(stdout,"INFO: SPLICELEN.........splice window in MS (default: %.0lf)\n",EDIT_SPLICELEN);
		fprintf(stdout,"INFO: \n");
		break;
	case(STACK):
		fprintf(stdout,"INFO: STACK TRANSPOSED COPIES OF A SOUND ON TOP OF ONE ANOTHER.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TRANSPOSITION DATA transposition in semitones.\n");
		fprintf(stdout,"INFO: ...................If numeric (e.g. N semitones) stack consists of original sound\n");
		fprintf(stdout,"INFO: ...................plus original sound transposed by N, 2N, 3N etc\n");
		fprintf(stdout,"INFO: ...................If data in a file, stack consists of copies of original source\n");
		fprintf(stdout,"INFO: ...................transposed by the values in the file.\n");
		fprintf(stdout,"INFO: NUMBER OF ITEMS....Number of (transposed) copies to mix.\n");
		fprintf(stdout,"INFO: STACK LEAN.........How much louder is highest sound in stack than lowest sound\n");
		fprintf(stdout,"INFO: ATTACK TIME........At what time (in the original file) should the copies be synchronised.\n");
		fprintf(stdout,"INFO: OVERALL GAIN.......Overall gain applied to the output stack\n");
		fprintf(stdout,"INFO: HOW MUCH OF OUTPUT.......What proportion of the output to generate\n");
		fprintf(stdout,"INFO:                    (if less than 1.0, output will cut off abruptly (click)\n");
		fprintf(stdout,"INFO: \n");
	case(EDIT_CUTMANY):
		fprintf(stdout,"INFO: CUT & KEEP SEVERAL SPECIFIED SEGMENTS OF A SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME IN SECONDS..........Specify time in seconds.\n");
		fprintf(stdout,"INFO: TIME AS SAMPLE COUNT.....Specify time as sample count (rounded to multiples of channel-cnt).\n");
		fprintf(stdout,"INFO: TIME AS GROUPED SAMPLES..Specify time as grouped-sample count (e.g. 3 = 3 stereo-pairs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CUT TIMES.........Start and end times for each cut segment, in a file\n");
		fprintf(stdout,"INFO: SPLICELEN.........splice window in MS (default: %.0lf)\n",EDIT_SPLICELEN);
		fprintf(stdout,"INFO: \n");
		break;
	case(EDIT_CUTEND):
		fprintf(stdout,"INFO: CUT & KEEP END PORTION OF A SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME IN SECONDS..........Specify time in seconds.\n");
		fprintf(stdout,"INFO: TIME AS SAMPLE COUNT.....Specify time as sample count (rounded to multiples of channel-cnt).\n");
		fprintf(stdout,"INFO: TIME AS GROUPED SAMPLES..Specify time as grouped-sample count (e.g. 3 = 3 stereo-pairs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LENGTH TO KEEP..ending at end of input sound.\n");
		fprintf(stdout,"INFO: SPLICELEN.......splice window in MS (default: %.0lf)\n",EDIT_SPLICELEN);
		fprintf(stdout,"INFO: \n");
		break;
	case(EDIT_ZCUT):
		fprintf(stdout,"INFO: CUT & KEEP SEGMENT OF MONO SOUND, CUTTING AT ZERO-CROSSINGS (NO SPLICES).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME IN SECONDS..........Specify time in seconds.\n");
		fprintf(stdout,"INFO: TIME AS SAMPLE COUNT.....Specify time as sample count (rounded to multiples of channel-cnt).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME OF STARTCUT..(approx) time in infile where segment to keep begins.\n");
		fprintf(stdout,"INFO: TIME OF ENDCUT....(approx) time in infile where segment to keep ends.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MANY_ZCUTS):
		fprintf(stdout,"INFO: CUT & KEEP SEVERAL SEGMENT OF A MONO SOUND, CUTTING AT ZERO-CROSSINGS (NO SPLICES).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME IN SECONDS..........Specify time in seconds.\n");
		fprintf(stdout,"INFO: TIME AS SAMPLE COUNT.....Specify time as sample count (rounded to multiples of channel-cnt).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CUT TIMES.........Start and end times for each cut segment, in a file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(EDIT_EXCISE):
		fprintf(stdout,"INFO: DISCARD SPECIFIED CHUNK OF SOUND, CLOSING UP THE GAP.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME IN SECONDS..........Specify time in seconds.\n");
		fprintf(stdout,"INFO: TIME AS SAMPLE COUNT.....Specify time as sample count (rounded to multiples of channel-cnt).\n");
		fprintf(stdout,"INFO: TIME AS GROUPED SAMPLES..Specify time as grouped-sample count (e.g. 3 = 3 stereo-pairs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME OF STARTCUT..starttime of excision.\n");
		fprintf(stdout,"INFO: TIME OF ENDCUT....endtime of excision.\n");
		fprintf(stdout,"INFO: SPLICELEN.........splice window in MS (default: %.0lf)\n",EDIT_SPLICELEN);
		fprintf(stdout,"INFO: \n");
		break;
	case(EDIT_EXCISEMANY):
		fprintf(stdout,"INFO: DISCARD SPECIFIED CHUNKS OF A SOUND, CLOSING UP THE GAPS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME IN SECONDS..........Specify time in seconds.\n");
		fprintf(stdout,"INFO: TIME AS SAMPLE COUNT.....Specify time as sample count (rounded to multiples of channel-cnt).\n");
		fprintf(stdout,"INFO: TIME AS GROUPED SAMPLES..Specify time as grouped-sample count (e.g. 3 = 3 stereo-pairs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXCISEFILE..is a texfile with (paired) start & end times of chunks\n");
		fprintf(stdout,"INFO: ............to be removed. These must be in increasing time order.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPLICELEN...splice window in MS (default: %.0lf)\n",EDIT_SPLICELEN);
		fprintf(stdout,"INFO: \n");
		break;
	case(EDIT_INSERT):
		fprintf(stdout,"INFO: INSERT A 2nd SOUND INTO AN EXISTING SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME IN SECONDS..........Specify time in seconds.\n");
		fprintf(stdout,"INFO: TIME AS SAMPLE COUNT.....Specify time as sample count (rounded to multiples of channel-cnt).\n");
		fprintf(stdout,"INFO: TIME AS GROUPED SAMPLES..Specify time as grouped-sample count (e.g. 3 = 3 stereo-pairs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INSERTION TIME..where 2nd file inserted into 1st.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPLICELEN.......splice window in MS (default: %.0lf)\n",EDIT_SPLICELEN);
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INSERT LEVEL....gain multiplier on inserted file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OVERWRITE.......overwrite 1st file with inserted file.\n");
		fprintf(stdout,"INFO: ................(default .. insertion pushes infile apart).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(EDIT_INSERT2):
		fprintf(stdout,"INFO: INSERT A 2nd SOUND INTO AN EXISTING SOUND, REPLACING A SEGEMNT OF THAT SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INSERTION TIME..where 2nd file inserted into 1st.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: END TIME OF OVERWRITE..endtime of segment in 1st file to be overwritten by insertion.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPLICELEN.......splice window in MS (default: %.0lf)\n",EDIT_SPLICELEN);
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INSERT LEVEL....gain multiplier on inserted file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(EDIT_INSERTSIL):
		fprintf(stdout,"INFO: INSERT SILENCE INTO AN EXISTING SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME IN SECONDS..........Specify time in seconds.\n");
		fprintf(stdout,"INFO: TIME AS SAMPLE COUNT.....Specify time as sample count (rounded to multiples of channel-cnt).\n");
		fprintf(stdout,"INFO: TIME AS GROUPED SAMPLES..Specify time as grouped-sample count (e.g. 3 = 3 stereo-pairs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INSERTION TIME.......where silence inserted.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION OF SILENCE..duration of silence\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPLICELEN............splice window in MS (default: %.0lf)\n",EDIT_SPLICELEN);
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OVERWRITE............overwrite infile with inserted silence.\n");
		fprintf(stdout,"INFO: .....................(default .. insertion pushes infile apart).\n");
		fprintf(stdout,"INFO: RETAIN TRAILING SILENCE....retain silence written over end of file.\n");
		fprintf(stdout,"INFO: .....................(default .. rejects insertion of silence at end of file).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(EDIT_JOIN):
		fprintf(stdout,"INFO: JOIN FILES TOGETHER, ONE AFTER ANOTHER.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPLICE........duration of splices, in MS (default 15)\n");
		fprintf(stdout,"INFO: SPLICE START..splices start of first file.\n");
		fprintf(stdout,"INFO: SPLICE END....splices end of last file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HOUSE_COPY):
		fprintf(stdout,"INFO: PRODUCE COPIES OF THE INFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: COPY ONCE\n" );
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: COPY MANY\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:       NUMBER OF DUPLICATES....is number of copies to produce.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:       IGNORE EXISTING COPIES..don't overwrite files with any of these names.\n");
		fprintf(stdout,"INFO:       ........................Otherwise process HALTS on discovering\n");
		fprintf(stdout,"INFO:       ........................a pre-existing file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HOUSE_DEL):
		fprintf(stdout,"INFO: DELETE EXISTING COPIES OF A FILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If you specify the generic name 'xx',\n");
		fprintf(stdout,"INFO: Deletes any files having names xxN, where N is an integer.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CARE: No checks are made that these ARE COPIES of file xx!!\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEARCH FOR ALL COPIES...Program checks all names in numbered sequence.\n");
		fprintf(stdout,"INFO: ........................Without this flag, once a numbered file is missing,\n");
		fprintf(stdout,"INFO: ........................program checks for %d more named files before halting.\n",COPYDEL_OVERMAX);
		fprintf(stdout,"INFO: ........................With flag, program searches for all possible\n");
		fprintf(stdout,"INFO: ........................duplicate filenames. This may take some time.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HOUSE_CHANS):
		fprintf(stdout,"INFO: EXTRACT OR CONVERT CHANNELS OF SOUNDFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXTRACT A CHANNEL\n");
		fprintf(stdout,"INFO: ..........CHANNEL TO GET is channel to extract\n" );
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXTRACT ALL CHANNELS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ZERO ONE CHANNEL\n");
		fprintf(stdout,"INFO: ..........CHANNEL TO ZERO is channel to set to zero.\n" );
		fprintf(stdout,"INFO: ..........mono file goes to just one side of stereo outfile.\n");
		fprintf(stdout,"INFO: ..........stereo file has one channel zeroed out.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: STEREO TO MONO\n");
		fprintf(stdout,"INFO: ..........INVERT CHANNEL2 PHASE: inverts channel 2 phase before mixing.\n" );
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MONO TO STEREO\n");
		fprintf(stdout,"INFO: ..........Creates a 2-channel equivalent of mono infile.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HOUSE_BUNDLE):
		fprintf(stdout,"INFO: COMPARE A LIST OF FILES BY TYPE OR PROPERTIES, AND LIST CHOSEN FILES IN A TEXTFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ANY FILES........Bundle all entered files.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NON-TEXT FILES...Bundle any non-text files entered.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SAME TYPE........Bundle all non-text files of same type as first\n");
		fprintf(stdout,"INFO: .................non-text file entered. e.g. all analysis files....\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SAME PROPERTIES..Bundle all non-text files with same properties\n");
		fprintf(stdout,"INFO: .................as first non-text file entered.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SAME CHANNELS....If first non-text file entered is a soundfile,\n");
		fprintf(stdout,"INFO: .................bundle only soundfiles with same channel count.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HOUSE_SORT):
		fprintf(stdout,"INFO: SORT FILES LISTED IN A TEXTFILE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BY FILETYPE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        Sorts files into different types.\n");
		fprintf(stdout,"INFO:        Lists filenames in separate textfiles.. \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BY SAMPLE RATE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        Sorts any soundfiles to different sampling rates.\n");
		fprintf(stdout,"INFO:        Lists filenames in separate textfiles.. \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BY DURATION\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        Sorts any soundfiles to different lengths.\n");
		fprintf(stdout,"INFO:        SMALL  is max size of smallest files. (secs)\n");
		fprintf(stdout,"INFO:        LARGE  is min size of largest files. (secs)\n");
		fprintf(stdout,"INFO:        STEP   is size-steps between file types. (secs)\n");
		fprintf(stdout,"INFO:        Use DON'T DISPLAY TIMINGS to suppress time values in outfile.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BY LOG DURATION\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        The same, except STEP is duration ratio between file types.\n");
		fprintf(stdout,"INFO:        Use DON'T DISPLAY TIMINGS to suppress time values in outfile.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INTO DURATION ORDER\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        Sorts any sndfiles into duration order.\n");
		fprintf(stdout,"INFO:        Use DON'T DISPLAY TIMINGS to suppress time values in outfile.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FIND ROGUES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        Sort out any non- or invalid soundfiles (ONLY).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HOUSE_SPEC):
		fprintf(stdout,"INFO: ALTER THE SPECIFICATION OF A SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHANGE SAMPLING RATE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                    New sampling rate must be one of...\n");
		fprintf(stdout,"INFO:                    48000,24000,44100,22050,32000,16000\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CONVERT SAMPLE FORMAT\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                    Convert from integer to float, or vice versa.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHANGE PROPERTIES OF SOUND (USE WITH CAUTION!!)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:       SAMPLE RATE..is the new sample rate to impose.\n");
		fprintf(stdout,"INFO:       .............NB: this does NOT RESAMPLE the data.\n");
		fprintf(stdout,"INFO:       .............Simply causes data to be read at different srate.\n");
		fprintf(stdout,"INFO:       .............Sound has same number of samples, different duration,\n");
		fprintf(stdout,"INFO:       .............and will appear to be transposed in pitch.\n");
		fprintf(stdout,"INFO:       CHANNELS.....is the new channel count to impose.\n");
		fprintf(stdout,"INFO:       .............NB: this does NOT RECHANNEL the data. e.g.\n");
		fprintf(stdout,"INFO:       .............Stereo file set to mono will appear twice as long.\n");
		fprintf(stdout,"INFO:       SAMPLE TYPE..(0=integers 1=floats) New sample type to impose.\n");
		fprintf(stdout,"INFO:       .............USE ONLY TO RESTORE A CORRUPTED HEADER.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HOUSE_EXTRACT):
		fprintf(stdout,"INFO: EXTRACT SIGNIFICANT DATA FROM SNDFILES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GATED EXTRACTION.....Cut out & keep significant events from sndfile.\n");
		fprintf(stdout,"INFO: .....................in separate files.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:       GATE LEVEL .........level below which sounds are omitted.\n");
		fprintf(stdout,"INFO:       SPLICE LENGTH.......in milliseconds (default 15ms)\n");
		fprintf(stdout,"INFO:       ENDGATE LEVEL.......level below which END of sound cut off.\n");
		fprintf(stdout,"INFO:                           (If set at zero, defaults to GATE value).\n");
		fprintf(stdout,"INFO:       THRESHOLD ..........Level within extracted event must exceed threshold,\n");
		fprintf(stdout,"INFO:                           if event is to be retained.(default 0)\n");
		fprintf(stdout,"INFO:       RETAIN TO ..........N sectors before start of next sound-segment.(default 0)\n");
		fprintf(stdout,"INFO:                           ('Sectors' are envelope blocks,see EXTRACTION PREVIEW)\n");
		fprintf(stdout,"INFO:       BAKTRAK ............and keep N sectors prior to gate-on, but only if\n");
		fprintf(stdout,"INFO:                           any segment level is above INITIAL LEVEL (see below).\n");
		fprintf(stdout,"INFO:       INITIAL LEVEL.......for use with baktraking.\n");
		fprintf(stdout,"INFO:       MIN DURATION........of segments to keep (secs).\n");
		fprintf(stdout,"INFO:       GATE WINDOWS........Sound gates OFF only if level stays below gate\n");
		fprintf(stdout,"INFO:                           for (GATE_WINDOWS+1) sectors. (default 0).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXTRACTION PREVIEW...create pseudo-sndfile showing envelope of sndfile,sector by sector.\n");
		fprintf(stdout,"INFO: .....................View this file to choose parameters for GATED EXTRACTION.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TOP AND TAIL.........Remove low level signal from start and end of a sound.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:       GATE LEVEL .....is level ABOVE which signal is accepted.\n");
		fprintf(stdout,"INFO:                       (Range 0-1 : default 0).\n");
		fprintf(stdout,"INFO:       SPLICE LENGTH...in milliseconds (default 15ms)\n");
		fprintf(stdout,"INFO:       NO START TRIM...Don't trim beginning of file.\n");
		fprintf(stdout,"INFO:       NO END TRIM.....Don't trim end of file.\n");
		fprintf(stdout,"INFO:                       Default: trims BOTH.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: REMOVE DC............shift entire signal to eliminate DC drift.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FIX BY HAND............For each bad sample, give sample number and value you want it to be.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FIND AND LIST ONSETS.....Find start-times of significant events from sndfile.\n");
		fprintf(stdout,"INFO: ..........................................and store in a textdata file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:       GATE LEVEL .........level below which sounds are omitted.\n");
		fprintf(stdout,"INFO:       ENDGATE LEVEL.......level below which END of sound cut off.\n");
		fprintf(stdout,"INFO:                           (If set at zero, defaults to GATE value).\n");
		fprintf(stdout,"INFO:       THRESHOLD ..........Level within extracted event must exceed threshold,\n");
		fprintf(stdout,"INFO:                           if event is to be retained.(default 0)\n");
		fprintf(stdout,"INFO:       BAKTRAK ............and keep N sectors prior to gate-on, but only if\n");
		fprintf(stdout,"INFO:                           any segment level is above INITIAL LEVEL (see below).\n");
		fprintf(stdout,"INFO:       INITIAL LEVEL.......for use with baktraking.\n");
		fprintf(stdout,"INFO:       MIN DURATION........of segments to keep (secs).\n");
		fprintf(stdout,"INFO:       GATE WINDOWS........Sound gates OFF only if level stays below gate\n");
		fprintf(stdout,"INFO:                           for (GATE_WINDOWS+1) sectors. (default 0).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TOPNTAIL_CLICKS):
		fprintf(stdout,"INFO: REMOVE CLICKS FROM START AND/OR END OF SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:       GATE LEVEL .....is level ABOVE which signal is accepted.\n");
		fprintf(stdout,"INFO:                       (Range 0-1 : default 0).\n");
		fprintf(stdout,"INFO:       SPLICE LENGTH...in milliseconds (default 2ms)\n");
		fprintf(stdout,"INFO:       START TRIM......Trim beginning of file.\n");
		fprintf(stdout,"INFO:       END TRIM........Trim end of file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HOUSE_GATE):
		fprintf(stdout,"INFO: CUT UP A SOUNDFILE AT ZERO AMPLITUDE POINTS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MIN ZERO CNT FOR CUT POINT....minimum number of consecutive zero samples (per channel).\n");
		fprintf(stdout,"INFO:                               to indicate a silent gap in the file, where it can be cut.\n");
		break;
	case(HOUSE_BAKUP):
		fprintf(stdout,"INFO: CONCATENATE FILES INTO BACKUP FILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Takes any number of soundfiles and \n");
		fprintf(stdout,"INFO: creates a 'sndfile' containing those files separated by silent gaps.\n\n");
		fprintf(stdout,"INFO: Files must all have same number of channels.\n");
		break;
	case(HOUSE_DUMP):
		fprintf(stdout,"INFO: DUMP FILES TO SPECIAL BAKUP FILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Takes any number of any kind(s) of soundsystem files, and\n");
		fprintf(stdout,"INFO: creates a 'sndfile' containing those files PLUS their headers.\n");
		fprintf(stdout,"INFO: A textfile, listing the files SUCCESFULLY stored, is also created.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Each sound+HEADER is preceded by a 'bleep',\n");
		fprintf(stdout,"INFO: (for identification purposes when searching sound-tape),\n");
		fprintf(stdout,"INFO: and the output concluded by a longer bleep.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: This file can be stored and recovered from DAT, using DIGITAL OUTPUT and INPUT ONLY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Restore such dumped-files with RECOVER option.\n");
		break;
	case(HOUSE_RECOVER):
		fprintf(stdout,"INFO: RECOVER DUMPED FILES.\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: HEADER COPIES RETRIEVED..In dump file, each file has 100 header copies.\n");
		fprintf(stdout,"INFO: ......................This parameter specifies the minimum fraction of copies to retrieve\n");
		fprintf(stdout,"INFO: ......................to verify recovery.             Range (0 to 1)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MARKER VALIDITY.......fraction of bytes in header-marker to recover\n");
		fprintf(stdout,"INFO: ......................to verify we've found a header.   Range (0 to 1)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: HEADER CONSISTENCY....fraction of bytes in one of header copies\n");
		fprintf(stdout,"INFO: ......................that must tally with bytes in other versions\n");
		fprintf(stdout,"INFO: ......................to qualify it as a true 'copy'.   Range (0 to 1)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SIGNAL SHIFT TO APLY..Bleep should be at level %d exactly,\n",SQUAREAMP);
		fprintf(stdout,"INFO: ......................and should start with +ve values.\n");
		fprintf(stdout,"INFO: ......................If not, this is the linear shift to apply to data\n");
		fprintf(stdout,"INFO: ......................to get rid of the anomaly. (view file first).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PHASE INVERSION.......If the data is phase inverted, this flag restores the original phase\n");
		fprintf(stdout,"INFO: ......................(it is applied AFTER any shift).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Recovered files will NOT be listed on the workspace.\n");
		fprintf(stdout,"INFO: Recovery information is written to a REPORT FILE as well as to the screen.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Dumped datafiles must be transferred DIGITALLY to & from tape.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HOUSE_DISK):
		fprintf(stdout,"INFO: DISPLAY AVAILABLE SPACE ON DISK.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If a sndfile is input, its sample rate will govern space calculations.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_PROPS):
		fprintf(stdout,"INFO: DISPLAY PROPERTIES OF A SNDFILING-SYSTEM FILE\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_SFLEN):
		fprintf(stdout,"INFO: DISPLAY DURATION OF A SNDFILING-SYSTEM FILE\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_TIMELIST):
		fprintf(stdout,"INFO: LIST DURATIONS OF SEVERAL SNDFILING-SYSTEM FILES\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_LOUDLIST):
		fprintf(stdout,"INFO: LIST MAXIMUM LEVEL OF SEVERAL SOUNDFILES\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_TIMESUM):
		fprintf(stdout,"INFO: SUM DURATIONS OF SEVERAL SNDFILING-SYSTEM FILES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPLICELEN is in milliseconds. (Default: 15ms)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_TIMEDIFF):
		fprintf(stdout,"INFO: FIND DIFFERENCE IN DURATION OF TWO SOUND FILES\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_SAMPTOTIME):
		fprintf(stdout,"INFO: CONVERT SAMPLE COUNT TO TIME IN SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: with COUNT SAMPLES IN GROUPS  e.g. stereo file: sample-PAIRS counted.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_TIMETOSAMP):
		fprintf(stdout,"INFO: CONVERT TIME TO SAMPLE COUNT IN SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: with COUNT SAMPLES IN GROUPS  e.g. stereo file: sample-PAIRS counted.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_MAXSAMP):
		fprintf(stdout,"INFO: FIND MAXIMUM SAMPLE IN SOUNDFILE OR BINARY DATA FILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FORCE SEARCH IN SOUND  Ignores any maxval written in header.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_MAXSAMP2):
		fprintf(stdout,"INFO: FIND MAXIMUM SAMPLE OVER GIVEN TIMERANGE IN SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START TIME OF SEARCH Time in soundfile to start search for a maximum.\n");
		fprintf(stdout,"INFO: END TIME OF SEARCH     Time in soundfile to stop search for a maximum.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_LOUDCHAN):
		fprintf(stdout,"INFO: FIND LOUDEST CHANNEL IN A STEREO SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_FINDHOLE):
		fprintf(stdout,"INFO: FIND LARGEST LOW LEVEL HOLE IN A SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: THRESHOLD....hole only if level falls and stays below threshold.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_DIFF):
		fprintf(stdout,"INFO: COMPARE 2 SOUND,ANALYSIS,PITCH,TRANSPOSITION,ENVELOPE, OR FORMANT FILES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: THRESHOLD........................max permissible difference in data values:\n");
		fprintf(stdout,"INFO: CNT..............................max number of differences to accept (default 1).\n");
		fprintf(stdout,"INFO: IGNORE LENGTH DIFFERENCE.........continue comparing files anyway.\n");
		fprintf(stdout,"INFO: IGNORE CHANNEL COUNT DIFFERENCE..continue comparing files anyway.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB: This process works only with binary (non-text) files.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_CDIFF):
		fprintf(stdout,"INFO: COMPARE CHANNELS IN A STEREO SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: THRESHOLD..max permissible difference in data values.\n");
		fprintf(stdout,"INFO: CNT........MAX NUMBER of differences to accept (default 1).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB: The output sample display is counted in sample-pairs.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_PRNTSND):
		fprintf(stdout,"INFO: PRINT SOUND SAMPLE DATA TO A TEXTFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CARE!!! large quantities of data.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INFO_MUSUNITS):
		fprintf(stdout,"INFO:                                                                                           CONVERT BETWEEN DIFFERENT MUSICAL UNITS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INTERVAL   m2   = minor 2nd             2  = major 2nd\n");
		fprintf(stdout,"INFO:                    m3   = minor 3rd             3  = major 3rd\n");
		fprintf(stdout,"INFO:                    4    = perfect 4th           #4 = a tritone\n");
		fprintf(stdout,"INFO:                    5    = perfect 5th\n");
		fprintf(stdout,"INFO:                    m6   = minor 6th             6  = major 6th\n");
		fprintf(stdout,"INFO:                    m7   = minor 7th             7  = major 7th\n");
		fprintf(stdout,"INFO:                    +8     = an octave OR an octave shift up or down. The maximum range of intervals is up or down 2 octaves (a 15th).\n");
		fprintf(stdout,"INFO:                    up      = an upward interval (default).\n");
		fprintf(stdout,"INFO:                    down  = a downward interval.\n");
		fprintf(stdout,"INFO:                    Intervals may also be displaced by quartertones.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: QTONE        +  = a quarter-tone further up.       - = a quarter-tone further down.        no = no quarter-tone displacement.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCH         As shown on the buttons.        Pitches may be displaced by quartertones.        Octave may be specified from the numeric pad.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NUMERIC    May be used to specify Midi value, Frequency, Frequency Ratio, Semitones, Octaves, Gain, Gain in dB, Timestretching factor, etc.\n");
		fprintf(stdout,"INFO:                    OR the octave in which a Pitch occurs.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: INPUT        The (possible) type(s) of data you are inputting.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT     The type of data which you wish to output.\n");
		fprintf(stdout,"INFO:                   When no output button is highlighted, click first on the relevant INPUT button.\n");
		fprintf(stdout,"INFO:                   Click on the appropriate output button to obtain the result.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                   Pitches are represented in the output by e.g. Ebu-2 or Ed3 where......\n");
		fprintf(stdout,"INFO:                   'b' = flat                  '#' = sharp                  'u' = up a quarter-tone                  'd' = down a quarter-tone\n");
		fprintf(stdout,"INFO:                   Numerals (-2, 3) represent the octave in which the note occurs. Octave 0 stretches from Middle C to just below the C above.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BARS        4.3 represents 4 bars and 3 beats\n");
		break;
	case(SYNTH_WAVE):
		fprintf(stdout,"INFO: GENERATE SIMPLE WAVEFORMS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SAMPLING RATE.......can be 48000, 24000, 44100, 22050, 32000, or 16000\n");
		fprintf(stdout,"INFO: NUMBER OF CHANNELS..can be 1, 2 or 4\n");
		fprintf(stdout,"INFO: DURATION............is duration of output snd, in seconds.\n");
		fprintf(stdout,"INFO: FREQUENCY...........of output sound, in Hz\n");
		fprintf(stdout,"INFO: AMPLITUDE...........of output sound: 0.0 < Range <= 1.0 (max & default).\n");
		fprintf(stdout,"INFO: WAVEFORM TABLESIZE..is size of table storing waveform: defaults to 256\n");
		fprintf(stdout,"INFO: ....................input value always rounded to multiple of 4.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MULTI_SYN):
		fprintf(stdout,"INFO: GENERATE CHORD OVER SIMPLE WAVEFORM\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHORD DATA is a list of (possibly fractional) MIDI values, OR a list of Frequency Values\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SAMPLING RATE.......can be 48000, 24000, 44100, 22050, 32000, or 16000\n");
		fprintf(stdout,"INFO: NUMBER OF CHANNELS..can be 1, 2 or 4\n");
		fprintf(stdout,"INFO: DURATION............is duration of output snd, in seconds.\n");
		fprintf(stdout,"INFO: AMPLITUDE...........of output sound: 0.0 < Range <= 1.0 (max & default).\n");
		fprintf(stdout,"INFO: WAVEFORM TABLESIZE..is size of table storing waveform: defaults to 4096\n");
		fprintf(stdout,"INFO: ....................input value always rounded to multiple of 4.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SYNTH_NOISE):
		fprintf(stdout,"INFO: GENERATE NOISE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SAMPLING RATE.......can be 48000, 24000, 44100, 22050, 32000, or 16000\n");
		fprintf(stdout,"INFO: NUMBER OF CHANNELS..can be 1, 2 or 4\n");
		fprintf(stdout,"INFO: DURATION............is duration of output snd, in seconds.\n");
		fprintf(stdout,"INFO: AMPLITUDE...........of output sound: 0.0 < Range <= 1.0 (max & default).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SYNTH_SIL):
		fprintf(stdout,"INFO: MAKE SILENT SOUNDFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SAMPLING RATE.......can be 48000, 24000, 44100, 22050, 32000, or 16000\n");
		fprintf(stdout,"INFO: NUMBER OF CHANNELS..can be 1, 2 or 4\n");
		fprintf(stdout,"INFO: DURATION............is duration of output snd, in seconds.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SYNTH_SPEC):
		fprintf(stdout,"INFO: MAKE STEREO FILE BY DEFINING SPECTRAL BANDS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION.........of output data files\n");
		fprintf(stdout,"INFO: CENTRE FREQUENCY.........Centre of the synthesized band\n");
		fprintf(stdout,"INFO: BAND SPREAD.... width of band, in Hz, or as a transposition ratio.\n");
		fprintf(stdout,"INFO: BAND FOCUS (MAX).... maximum tightness of the band.\n");
		fprintf(stdout,"INFO: BAND FOCUS (MIN).....minimum tightness of band. If different from max,\n");
		fprintf(stdout,"INFO:              band tightness varies at random between the two.\n");
		fprintf(stdout,"INFO: TIME VARIATION.....extent to which band components fluctuate with time.\n");
		fprintf(stdout,"INFO: SAMPLE RATE........sample rate of output audio file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPREAD_AS_TRANSPOSITION_RATIO......(default, a Hz bandwidth)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(INSERTSIL_MANY):
		fprintf(stdout,"INFO: PUT (SEVERAL) SILENCING MASKS IN AN EXISTING SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME IN SECONDS..........Specify time in seconds.\n");
		fprintf(stdout,"INFO: TIME AS SAMPLE COUNT.....Specify time as sample count (rounded to multiples of channel-cnt).\n");
		fprintf(stdout,"INFO: TIME AS GROUPED SAMPLES..Specify time as grouped-sample count (e.g. 3 = 3 stereo-pairs).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXCISEFILE..is a texfile with (paired) start & end times of masks\n");
		fprintf(stdout,"INFO: ............These must be in increasing time order.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPLICELEN...splice window in MS (default: %.0lf)\n",EDIT_SPLICELEN);
		fprintf(stdout,"INFO: \n");
		break;
	case(RANDCUTS):
		fprintf(stdout,"INFO: CUT FILE RANDOMLY INTO CHUNKS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        AVERAGE CHUNKLENGTH..average length of chunks to cut & permute.\n");
		fprintf(stdout,"INFO:        SCATTERING..........randomisation of cuts: default 1.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(RANDCHUNKS):
		fprintf(stdout,"INFO: CUT SEVERAL CHUNKS FROM A SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CHUNKCNT..is the number of chunks to cut\n");
		fprintf(stdout,"INFO: MINCHUNK..is the length of the smallest chunk permitted\n");
		fprintf(stdout,"INFO: MAXCHUNK..is the length of the largest chunk permitted\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: LINEAR DISTRIBUTION...more regular distribution of sizes \n");
		fprintf(stdout,"INFO: ALL BEGIN AT SOUND START..all chunks start at start of sound \n");
		break;
	case(TE_3):
		fprintf(stdout,"INFO:                                                                         POSSIBLE OPERATIONS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: There are 5 distinct ways to use the Table Editor, plus some additional options.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) SELECT A FILE CONTAINING COLUMNS OF DATA: MANIPULATE THE DATA IN A CHOSEN COLUMN.\n");
		fprintf(stdout,"INFO: 2) CREATE A COLUMN OF DATA FROM SCRATCH.\n");
		fprintf(stdout,"INFO: 3) CREATE A TABLE OF DATA FROM SCRATCH.\n");
		fprintf(stdout,"INFO: 4) COMBINE THE DATA IN TWO DIFFERENT COLUMNS\n");
		fprintf(stdout,"INFO: 5) COMBINE THE DATA IN TWO DIFFERENT TABLES\n");
		fprintf(stdout,"INFO: +) EDIT OR TEST DATA, OR FIND PARTICULAR ITEMS, IN COLUMNS OF DATA\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: These are described below.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) SELECT A FILE CONTAINING COLUMNS OF DATA: MANIPULATE THE DATA IN A CHOSEN COLUMN.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         a) Choose a file from those listed in the 'FILES' list, by clicking on it.\n");
		fprintf(stdout,"INFO:               It will be displayed in the 'INPUT TABLE' display.\n");
		fprintf(stdout,"INFO:               1) If NO FILES are listed, this means you have NO (appropriate) textfiles listed on the workspace.\n");
		fprintf(stdout,"INFO:               2) If your file IS on the workspace, but is NOT LISTED here, it may have the wrong kind of data.\n");
		fprintf(stdout,"INFO:                     In particular, if your file does not have columns of data with the same number of items\n");
		fprintf(stdout,"INFO:                     in every column, Try switching to 'Free Text Mode'.\n");
		fprintf(stdout,"INFO:                     If this does not bring up your file, the Table Editor cannot handle it.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         b) Select a column from the file, by entering a column number and pressing OK,\n");
		fprintf(stdout,"INFO:               on the 'INPUT TABLE' display.\n");
		fprintf(stdout,"INFO:               1) The column will normally be displayed in COLUMN IN.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         c) Select where you want the RESULT of the operation to go.\n");
		fprintf(stdout,"INFO:               1) Normally the result will be displayed in COLUMN OUT.\n");
		fprintf(stdout,"INFO:               2) Select 'Result HERE' to put the result in COLUMN IN, overwriting the original.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         d) Select an operation from one of the menus.\n");
		fprintf(stdout,"INFO:               1) You may also need to enter a parameter (at N) or several parameters\n");
		fprintf(stdout,"INFO:                     (in which case a dialogue box will appear).\n");
		fprintf(stdout,"INFO:               2) If the operation is successful, a modified column should appear.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         e) If you are not satisfied with the result, choose a different parameter value, or a different process from the menus.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         f) IF you are happy with the result, you can save it to a table.\n");
		fprintf(stdout,"INFO:               1) You can keep just the column, as it is.\n");
		fprintf(stdout,"INFO:               2) You can replace the column you got from the original table, inside that table.\n");
		fprintf(stdout,"INFO:               3) You can replace some other column in the original table.\n");
		fprintf(stdout,"INFO:               4) You can insert the column as a NEW column, in the original table.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         g) You can select further columns and process them in similar ways.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         h) You can put the resulting columns into either the ORIGINAL table (still displayed at left).\n");
		fprintf(stdout,"INFO:               or into the NEW table you are building.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         i) Save the New table you have made, by giving it a name.\n");
		fprintf(stdout,"INFO:               1) You may save the whole table, as is.\n");
		fprintf(stdout,"INFO:               2) You may save each column of the table to a separate file.\n");
		fprintf(stdout,"INFO:               3) You may save each row of the table to a separate file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         j) You can also RECYCLE the table, from the OUTPUT TABLE display to the INPUT TABLE.\n");
		fprintf(stdout,"INFO:               N.B. You must be in 'File to Table' mode to do this.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 2) CREATE A COLUMN OF DATA FROM SCRATCH.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         a) Select a process from the CREATE or CREATE2 menu.\n");
		fprintf(stdout,"INFO:               1) You may also need to enter a parameter (at N) or several parameters\n");
		fprintf(stdout,"INFO:                     (in which case a dialogue box will appear).\n");
		fprintf(stdout,"INFO:               2) If the operation is successful, a column should appear in COLUMN OUT.\n");
		fprintf(stdout,"INFO:               3) If the operation fails, a message will be displayed.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         b) You can force the column to be created in COLUMN IN, by selecting 'Result HERE'.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         c) You can transform the column with processes selected from the menus, as described above.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         d) You can save the resulting column as a table. (as described above)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         e) You can create further columns and ADD then as new columns to the OUTPUT TABLE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         f) You can save the output tabe, as described above.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 3) CREATE A TABLE OF DATA FROM SCRATCH.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         a) Select a process from the CREATE options in the TABLES menu.\n");
		fprintf(stdout,"INFO:               Then write values (numeric or text) into a new table.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         b) You can now use the new table in the normal way described above.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 4) COMBINE THE DATA IN TWO DIFFERENT COLUMNS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         a) If you have data in both COLUMN IN and COLUMN OUT displays, you can combine their data.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         b) If you have data in COLUMN IN,\n");
		fprintf(stdout,"INFO:               you can get a single column of data DIRECTLY  FROM A FILE, into COLUMN OUT,\n");
		fprintf(stdout,"INFO:               by selecting 'File to column output' mode,\n");
		fprintf(stdout,"INFO:               then selecting a file (from the FILES list) which contains JUST ONE column of data.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:               (Be sure to switch back to 'File to Table' mode afterwards).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         c) Select a process from the COMBINE or BRK menu.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         d) The result will usually appear in the OUTPUT TABLE,\n");
		fprintf(stdout,"INFO:                and you can treat this in the usual ways (see above).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         e) Some COMBINE options write their result into one of the column displays,\n");
		fprintf(stdout,"INFO:                (COLUMN IN or OUT depending on whether you have selected 'Result HERE'\n");
		fprintf(stdout,"INFO:                or 'Result to OUTPUT). overwriting the original data,\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                You can treat this resulting column in the usual ways.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 5) COMBINE THE DATA IN TWO DIFFERENT TABLES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         a) Select Multiple Files mode.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         b) Select files from the FILES listing.\n");
		fprintf(stdout,"INFO:                1) Their NAMES will be listed in the OUTPUT TABLE  display.\n");
		fprintf(stdout,"INFO:                2) As each one is selected you will see its contents in INPUT TABLE.\n");
		fprintf(stdout,"INFO:                3) You can de-select a file: click on its name in OUTPUT TABLE display.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         c) Select a process from the JOIN menu.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         d) The result of combining the tables will now appear in the OUTPUT TABLE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         e) It is possible to use the JOIN menu to create Vectored Batchfiles (see JOIN menu\n");
		fprintf(stdout,"INFO:                for further information). In this case, there is the possibility to\n");
		fprintf(stdout,"INFO:                save the Output Table as a BATCH FILE (the appropriate button will be highlighted).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ----------------------------------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: +) EDIT OR TEST DATA, OR FIND PARTICULAR ITEMS, IN COLUMNS OF DATA\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         a) Use the EDIT IN, EDIT OUT, AT CURSOR, FIND or TEST menus.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_2):
		fprintf(stdout,"INFO:                                                 MENU FUNCTIONS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MOST FUNCTIONS convert values in COLUMN IN to new values.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         a) Usually the new values appear in COLUMN OUT.\n");
		fprintf(stdout,"INFO:         b) You can perform multiple operations on column data,\n");
		fprintf(stdout,"INFO:               using 'Copy to IN' to recycle the COLUMN OUT data back to COLUMN IN.\n");
		fprintf(stdout,"INFO:         c) You can force results to appear in COLUMN IN (overwriting original values),\n");
		fprintf(stdout,"INFO:               by selecting 'Result HERE'.\n");
		fprintf(stdout,"INFO:               You can then work 'in situ' in COLUMN IN, overwriting the original data as you go.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         d) You can also swap around the COLUMN IN & COLUMN OUT data.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: CREATE and CREATE2 Menu functions create values in the Column display you select\n");
		fprintf(stdout,"INFO:         ('Result HERE' or 'Result to OUT').\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: COMBINE Menu functions (and some BRK functions) combine values in COLUMN IN and OUT displays.\n");
		fprintf(stdout,"INFO:         The result is placed in the New Table display, unless otherwise stated.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TABLES Menu functions act directly on TABLE INPUT display, giving the result in TABLE OUTPUT.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: JOIN Menu functions combine data directly from FILES into the OUTPUT TABLE display.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BRK Menu functions are designed for use with breakpoint file data.\n");
		fprintf(stdout,"INFO:         They only become active when the input table is a breakpoint file.\n");
		fprintf(stdout,"INFO:         However, most other functions can be applied to the values in such files.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVEL Menu functions are designed for use with normalised envelope file data.\n");
		fprintf(stdout,"INFO:         They only become active when input file is such.\n");
		fprintf(stdout,"INFO:         However, many other functions can be applied to the values in such file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEQ Menu functions are designed for use with sequencing file data (triples of time,transposition,level).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_4):
		fprintf(stdout,"INFO:                                             PARAMETERS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Most functions take a parameter (N).\n");
		fprintf(stdout,"INFO: Some functions take no parameter (any value you enter is ignored).\n");
		fprintf(stdout,"INFO: Some functions work with or without a parameter.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Some functions take a 2nd parameter in the 'Threshold' box.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Some functions take several parameters (x1,x2 etc.).\n");
		fprintf(stdout,"INFO: A special entry box will appear for you to enter these values.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Each process checks parameter ranges, and advises if you are outside the limits.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_5):
		fprintf(stdout,"INFO:                                                                          THRESHOLD\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: THRESHOLD is either a special extra 'threshold' value, or a 2nd parameter to a process.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MATHS Menu Functions Add, Multiply, Divide, Find Reciprocals, and Raise to a Power\n");
		fprintf(stdout,"INFO:         can be applied solely to values in input above or below a threshold value.\n");
		fprintf(stdout,"INFO:         Other values remaining unaffected.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: COMBINE Menu's search for values Equal to an input parameter, (and one or two other functions)\n");
		fprintf(stdout,"INFO:         may use the threshold value as the maximum error allowed in assessing the equality of values.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: One or two functions take Threshold values as a parameter (e.g. SPAN functions in CREATE2).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Most functions ignore the threshold value.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_1):
		fprintf(stdout,"INFO:                                     FILE TO TABLE \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Contents of the selected file are listed in the TABLE INPUT, on the left.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                              FILE TO COLUMN OUTPUT ('File->Col' on MAC)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Data from file selected from filelist goes directly to COLUMN OUT display,\n");
		fprintf(stdout,"INFO: but ONLY if it contains just a single column of data.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                               MULTIPLE FILES ('Many Files' on MAC)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: File selected from the filelist, which must contain one or more columns of data,\n");
		fprintf(stdout,"INFO: can be combined directly into multiple column tables, using the JOIN menu.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                                     FREE TEXT MODE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Free Text mode handles most kinds of text input.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: This contrasts with the normal mode of operation, which handles only textfiles in which...\n");
		fprintf(stdout,"INFO:         a) data is aligned in columns.\n");
		fprintf(stdout,"INFO:         b) each column contains the same number of entries.\n");
		fprintf(stdout,"INFO:         c) All the entries in any one column are of the same type (e.g. numeric, dB vals, text).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Free Text mode can be used to edit files with comment-lines, or mixfiles with lines of different lengths,\n");
		fprintf(stdout,"INFO: or Csound scores with 'e' and 's' lines.\n");
		break;
	case(TE_14):
		fprintf(stdout,"INFO:                                     CHANGE SLOPE BY FACTOR\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Assumes input represents a graph of values. Changes the slope of the graph.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_6):
		fprintf(stdout,"INFO:                            CREATE X1 STEPS IN INTERVAL BETWEEN X2 AND X3, CURVATURE X4\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Curvature = 1 rises (or falls) evenly.\n");
		fprintf(stdout,"INFO: Curvature < 1 rises quicker at start or falls quicker at end.\n");
		fprintf(stdout,"INFO: Curvature > 1 rises quicker at end or falls quicker at start.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_7):
		fprintf(stdout,"INFO:                            ENTRYTIMES OF EVENTS OF GIVEN DURATIONS TO MAINTAIN A GIVEN DENSITY\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Input values are event durations.\n");
		fprintf(stdout,"INFO: Outputs are start times of successive events required to maintain the specified (vertical) density of events.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_8):
		fprintf(stdout,"INFO:                                     ISOLATE GROUPS OF EVENTS USING SEPARATION <= N (ASCENDING ONLY) \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: For an ascending sequence of times, items close together (separation <= N) are replaced by start and end time of the group,\n");
		fprintf(stdout,"INFO: while isolated items (separated from others by > N) are duplicated.\n");
		fprintf(stdout,"INFO: The resulting pairs-of-times serve to bracket these isolated event-groups (groups having 1 or more members).\n");
		fprintf(stdout,"INFO: This data might be 'SPANNED' to create an envelope.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                                     RANDOMLY DELETE X1 ITEMS,BUT <= X2 ADJACENT ITEMS: SETS OF ADJACENT ITEMS REMAINING <= X3\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: For controlled random deletion.\n");
		fprintf(stdout,"INFO: In a sequnce of events, randomly delete X1 items. Ensure that no more than X2 adjacent items are deleted.\n");
		fprintf(stdout,"INFO: Ensure that the remaining sets of undeleted items are no longer than x3.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_9):
		fprintf(stdout,"INFO:                                                       OVERLAP\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Time by which each event entry in a sequence overlaps the previous event.\n");
		fprintf(stdout,"INFO: e.g. overlap = splice-length when items edited together.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_10):
		fprintf(stdout,"INFO:                                                       PARTITIONS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You can partition a set into subsets ....\n");
		fprintf(stdout,"INFO: For example, you have a set of 144 values in column1.\n");
		fprintf(stdout,"INFO: Generate a column2 (with 144 entries) using the values 1,2 & 3 distributed at random.\n");
		fprintf(stdout,"INFO: (See the CREATE menu).\n");
		fprintf(stdout,"INFO: Use the random positions of the '1's ('2's and '3's) to select 3 random subsets from the original set.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_11):
		fprintf(stdout,"INFO:                                                 RAISE NEGATIVE VALS TO POWER\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Negative vals raised to a power are TREATED IN A SPECIAL WAY.\n");
		fprintf(stdout,"INFO: e.g. value -4 raised to the power of 3  becomes -64 i.e. minus (4-to-the-power-of-3).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_21):
		fprintf(stdout,"INFO:                                     RANDOMISATION\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Imagine the items spaced out evenly.\n");
		fprintf(stdout,"INFO: Each sits in a local space stretching from the midpoint between it and its lower neighbour,\n");
		fprintf(stdout,"INFO: to the midpoint between it and its upper neighbour. (first and last points are handled differently).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Randomisation 0         Creates no randomisation of these original (equal-spaced) positions.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Randomisation 1         Each item can appear anywhere in its local space.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Randomisation > 0 < 1   Each item has its position randomised within its local space.\n");
		fprintf(stdout,"INFO:                                                the randomisation increases with higher values.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Randomisation > 1           If the randomisation is N, each group of N items is placed at random\n");
		fprintf(stdout,"INFO:                                                in the TOTAL space occupied by their N adjacent local spaces.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_12):
		fprintf(stdout,"INFO:                                     RANK\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Lists each different-value item once only,\n");
		fprintf(stdout,"INFO: placing most frequently occuring items at top of list,\n");
		fprintf(stdout,"INFO: down to the least frequent, at the foot of the list.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_13):
		fprintf(stdout,"INFO:                                                                         SCATTER VALUES OVER A QUANTISED GRID\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                       X1 VALS, QUANTISED OVER X2, SPREAD IN INTERVAL X3, WITH RANDOMISATION X4\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: e.g. place a set of X1 accents within a duration x3. The accents must occur ON THE BEAT (defined by quantisation time X2).\n");
		fprintf(stdout,"INFO: The accents are to be placed randomly, with a degree of randomness specified by X4.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IF the randomness X4 <= 1 :      Imagine the duration divided into X1 EQUAL chunks.\n");
		fprintf(stdout,"INFO: puts 1 event in each chunk, scattered away from that chunk's starttime by up to half distance to next chunk-starttime in either direction.\n");
		fprintf(stdout,"INFO: Randomness 0 gives no scatter (acents are regular), Randomness 1 gives maximum scatter of this type.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: If the randomness X4 > 1 (where X4 is rounded to nearest integer) :       Imagine the duration divided into N = X1/X4  EQUAL large chunks.\n");
		fprintf(stdout,"INFO: scatters each succesive group of X4 events randomly over the whole duration of the next N-length chunk.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                       X1 RANDOM VALS QUANTISED OVER X2: MIN OF X3, MAX OF X4, BETWEEN EACH INPUT COL PAIR\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: e.g. Place a set of (x1) accents at random. The accents must fall ON THE BEAT (defined by quantisation x2).\n");
		fprintf(stdout,"INFO: The accents must fall only in time slots defined by successive pairs of values in the input column.\n");
		fprintf(stdout,"INFO: There must be at least x3 and no more than x4 such accents in each time slot.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_15):
		fprintf(stdout,"INFO:                                                                         SPAN VALUES BY OTHERS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                       EACH VALUE (T) GOES TO (T-THRESHOLD,T+N+THRESHOLD)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: e.g. Create the time-sequence for an an envelope with which to isolate individual events of roughly equal length.\n");
		fprintf(stdout,"INFO: Threshold is splice length, N the typical event length. Use an alternating sequence (0110011..) to generate the envelope.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                       SPAN: EACH PAIR (T1,T2) GOES TO (T1-THRESHOLD,T1,T2,T2+N+THRESHOLD) \n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: e.g. Create the time-sequence for an an envelope with which to isolate groups of events, (individual) events being of roughly equal length.\n");
		fprintf(stdout,"INFO: First event in group starts at T1 and last event in group starts at T2. Threshold is splice length, N the typical (individual) event length.\n");
		fprintf(stdout,"INFO: Associate the new times created with an alternating sequence (0110011...) to generate the envelope. This creates an envelope\n");
		fprintf(stdout,"INFO: rising at each T1-threshold to max at T1, and falling at T2+N, to min at T2+N+threshold. (All (time) values created are >= 0.)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_16):
		fprintf(stdout,"INFO:                                                                         STACK VALUES FROM ZERO\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Assume input lists durations of successive events. Output gives start time of each event in such a list.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_17):
		fprintf(stdout,"INFO:                                                                         SUM THE ABSOLUTE DIFFERENCES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Use, e.g., to find duration of a zigzagging process, from a list of times at which the source-read process reverses.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_18):
		fprintf(stdout,"INFO:                                                                         SUPERIMPOSE ENVELOPES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: e.g. Extract part of a sound, treat it, and reinsert it in the original at the same place.\n");
		fprintf(stdout,"INFO: The rise and fall envelope of the inserted sound needs to be mirrored in the envelope of the original sound, at the insertion point.\n");
		fprintf(stdout,"INFO: This inverted envelope can be superimposed on any existing original-file envelope, using the 'superimpose inverted envelope' option.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: This process works only with NORMALISED envelopes (envelope levels lie between 0 and 1).\n");
		fprintf(stdout,"INFO: In general, an inserted envelope should start and end with level 0 or 1.\n");
		fprintf(stdout,"INFO: If it does not, its start level (or its inverse) will be imposed on all time points occuring before the insertion starttime.\n");
		fprintf(stdout,"INFO: and its end level (or its inverse) on all time points occuring after the insertion endtime.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_19):
		fprintf(stdout,"INFO:                                                                         TEMPER\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: With no parameter, adjust data onto standard (12 semitones per octave) equal-temperament scale.\n");
		fprintf(stdout,"INFO: With e.g. parameter 9, adjust data onto a 9-steps-per-octave equal-temperament scale.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_20):
		fprintf(stdout,"INFO:                                                     TIME SEQUENCE ,DURATION X1, FROM MIN STEP X2 TO MAX X3\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Create a sequence of successive time points of total duration x1. Time-step between successive points begins as x2 and ends as x3.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_22):
		fprintf(stdout,"INFO:                                                     VECTORED BATCHFILES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: A Batchfile is a textfile containing several lines: each line is a command to run a program.\n");
		fprintf(stdout,"INFO: Running the batchfile runs each program in turn.\n");
		fprintf(stdout,"INFO: Batchfiles can be run from the Workspace page.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: A Vectored Batchfile is either:\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) a Batchfile which applies the SAME process to the SAME input file on each line,\n");
		fprintf(stdout,"INFO:         using a different value for ONE (or more) of the parameters, in each line, OR....\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 2) a Batchfile which applies the SAME process to a DIFFERENT input file on each line,\n");
		fprintf(stdout,"INFO:         using a different value for ONE (or more) of the parameters, in each line.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The list of the different values for the SAME parameter, is the PARAMETER VECTOR.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_23):
		fprintf(stdout,"INFO:                                                  TO CREATE A VECTORED BATCHFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (1) On the Workspace, choose ONE of the files you want to process, and set up the process on the PARAMETERS PAGE,\n");
		fprintf(stdout,"INFO:         but INSTEAD OF RUNNING IT, save the process AS A BATCHFILE.\n");
		fprintf(stdout,"INFO:         (This creates an elementary batchfile from which you will generate the Vectored Batchfile).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (2) Now put all the file(s) you want to process into the Chosen Files list on the Workspace.\n");
		fprintf(stdout,"INFO:         (Lets assume you want to generate 6 processes). There are TWO DIFFERENT OPTIONS.........\n");
		fprintf(stdout,"INFO:         (a) List 1 file FOR EACH parameter value you intend to use, so you will have 6 infiles with 6 vector-values.\n");
		fprintf(stdout,"INFO:                   the 1st file is processed using the 1st value in the vector , the 2nd file using the 2nd value in the vector, and so on.\n");
		fprintf(stdout,"INFO:         (b) List JUST ONE file: in this case the 6 parameter-vector values will be applied, in turn, to the SAME file\n");
		fprintf(stdout,"INFO:                   to produce 6 separate outputs from the same input file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (3) In the TABLE EDITOR, use the CREATE menu to generate a list of values for ONE parameter (the parameter VECTOR), and save this file.\n");
		fprintf(stdout,"INFO:         (in our example, the file will contain 6 values).\n");
		fprintf(stdout,"INFO:         You can create vectors for more than one parameter of the batchfile you are working on,\n");
		fprintf(stdout,"INFO:         but every one of these vectors must have the SAME NUMBER OF ENTRIES. (In our example they will all have 6 values).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (4) Switch the Table Editor to Multiple Files mode.\n");
		fprintf(stdout,"INFO: (5) Select the Batchfile you just made, followed by the Vector file(s) you just created.\n");
		fprintf(stdout,"INFO: (6) Select 'Create a Vectored Batchfile' from the JOIN menu.\n");
		fprintf(stdout,"INFO: \n");
	case(TE_24):
		fprintf(stdout,"INFO:                                                     PARAMETERS, SAVING AND RUNNING\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: (7) You will be shown a parameter entry box. Consult the display at the foot of the parameter entry box, and enter.....\n");
		fprintf(stdout,"INFO:         (a) The batchfile column-number having the INPUT FILE.\n");
		fprintf(stdout,"INFO:         (b) The batchfile column-number having the OUTPUT FILE.\n");
		fprintf(stdout,"INFO:         (c) The batchfile column-number of (each) PARAMETER you are replacing with a vector.\n");
		fprintf(stdout,"INFO:                  If there is more than one vectored parameter, the column numbers for each of the vectored-parameters need to be entered\n");
		fprintf(stdout,"INFO:                  IN THE SAME ORDER as the parameter vector-files you have listed on the Table Editor.\n");
		fprintf(stdout,"INFO: (8) ***** SAVE the resulting table AS A BATCHFILE !!!!! *****\n");
		fprintf(stdout,"INFO: (9) Run the resulting batchfile from the Workspace.\n");
		break;
	case(TE_25):
		fprintf(stdout,"INFO:                                                     WARPING TIMES OR DATA\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Enter the File with the Data (DATAFILE) followed by the Warping File (WARPFILE).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The WARPFILE is a Breakpoint File of time-value pairs, where times MUST BEGIN AT ZERO.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TO WARP TIMES:\n");
		fprintf(stdout,"INFO: 1)  Times in Warpfile correspond to (prewarped) times in Datafile.\n");
		fprintf(stdout,"INFO: 2)  Warp Values must be greater than zero.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TO WARP VALUES IN AN EXISTING BREAKPOINT FILE:\n");
		fprintf(stdout,"INFO: 1)  Times in Warpfile correspond to times in Datafile.\n");
		fprintf(stdout,"INFO: 2)  Warp Values can take any value.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TO WARP VALUES IN AN EXISTING LIST OF VALUES:\n");
		fprintf(stdout,"INFO: 1) Range of times in Warpfile is arbitrary, and will be mapped to length of the data in Datafile.\n");
		fprintf(stdout,"INFO: 2) Warp Values can take any value.\n");
		break;
	case(TE_26):
		fprintf(stdout,"INFO:                                                                  ******* MUSIC WORKPAD *******\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) TO GET (&/OR REMOVE) FILES\n");
		fprintf(stdout,"INFO:           select file from right hand display, and press 'GET' or 'GET & REMOVE'\n");
		fprintf(stdout,"INFO:           **** 'GET' IS NOT CUMULATIVE : do a 'PUT' before selecting more files ****\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 2) TO PUT FILES INTO A LIST\n");
		fprintf(stdout,"INFO:           You must 'GET' files first.\n");
		fprintf(stdout,"INFO:           Select a position in the Right Hand display, and press 'PUT FILES'\n");
		fprintf(stdout,"INFO:           (with NO POSITION selected, files go to the END of the display)\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_27):
		fprintf(stdout,"INFO: The MUSIC TESTBED has various higher level facilities for organising musical material.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1)  BACKGROUND LISTINGS.\n");
		fprintf(stdout,"INFO:           Files which you feel are musically related, can be gathered together in a BACKGROUND LISTING (B-List).\n");
		fprintf(stdout,"INFO:           These B-Lists are NOT mutually exclusive i.e. any file can be listed in any number of B-lists.\n");
		fprintf(stdout,"INFO:           Files in a B-List can be LOADED ONTO THE WORKSPACE AS A SET, so they can be worked on as a group.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:           The MUSIC WORKPAD allows you to sort and reorganise the sound materials you have previously stored in B-Lists.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 2)  INTERPOLATION WORKSHOP.\n");
		fprintf(stdout,"INFO:           Make sounds intermediate between two given sounds, by proportional mixing..\n");
		fprintf(stdout,"INFO:           The INTERPOLATION WORKSHOP provides flexible ways to do this and to assess the results (by listening).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 3)  NAME GAMES.\n");
		fprintf(stdout,"INFO:           Numerous operations may be performed upon SEGMENTS WITHIN FILENAMES.\n");
		fprintf(stdout,"INFO:           If these segments refer to processes applied to the named sound, this allows such processes to be ordered & organised.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 4)  PITCH MARKS.\n");
		fprintf(stdout,"INFO:           A sound file may be assigned a PITCH MARK, indicating its pitch or pitches.\n");
		fprintf(stdout,"INFO:           Pitch Marks may be compared, transferred from one sound to another, etc. etc..\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 5)  PROPERTIES FILES.\n");
		fprintf(stdout,"INFO:           Soundfiles can be assigned any number of (user-defined) properties, and these listed in a PROPERTIES FILE.\n");
		fprintf(stdout,"INFO:           Property Files can be used to select sounds (e.g. those sharing one or more property) etc.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 7)  SKETCH SCORE\n");
		fprintf(stdout,"INFO:           The SKETCH SCORE allows you drag sounds about on a page, to decide on (and rememeber) a rough sequence of events.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_28):
		fprintf(stdout,"INFO:                                                              ******* BACKGROUND LISTINGS *******\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Background listings only accept files which are NOT in the CDP base directory (back them up first).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: B-lists allow files to be grouped together 'experimentally' while you test out musical ideas.\n");
		fprintf(stdout,"INFO: Files in the same B-List can come from DIFFERENT directories.\n");
		fprintf(stdout,"INFO: ALSO, Placing a file in one B-list does not preclude it from being placed in another.\n");
		fprintf(stdout,"INFO: Hence different ideas about how sounds are (to be) grouped can be tested, remembered, and recalled.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Sounds in B-Lists Can be LOADED ONTO THE WORKSPACE AS A SET (or individually),\n");
		fprintf(stdout,"INFO: either adding to what is already on the Workspace, or replacing it,\n");
		fprintf(stdout,"INFO: so that these B-listed sounds can be worked on as a group.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: A sound in a B-List may be assigned a PITCHMARK, indicating the principle pitch(es) of the sound.\n");
		fprintf(stdout,"INFO: (a Pitchmark is ASSOCIATED WITH THE SOUND, so can be viewed from any B-list the sound occurs in, or from the Workspace.)\n");
		fprintf(stdout,"INFO: Pitchmarks are preserved when sounds are copied (e.g. to a new directory),\n");
		fprintf(stdout,"INFO: and can themselves be copied from one sound to another.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PITCHMARKS CAN BE COMPARED, pairwise or with the Pitchmark of every other Pitchmarked sound.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_29):
		fprintf(stdout,"INFO:                                                                  ******* MUSIC WORKPAD *******\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The MUSIC WORKPAD enables you to CREATE & DESTROY B-LISTS, GET FILES to them, and REORGANISE MATERIALS amongst them.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You may work with existing B-lists, or Create new ones.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You may Grab files from the Workspace, or from any specified directory on your system, to put in a B-list.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Files may be MOVED TO AND FROM DIFFERENT B-LISTS, or reordered within or deleted from a B-List, using 'GET' and 'PUT'\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You may SEARCH ALL THE B-LISTS for files with similar names, or for files from the same directory,\n");
		fprintf(stdout,"INFO:           (e.g. to discover what other B-lists you have placed a particular file in).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You may LOAD THE DIRECTORY of a selected file onto the Workspace.\n");
		fprintf(stdout,"INFO:           (e.g. to discover other related sounds ....assuming you stored related sounds in the same directory.)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You may SEARCH THE SOUND LOOM LOGS, to discover how a particular file was made.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You may VIEW THE PITCHMARK of any file that has one, and MAKE COMPARISONS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You may LOAD a file, or the directory of the file, ONTO THE WORKSPACE, for further work.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_30):
		fprintf(stdout,"INFO:                                                                  ******* SKETCH SCORE *******\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The SKETCH SCORE enables you to place sounds on a large 'Score' page, arrange them in sequence, and play the whole sequence.\n");
		fprintf(stdout,"INFO: You can also write Descriptive Comments on the Score.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:         1) Files can be grabbed from Background Listings,from the Workspace, of from elsewhere and positioned on the score.\n");
		fprintf(stdout,"INFO:         2) Files may be placed anywhere on this score, dragged from one position to another, or removed.\n");
		fprintf(stdout,"INFO:         3) Any single file on the Score can be Played, by clicking on it.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The Sequence of files on the score (or a specified part of it) can be joined together and\n");
		fprintf(stdout,"INFO:          Played. You can use the complete sounds OR JUST A SMALL PART OF EACH.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The sequence of files (or a specified part of it) can be .....\n");
		fprintf(stdout,"INFO:         1) Saved to a temporary mixfile, ready for more detailed work.\n");
		fprintf(stdout,"INFO:         2) Grabbed to the Chosen Files list on the Workspace, for further work.\n");
		fprintf(stdout,"INFO:         3) Saved to a new, or an existing, Background Listing.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The SKETCH SCORE is a 'pre-sequencer', rather than a true sequencer or mixing environment.\n");
		fprintf(stdout,"INFO: It allows you to quickly test ideas before committing to a real mix.\n");
		fprintf(stdout,"INFO: It is intended as an aid in decision-making about the larger-scale form of a piece, once\n");
		fprintf(stdout,"INFO: substantial chunks of material have already been made which need to be appropriately ordered.\n");
		fprintf(stdout,"INFO: You can quickly test ideas about the ultimate sequence of events \n");
		fprintf(stdout,"INFO: by joining just a small part of each large file and listening to the result.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NB: Scores are always backed up in the last state in which they contained sounds.\n");
		fprintf(stdout,"INFO:         If you exit from an EMPTY score, then recall it, the last sounds which appeared on it will reapear.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(TE_31):
		fprintf(stdout,"INFO:                                                          ******* INTERPOLATION WORKSHOP *******\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: The INTERPOLATION WORKSHOP uses the program 'submix inbetween' to generate sounds intermediate between two given sounds,\n");
		fprintf(stdout,"INFO: through a simple mixing process. True spectral interpolation happens only if the 2 sounds are synchronised at zero-crossings\n");
		fprintf(stdout,"INFO: (as happens with the CDP 'DISTORT' processes).  However, aurally convincing results can be obtained with other sounds.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TO MAKE AN INTERPOLATION\n");
		fprintf(stdout,"INFO:         1) Select onto the Chosen Files list of the Workspace the two sounds you wish to interpolate between.\n");
		fprintf(stdout,"INFO:         2) Start the INTERPOLATION WORKSHOP : the two sounds will now appear on its own display panel.\n");
		fprintf(stdout,"INFO:         3) You can create intermediate sounds immediately (or at any time you have ONLY 2 sounds in this list) by...\n");
		fprintf(stdout,"INFO:                 a) Specifying how many intermediate sounds to make.\n");
		fprintf(stdout,"INFO:                 b) Giving those new sounds a (generic) name.\n");
		fprintf(stdout,"INFO:                 c) Specifying the interpolation skew.  (Use default value 1: if dissatisfied with the result, try a different value.)\n");
		fprintf(stdout,"INFO:                 d) Hitting the interpolate button.\n");
		fprintf(stdout,"INFO:         4) The newly created sounds will be listed in the panel BETWEEN the two original sounds.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: YOU CAN NOW LISTEN....\n");
		fprintf(stdout,"INFO:         a) To the whole listed sequence of sounds.\n");
		fprintf(stdout,"INFO:         b) To a sequence of sounds (or any individual sound) you select with the mouse.\n");
		fprintf(stdout,"INFO:         c) To the listed sequence of sounds, APART FROM those you select with the mouse.\n");
		fprintf(stdout,"INFO: YOU CAN DELETE...\n");
		fprintf(stdout,"INFO:         a) Particular sounds, selected with the mouse. (But you are prevented from deleting the ORIGINAL two sounds selected from the Workspace).\n");
		fprintf(stdout,"INFO:         b) The entire interpolation sequence you just made (e.g. in order to try different parameters for the interpolation).\n");
		fprintf(stdout,"INFO: YOU CAN MAKE ADDITIONAL INTERPOLATIONS between ANY ADJACENT PAIR of sounds on the list....\n");
		fprintf(stdout,"INFO:         a) Choose two adjacent sounds with the mouse.\n");
		fprintf(stdout,"INFO:         b) Proceed exactly as for the original interpolation.\n");
		fprintf(stdout,"INFO: AND YOU CAN FINISH by...\n");
		fprintf(stdout,"INFO:         a) CONCLUDING: retaining all the files remaining on the listing.\n");
		fprintf(stdout,"INFO:         b) QUITTING: Which deletes all the interpolated files you made (but NOT the original two sources).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ACC_STREAM):
		fprintf(stdout,"INFO: REPEAT A SOUND AT A SERIES OF SPECIFIED TIMES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        TIME OF EVENTS..times at which the sound will play.\n");
		fprintf(stdout,"INFO:        ATTENUATION.......level reduction (e.g. to accomodate attack overlaps).\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HF_PERM1):
    	fprintf(stdout,"INFO: GENERATE ALL CHORDS POSSIBLE FROM NOTES IN A GIVEN SET,\n");
    	fprintf(stdout,"INFO: RESTRICTING CHORDS TO WITHIN A GIVEN RANGE OF PITCH,\n");
    	fprintf(stdout,"INFO: AND USING EACH NOTE (OR ITS OCTAVE TRANSPOSITION) ONCE ONLY PER CHORD.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SOUND OUT................Outputs 1 soundfile of the chords.\n");
		fprintf(stdout,"INFO: SOUNDS OUT...............Outputs several soundfiles, chords grouped by the sort prodecure(s) you specify.\n");
		fprintf(stdout,"INFO: TEXT OUT ................Outputs list of chords described by their note names.\n");
		fprintf(stdout,"INFO: MIDI OUT ................Outputs list of chords described by the MIDI values of the notes in them.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Sound-out & Sounds-Out modes only....\n");
		fprintf(stdout,"INFO:        SAMPLE RATE OF THE SOUND OUTPUT\n");
		fprintf(stdout,"INFO:        DURATION OF EACH CHORD GENERATED (SECS)\n");
		fprintf(stdout,"INFO:        DURATION OF PAUSES BETWEEN CHORDS (SECS)\n");
		fprintf(stdout,"INFO: Sound-out only: ....\n");
		fprintf(stdout,"INFO:        DURATION OF PAUSES BETWEEN CHORD-GROUPS (SECS)\n");
		fprintf(stdout,"INFO: All modes....\n");
		fprintf(stdout,"INFO:        MIN NUMBER OF NOTES PER CHORD\n");
		fprintf(stdout,"INFO:        BOTTOM NOTE OF THE PITCH RANGE OF THE CHORDS\n");
		fprintf(stdout,"INFO:        OCTAVE IN WHICH THIS NOTE OCCURS...zero = octave upwards from Middle C\n");
		fprintf(stdout,"INFO:        TOP NOTE OF THE PITCH RANGE OF THE CHORDS\n");
		fprintf(stdout,"INFO:        OCTAVE IN WHICH THIS NOTE OCCURS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        SORT CHORDS BY   ....ROOT             Chord with lowest root note comes first.\n");
		fprintf(stdout,"INFO:                                        ....TOPNOTE          Chord with highest top note comes first.\n");
		fprintf(stdout,"INFO:                                        ....PITCHCLASS SET   Chords with same (8va equivalent) notes grouped together.\n");
		fprintf(stdout,"INFO:                                        ....CHORD TYPE       Chords of same interval structure grouped together.\n");
		fprintf(stdout,"INFO:                                        ....    1 of each:   only 1 representative of each chord retained.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        CHORDS ONLY OF SPECIFIED MIN NO OF NOTES\n");
		fprintf(stdout,"INFO:          .... Don't generate chords with more notes than minimum specified.\n");
		fprintf(stdout,"INFO:        SMALLEST SPAN FIRST (ELSE LARGEST) (inoperative with CHORD TYPE sorts)\n");
		fprintf(stdout,"INFO:          .... In each subgroup, put smallest span chord first (otherwise it goes last).\n");
		fprintf(stdout,"INFO:        SORT BY ALTERNATIVE METHOD (ELSE BY DENSITY) (inoperative with CHORD TYPE sorts)\n");
		fprintf(stdout,"INFO:          .... By default, chords in each subgroup are sorted by density.\n");
		fprintf(stdout,"INFO:          .... If flag is set,\n");
		fprintf(stdout,"INFO:          .... For ROOT or TOP NOTE sort, subgroups sorted by the way intervals are stacked inside chord.\n");
		fprintf(stdout,"INFO:          .... For PITCHCLASS SET sort, subgroups sorted by size of containing interval, then by density.\n");
		fprintf(stdout,"INFO:        ELIMINATE CHORDS DUPLICATED AT OCTAVES\n");
		fprintf(stdout,"INFO:          .... Where exactly same chord occurs in more than one octave, eliminate duplicates.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(HF_PERM2):
    	fprintf(stdout,"INFO: GENERATE ALL CHORDS POSSIBLE FROM MIDI VALUES IN A GIVEN SET,\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SOUND OUT................Outputs 1 soundfile of the chords.\n");
		fprintf(stdout,"INFO: SOUNDS OUT...............Outputs several soundfiles, chords grouped by the sort prodecure(s) you specify.\n");
		fprintf(stdout,"INFO: TEXT OUT ................Outputs list of chords described by their note names.\n");
		fprintf(stdout,"INFO: MIDI OUT ................Outputs list of chords described by the MIDI values of the notes in them.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Sound-out & Sounds-Out modes only....\n");
		fprintf(stdout,"INFO:        SAMPLE RATE OF THE SOUND OUTPUT\n");
		fprintf(stdout,"INFO:        DURATION OF EACH CHORD GENERATED (SECS)\n");
		fprintf(stdout,"INFO:        DURATION OF PAUSES BETWEEN CHORDS (SECS)\n");
		fprintf(stdout,"INFO: Sound-out only: ....\n");
		fprintf(stdout,"INFO:        DURATION OF PAUSES BETWEEN CHORD-GROUPS (SECS)\n");
		fprintf(stdout,"INFO: All modes....\n");
		fprintf(stdout,"INFO:        MIN NUMBER OF NOTES PER CHORD\n");
		fprintf(stdout,"INFO:        SORT CHORDS BY   ....ROOT             Chord with lowest root note comes first.\n");
		fprintf(stdout,"INFO:                                        ....TOPNOTE          Chord with highest top note comes first.\n");
		fprintf(stdout,"INFO:                                        ....PITCHCLASS SET   Chords with same (8va equivalent) notes grouped together.\n");
		fprintf(stdout,"INFO:                                        ....CHORD TYPE       Chords of same interval structure grouped together.\n");
		fprintf(stdout,"INFO:                                        ....    1 of each:   only 1 representative of each chord retained.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:        CHORDS ONLY OF SPECIFIED MIN NO OF NOTES\n");
		fprintf(stdout,"INFO:          .... Don't generate chords with more notes than minimum specified.\n");
		fprintf(stdout,"INFO:        SMALLEST SPAN FIRST (ELSE LARGEST) (inoperative with CHORD TYPE sorts)\n");
		fprintf(stdout,"INFO:          .... In each subgroup, put smallest span chord first (otherwise it goes last).\n");
		fprintf(stdout,"INFO:        SORT BY ALTERNATIVE METHOD (ELSE BY DENSITY) (inoperative with CHORD TYPE sorts)\n");
		fprintf(stdout,"INFO:          .... By default, chords in each subgroup are sorted by density.\n");
		fprintf(stdout,"INFO:          .... If flag is set,\n");
		fprintf(stdout,"INFO:          .... For ROOT or TOP NOTE sort, subgroups sorted by the way intervals are stacked inside chord.\n");
		fprintf(stdout,"INFO:          .... For PITCHCLASS SET sort, subgroups sorted by size of containing interval, then by density.\n");
		fprintf(stdout,"INFO:        ELIMINATE CHORDS DUPLICATED AT OCTAVES\n");
		fprintf(stdout,"INFO:          .... Where exactly same chord occurs in more than one octave, eliminate duplicates.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(DEL_PERM):
    	fprintf(stdout,"INFO: DELAY AND TRANSFORM EACH INPUT MIDI VALUE, CUMULATIVELY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO:    DELAY PERMUTATION\n");
		fprintf(stdout,"INFO:    ......list of pairs of values, in textfile\n");
		fprintf(stdout,"INFO:    ......1st value of the pair is a semitone transposition\n");
		fprintf(stdout,"INFO:    ......2nd value of pair is a time-multiplier of duration (<1)\n");
		fprintf(stdout,"INFO:    ......Sum of all time-multipliers must be equal to 1\n");
		fprintf(stdout,"INFO:    SAMPLE RATE              sample rate of the sound output\n");
		fprintf(stdout,"INFO:    INITIAL DURATION OF NOTES length of each input note, before it is transformed\n");
		fprintf(stdout,"INFO:    CYCLES OF PERMUTATION    number of times the permutation is recursively applied.\n");
		break;
	case(DEL_PERM2):
    	fprintf(stdout,"INFO: DELAY AND TRANSFORM INPUT SOUND (assumed to be at MIDI 60) AT INPUT MIDI VALUES, CUMULATIVELY.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO:    DELAY PERMUTATION\n");
		fprintf(stdout,"INFO:    ......list of pairs of values, in textfile\n");
		fprintf(stdout,"INFO:    ......1st value of the pair is a semitone transposition\n");
		fprintf(stdout,"INFO:    ......2nd value of pair is a time-multiplier of duration (<1)\n");
		fprintf(stdout,"INFO:    ......Sum of all time-multipliers must be equal to 1\n");
		fprintf(stdout,"INFO:    CYCLES OF PERMUTATION    number of times the permutation is recursively applied.\n");
		break;
	case(TWIXT):
    	fprintf(stdout,"INFO: SWITCH, AT GIVEN TIMES, BETWEEN SEVERAL FILES, AS THEY 'PLAY' IN PARALLEL.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
  		fprintf(stdout,"INFO: TIME-SEGMENTS IN SEQUENCE.........Proceed from first time-segment to 2nd to 3rd etc.\n");
    	fprintf(stdout,"INFO: TIME-SEGMENTS PERMUTED............Permute the sequence of time-segments.\n");
    	fprintf(stdout,"INFO: TIME-SEGMENTS AT RANDOM..........Chose any time-segment, at random.\n");
		fprintf(stdout,"INFO: TEST SWITCH TIMES....................Chops up first file (only) at the given times,\n");
		fprintf(stdout,"INFO: ............................................producing segments as separate output files.\n");
		fprintf(stdout,"INFO: ............................................to test accuracy of file segmentation times.\n");
		fprintf(stdout,"INFO: PREVIEW SOURCE1 ENVELOPE........Generate a view of the envelope of 1st file,\n");
		fprintf(stdout,"INFO: ............................................to permit choice of intelligent gating.\n");
		fprintf(stdout,"INFO: EXTRACT SWITCH TIMES..............Use intelligent gating to generate switch times from first file.\n");				   
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SWITCH TIMES ....... is a texfile containing times which divide the files into segments.\n");
		fprintf(stdout,"INFO:                                    Include time zero if you want start of files to be used as a segment.\n");
		fprintf(stdout,"INFO: SPLICE LENGTH (MS) ....... is (approx) length of splices used on segments, in milliseconds.\n");
		fprintf(stdout,"INFO: NUMBER OF SEGMENTS TO OUTPUT ....... (Only relevant with the random modes).\n");
		fprintf(stdout,"INFO: WEIGHTING OF FIRST FILE ....... First file occurs N times more often then other files.\n");
		fprintf(stdout,"INFO: RANDOM PERM OF FILES ....... Sequence of files chosen is randomly permuted..\n");
		fprintf(stdout,"INFO:                                    except that output always begins with first file in your list.\n");
		fprintf(stdout,"INFO:                                    (default: files taken in order given in chosen-files list.)\n");
		break;
	case(SPHINX):
    	fprintf(stdout,"INFO: SWITCH, AT GIVEN INPUT-FILE TIMES, BETWEEN SEVERAL FILES,\n");
    	fprintf(stdout,"INFO: BUT SWITCH-TIMES ASSOCIATED WITH EACH FILE ARE NOT NECESSARILY THE SAME.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
    	fprintf(stdout,"INFO:      IN TIME ORDER..................Proceed from 1st time-segment to 2nd to 3rd etc.\n");
    	fprintf(stdout,"INFO:      RANDOMLY REORDERED.......Permute the sequence of time-segments.\n");
    	fprintf(stdout,"INFO:      RANDOM CHOICE...............Chose any time-segment, at random.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:      SWITCH TIMES ....... is a texfile containing times which divide the files into segments.\n");
		fprintf(stdout,"INFO:                                Include zero if start of files to be used, and file endtime, if end of file to be used.\n");
		fprintf(stdout,"INFO:                                The 1st times in each file should all be on line 1.\n");
		fprintf(stdout,"INFO:                                The 2nd times in each file should all be on line 2.  ETC.....\n");
		fprintf(stdout,"INFO:                                Each file must have the SAME NUMBER of switch times.\n");
		fprintf(stdout,"INFO:      SPLICE LENGTH (MS) ....... is (approx) length of splices used on segments, in milliseconds.\n");
		fprintf(stdout,"INFO:      NUMBER OF SEGMENTS TO OUTPUT ....... (Only relevant with the random modes).\n");
		fprintf(stdout,"INFO:      WEIGHTING OF FIRST FILE ....... First file occurs N times more often then other files.\n");
		fprintf(stdout,"INFO:      RANDOM PERM OF FILES ....... File sequence randomly permuted (except 1st file always starts output)\n");
		fprintf(stdout,"INFO:                                (default: files taken in order given in chosen-files list.)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: GENERATING A DATA FILE FOR SPHINX ------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:      1) Run Mode PREVIEW SOURCE1 ENVELOPE and then EXTRACT SWITCH TIMES\n");
		fprintf(stdout,"INFO:                to automatically generate list of segment onsets for 1st file in your list.\n");
		fprintf(stdout,"INFO:      2) Run Mode TEST SWITCH TIMES to check segment onset times are good.\n");
		fprintf(stdout,"INFO:      3) IF NOT: Use 'Nudge Times' on Parameters page to modify (& test) segment onset times.\n");
		fprintf(stdout,"INFO:      4) Rotate the file-list on workspace, and generate the next edit-times file. ETC.\n");
		fprintf(stdout,"INFO:      5) Use the TABLE EDITOR in MULTIPLE FILES MODE to merge all these individual datafiles.\n");
		fprintf(stdout,"INFO:            a) Select the data files you have created from the listing at left,\n");
		fprintf(stdout,"INFO:            b) Use the JOIN menu, 'Put Cols of one file next to cols of another'\n");
		fprintf(stdout,"INFO:            c) Save resulting output table as your sphinx datafile.\n");
		break;
	case(NOISE_SUPRESS):
    	fprintf(stdout,"INFO: REPLACE NOISE CONSTITUENTS IN FILE BY SILENCE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SPLICE LENGTH (MS) for splice editing out noise.\n");
		fprintf(stdout,"INFO: MINIMUM NOISE FREQUENCY (HZ) frequency above which signal treated as potential noise.\n");
		fprintf(stdout,"INFO: MAXIMUM DURATION OF NOISE TO KEEP (MS)\n");
		fprintf(stdout,"INFO: MINIMUM DURATION OF TONE TO KEEP (MS)\n");
		fprintf(stdout,"INFO: RETAIN NOISE RATHER THAN TONE keeps only the noise components\n");
		break;
	case(TIME_GRID):
    	fprintf(stdout,"INFO: DIVIDE SOURCE INTO SET OF ADJACENT GRIDS.\n");
    	fprintf(stdout,"INFO: A GRID SHOWS WINDOWS OF SOURCE, AT ORIGINAL TIMES, SEPARATED BY SILENCE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NUMBER OF GRIDS: number of grids into which source is to be partitioned.\n");
		fprintf(stdout,"INFO: WIDTH OF GRID WINDOWS: size of grid windows, in seconds.\n");
		fprintf(stdout,"INFO: SPLICE LENGTH: length of splices, in milliseconds.\n");
		break;
	case(SEQUENCER):
    	fprintf(stdout,"INFO: PRODUCE SEQUENCE OF INPUT SOUND PLAYED AT TRANSPOSITIONS & TIMES SPECIFIED.\n");
 		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEQUENCE VALUES IN FILE\n");
		fprintf(stdout,"INFO: Required data is a textfile containing TIME : TRANSPOSITION : LEVEL triples.\n");
		fprintf(stdout,"INFO: Transpositions are (+ve or -ve) semitone shifts.\n");
		fprintf(stdout,"INFO: Level values multiple the original event's level.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ATTENUATION: to reduce level, should sequencing overload.\n");
		break;
	case(SEQUENCER2):
    	fprintf(stdout,"INFO: PRODUCE SEQUENCE OF SEVERAL INPUT SOUNDS PLAYED AT TRANSPOSITIONS & TIMES SPECIFIED.\n");
 		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) SEQUENCE VALUES IN FILE : Required data is a textfile containing ......\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:          On the FIRST line:   The (MIDI) pitch of each input file.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:          On ALL OTHER lines:  A set of Five values for each event in ther output...\n");
		fprintf(stdout,"INFO:              a) Input Sound Number.\n");
		fprintf(stdout,"INFO:              b) Time (secs).             (times must be in increasing order).\n");
		fprintf(stdout,"INFO:              c) MIDI pitch.\n");
		fprintf(stdout,"INFO:              d) Loudness                      (a multiplier).\n");
		fprintf(stdout,"INFO:              e) Duration                      (if [transposed]-source is shorter than 'Duration'.\n");
		fprintf(stdout,"INFO:                                                              sound duration cannot be extended)\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 2) ATTENUATION: to reduce level, should sequencing overload.\n");
		fprintf(stdout,"INFO: 2) SPLICE (MS): to cut short events, if they are too long.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(CONVOLVE):
    	fprintf(stdout,"INFO: CONVOLVE THE FIRST SOUND WITH THE SECOND.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: Each sample of the first sound is multiplied by each sample of the 2nd.\n");
 		fprintf(stdout,"INFO: Typically, the 2nd sound is a loud all-frequency sound (e.g. a gunshot)\n");
 		fprintf(stdout,"INFO: in a reverberant space. Convolution imposes the reverberant characteristics\n");
 		fprintf(stdout,"INFO: of that space onto the first sound.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: The second (convolving) sound must not be longer than the first (convolved) sound.\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: This process is very slow!!.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
  		fprintf(stdout,"INFO: NORMAL.\n");
  		fprintf(stdout,"INFO: TIME_VARYING.....convolving file can be transposed in a time-varying way.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS (TIME_VARYING MODE ONLY) ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEMITONE TRANSPOSITION OF CONVOLVING FILE....may vary through time.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(BAKTOBAK):
    	fprintf(stdout,"INFO: JOIN A TIME-REVERSED COPY OF THE SOUND, TO A NORMAL COPY, IN THAT ORDER.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME OF JOIN  Time in src file where join-cut is to be made.\n");
		fprintf(stdout,"INFO: SPLICE LENGTH (MS) Length of the splice, in milliseconds.\n");
		break;
	case(ADDTOMIX):
    	fprintf(stdout,"INFO: ADD SOUNDFILES TO AN EXISTING MIXFILE.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: SOUNDFILES ARE ADDED, (AT MAX LEVEL AND TIME ZERO), TO FOOT OF AN EXISTING MIXFILE.\n");
 		fprintf(stdout,"INFO: \n");
		break;
	case(MIX_PAN):
    	fprintf(stdout,"INFO: PAN ENTRIES IN A MIXFILE.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: SOUNDFILES ARE PLACED AT POSITIONS SPECIFIED BY A PAN VALUE,\n");
 		fprintf(stdout,"INFO: or BY VALUES READ FROM A TIME-VARYING BRKPOINT FILE.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: THE SOUNDS THEMSELVES DO NOT PAN.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: IF THERE IS ANY STEREO FILE IN THE ORIGINAL MIX,\n");
 		fprintf(stdout,"INFO: WHEN THE RESULTING MIX IS USED TO GENERATE SOUND OUTPUT\n");
 		fprintf(stdout,"INFO: THAT STEREO FILE WILL BE MERGED TO A MONO STREAM,\n");
 		fprintf(stdout,"INFO: AND THAT STREAM POSITIONED IN THE STEREO SPACE OF THE OUTPUT.\n");
		break;
	case(SHUDDER):
    	fprintf(stdout,"INFO: SHUDDER\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PRODUCE (RANDOMISED) TREMULATIONS ON STEREO FILE\n");
 		fprintf(stdout,"INFO: WHICH CAN BE SPREAD OVER THE STEREO STAGE\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START_TIME of the Shuddering.\n");
		fprintf(stdout,"INFO: FREQUENCY  of the Shuddering.\n");
		fprintf(stdout,"INFO: RANDOMISATION of the Shuddering. (0 - 1)\n");
		fprintf(stdout,"INFO: SPATIAL_SPREAD of the Shuddering. (0 - 1)\n");
		fprintf(stdout,"INFO: LOUDNESS DEPTH (MIN & MAX) of the Shuddering. (0 - 1)\n");
		fprintf(stdout,"INFO: EVENT WIDTH (MIN & MAX), in seconds, of the Shudder events.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: BALACE CHANNEL LEVELS, Boost overall level of quieter channel,\n");
		fprintf(stdout,"INFO:         if peak level more than 1dB lower than peak level of other channel.\n");
		break;
	case(MIX_AT_STEP):
    	fprintf(stdout,"INFO: CREATE MIXFILE FROM TWO OR MORE SOUNDS, WITH GIVEN TIME STEP BETWEEN ENTRIES\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: TIME STEP between entry of the sounds.\n");
		break;
	case(FIND_PANPOS):
    	fprintf(stdout,"INFO: FIND PAN POSITION OF SOUND IN STEREO IMAGE\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: AT TIME : Time in file at which to assess stereo position.\n");
 		fprintf(stdout,"INFO: N.B. IF TIME IS SET TO ZERO, the process assesses the ENTIRE FILE.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: The process only works with Stereo files.\n");
 		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: This process assumes that (approx) the SAME sound is present in both the Left & Right channels.\n");
		fprintf(stdout,"INFO: This will be the case if the stereo file is the result of panning a previously mono sound source.\n");
		break;
	case(CLICK):
    	fprintf(stdout,"INFO: GENERATE A SEQUENCE OF CLICKS\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: TAKES DATAFILE CONTAINING SEQUENCE OF DATA LINES -------------------\n");
 		fprintf(stdout,"INFO: EACH DATA LINE HAS A LINE NUMBER followed by 3 or 4 DATA ITEMS, separated by spaces, EITHER in the form...\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: GP  0  27.3          for a general pause of 27.3 secs.\n");
 		fprintf(stdout,"INFO: GP  1  18.7          for a general pause of 18.7 secs. with an accent at start.\n");
 		fprintf(stdout,"INFO: TIME  123.5          Set the absolute time to 123.5 (time must be LATER than previous event).\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: OR the following set of items.....\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: 1) TEMPO     :  in form....(with no spaces around '=')\n");
 		fprintf(stdout,"INFO:          1=144                 (for crotchet = 144)      2=75.3         (for minim = 75.3)\n");
 		fprintf(stdout,"INFO:          0.5=180             (for quaver = 180)        1.5=100       (for dotted crotchet = 100)\n");
 		fprintf(stdout,"INFO:          1=144.3to89.5   (for tempo change from crotchet = 144.3 to crotchet = 89.5)\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO:          A SINGLE DOT ('.') can be used to indicate 'same tempo', BUT not after a changing tempo\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: 2) BARRING :  in form    4:4    or    6:8    or    7:16    etc. (no spaces around ':')\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO:          A SINGLE DOT ('.') can be used to indicate 'same barring', BUT only after barring has been established.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: 3) COUNT     :  i.e. number of bars in this format.\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: ----------------------- and optionally -----------------------\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: 4) ACCENTS :  in one of the forms....(no spaces within the pattern)\n");
 		fprintf(stdout,"INFO:                           1.....          strong beat followed by 5 weak beats\n");
 		fprintf(stdout,"INFO:                           1..1..         strong beat (start) and secondary beat (at 4) with weak beats between\n");
 		fprintf(stdout,"INFO:                           100100      strong beat and secondary beat, with NO intermediate beats\n");
 		fprintf(stdout,"INFO:                           ETC.\n");
		fprintf(stdout,"INFO: IF ACCENT PATTERN OMITTED, default patterns used. These are....\n");
		fprintf(stdout,"INFO: An accent on start of each bar, plus....\n");
		fprintf(stdout,"INFO: a) in 6:8, 9:8, 12:8, 15:8 etc, or 6:4, 6:16, 6:32 or 9:4, 9:16 etc.\n");
		fprintf(stdout,"INFO:           Sound on every specified unit (4,8,16,32 etc.) with Secondary accents every 3rd beat.\n");
		fprintf(stdout,"INFO: b) in all other meters,\n");
		fprintf(stdout,"INFO:           Sound on every specified unit (4,8,16,32 etc.), but NO secondary accents\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: ----------------------- also -----------------------\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: comments preceded by ';' can be used e.g.  ;Section 1\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: OTHER PARAMETERS-----------------------------------------------------\n");
 		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                                            IN MODE 'FROM TIME'\n");
 		fprintf(stdout,"INFO: MAKE CLICK FROM TIME ..... Generate clicktrack, beginning at score time given here.\n");
 		fprintf(stdout,"INFO:                            If time is given as ZERO, output will include any clicks prior to music zero.\n");
 		fprintf(stdout,"INFO: MAKE CLICK TO TIME ......... Generate clicktrack, ending at score time given here.\n");
 		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                                            IN MODE 'FROM LINE'\n");
 		fprintf(stdout,"INFO: MAKE CLICK FROM DATA LINE ..... Generate clicktrack, beginning at data line.\n");
 		fprintf(stdout,"INFO: MAKE CLICK TO DATA LINE ......... Generate clicktrack, ending at data line.\n");
 		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO:                                                   IN ALL MODES\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: MUSIC STARTS AT LINE...........Usually clicks will begin BEFORE the true start of the music,\n");
 		fprintf(stdout,"INFO:                                      and in this case music-zero-time will come AFTER the start of the clicks.\n");
 		fprintf(stdout,"INFO:                        This parameter allows you to specify at which line in the data the music itself begins.\n");
 		fprintf(stdout,"INFO: SHOW LINE TIMES ..... Running display of times at which each data line begins (relative to music zero).\n");
		break;
	case(DOUBLETS):
    	fprintf(stdout,"INFO: SLICE UP SOUND, REPEATING SLICED SEGMENTS\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: SEGMENTATION LENGTH .... duration of sliced segments.\n");
 		fprintf(stdout,"INFO: SEGMENT REPEATS .............. number of times each segment is repeated.\n");
 		fprintf(stdout,"INFO: RETAIN ORIGINAL DURATION ...step through file fast enough to keep up with time in source file.\n");
		break;
	case(SYLLABS):
    	fprintf(stdout,"INFO: SLICE TEXT INTO ITS CONTIGUOUS SYLLABLES\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS----------------------------------------------------------\n");
 		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: SYLLABLE TIMES .... List of syllable starttimes, plus endtime of last syllable.\n");
 		fprintf(stdout,"INFO: DOVETAIL ...........Time (MS) allowed for syllable overlap.\n");
 		fprintf(stdout,"INFO: SPLICELENGTH .......Duration (MS) of editing splices.\n");
 		fprintf(stdout,"INFO: IN PAIRS .......Cut all syllable-pairs (default, cut individual syllables).\n");
		break;
	case(JOIN_SEQ):
		fprintf(stdout,"INFO: JOIN FILES TOGETHER, ONE AFTER ANOTHER, IN A GIVEN PATTERN\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PATTERN.......File numbers, in the sequence in which they are to be joined.\n");
		fprintf(stdout,"INFO: SPLICE........duration of splices, in MS (default 15)\n");
		fprintf(stdout,"INFO: SPLICE START..splices start of first file.\n");
		fprintf(stdout,"INFO: SPLICE END....splices end of last file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(JOIN_SEQDYN):
		fprintf(stdout,"INFO: JOIN FILES TOGETHER, ONE AFTER ANOTHER, IN A GIVEN PATTERN, WITH A LOUDNESS PATTERNING\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PATTERN.......File numbers, in the sequence in which they are to be joined.\n");
		fprintf(stdout,"INFO: .....................each followed by the relative loudness of that pattern item.\n");
		fprintf(stdout,"INFO: SPLICE........duration of splices, in MS (default 15)\n");
		fprintf(stdout,"INFO: SPLICE START..splices start of first file.\n");
		fprintf(stdout,"INFO: SPLICE END....splices end of last file.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MAKE_VFILT):
		fprintf(stdout,"INFO: CONVERT EACH VALUE IN A LIST OF MIDI VALUES IN A TEXTFILE\n");
		fprintf(stdout,"INFO: TO A FIXED-PITCH FILTER-DATA-FILE FOR THE VARI-FILTER\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(BATCH_EXPAND):
		fprintf(stdout,"INFO: USE EXISTING BATCHFILE AS A MODEL TO WORK ON OTHER SOUNDFILES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MODES---------------------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
  		fprintf(stdout,"INFO: 1) ONE PARAM.\n");
		fprintf(stdout,"INFO:       a) EXISTING BATCHFILE MUST OPERATE ON A SINGLE SOUNDFILE.\n");
		fprintf(stdout,"INFO:       b) PARAMETER TO BE REPLACED MUST BE SAME VALUE FOR EACH BATCHFILE LINE.\n");
		fprintf(stdout,"INFO:  SAME SEQUENCE OF OPERATIONS APPLIED TO EACH IN-SNDFILE USING EACH NEW PARAM IN TURN\n");
		fprintf(stdout,"INFO: e.g. Batchfile\n");
		fprintf(stdout,"INFO: filter varibank 2 in1.wav in1_a  filt0.txt 10 2 14 -h36 -r0.0 -d\n");
		fprintf(stdout,"INFO: filter varibank 2 in1.wav in1_b  filt1.txt 20 2 14 -h38 -r0.0 -d\n");
		fprintf(stdout,"INFO: filter varibank 2 in1.wav in1_c  filt2.txt 30 2 14 -h40 -r0.0 -d\n");
		fprintf(stdout,"INFO: with sndlist and datafile entries \n");
		fprintf(stdout,"INFO:       ex2.wav            22\n");
		fprintf(stdout,"INFO:       ff3.wav            99\n");
		fprintf(stdout,"INFO: and parameter column 9: gives\n");
		fprintf(stdout,"INFO: filter varibank 2 ex2.wav ex2_b0 filt0.txt 10 2 22 -h36 -r0.0 -d\n");
		fprintf(stdout,"INFO: filter varibank 2 ex2.wav ex2_b1 filt1.txt 20 2 22 -h38 -r0.0 -d\n");
		fprintf(stdout,"INFO: filter varibank 2 ex2.wav ex2_b2 filt2.txt 30 2 22 -h40 -r0.0 -d\n");
		fprintf(stdout,"INFO: filter varibank 2 ff3.wav in1_b0 filt0.txt 10 2 99 -h36 -r0.0 -d\n");
		fprintf(stdout,"INFO: filter varibank 2 ff3.wav in1_b1 filt1.txt 20 2 99 -h38 -r0.0 -d\n");
		fprintf(stdout,"INFO: filter varibank 2 ff3.wav in1_b2 filt2.txt 30 2 99 -h40 -r0.0 -d\n");
		fprintf(stdout,"INFO: \n");
  		fprintf(stdout,"INFO: 2) MANY PARAMS.\n");
		fprintf(stdout,"INFO:       a) EXISTING BATCHFILE CAN OPERATE ON DIFFERENT SOUNDFILES.\n");
		fprintf(stdout,"INFO:       b) SOUNDFILES IN ORIG BATCHFILE REPLACED BY CHOSEN FILES, AND USING NEW PARAMS.\n");
		fprintf(stdout,"INFO:             TAKING EACH LINE IN TURN.\n");
		fprintf(stdout,"INFO: e.g. Batchfile\n");
		fprintf(stdout,"INFO: filter varibank 2 in1.wav in1_a filt0.txt 10 2 14 -h36 -r0.0 -d\n");
		fprintf(stdout,"INFO: filter varibank 2 in0.wav in0_b filt1.txt 20 2 17 -h38 -r0.0 -d\n");
		fprintf(stdout,"INFO: filter varibank 2 in7.wav in7_c filt2.txt 30 2 11 -h40 -r0.0 -d\n");
		fprintf(stdout,"INFO: e.g. and same Params as above, gives...\n");
		fprintf(stdout,"INFO: filter varibank 2 ex2.wav ex2_b filt0.txt 10 2 22 -h36 -r0.0 -d\n");
		fprintf(stdout,"INFO: filter varibank 2 ff3.wav ff3_b filt1.txt 20 2 99 -h38 -r0.0 -d\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: COLUMN NUMBER OF INFILE, IN BATCHFILE.\n");
		fprintf(stdout,"INFO: COLUMN NUMBER OF OUTFILE, IN BATCHFILE.\n");
		fprintf(stdout,"INFO: COLUMN NUMBER OF PARAM TO BE REPLACED, IN BATCHFILE.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(MIX_MODEL):
		fprintf(stdout,"INFO: SUBSTITUTE NEW SOUNDFILES IN EXISTING MIXFILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1st FILE MUST BE AN EXISTING MIXFILE.\n");
		fprintf(stdout,"INFO: OTHER FILES ARE SOUNDFILES.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: THERE MUST BE ONE SOUNDFILE FOR EACH MIXFILE LINE.\n");
		fprintf(stdout,"INFO: CHANNEL-CNT OF SOUND MUST CORRESPOND TO CHANNEL-CNT ON CORERSPONDING MIXFILE LINE.\n");
		break;
	case(CYCINBETWEEN):
		fprintf(stdout,"INFO: CREATE NEW FILES INTERMEDIATE BETWEEN 2 GIVEN FILES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: FILES ARE INTERPOLATED, ATTEMPTING TO KEEP ZER-CROSSINGS PEGGED.\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NUMBER OF INTERMEDIATE FILES.\n");
		fprintf(stdout,"INFO: HIGH FREQUENCY CUTOFF.\n");
		break;
	case(ENVSYN):
		fprintf(stdout,"INFO: CREATE ENVELOPE WITH REPEATING PATTERN, IN BINARY ENVELOPE FILE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW SIZE ....is the resolution of the envelope (smaller window gives finer resolution) .\n");
		fprintf(stdout,"INFO: .........................Window size is in MILLIseconds.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION OF OUTFILE.......The duration (in secs) of the file you want to generate.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: DURATION OF REPEATING UNIT......Duration (in secs) of the repeating units. This can vary over time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START POINT WITHIN FIRST UNIT......0 starts at beginning of unit, 1 at the very end.\n");
		fprintf(stdout,"INFO: ......................................values in between start within the unit.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: HEIGHT OF ENVELOPE TROUGH......Lowest value reached by the envelope units (can vary over time).\n");
		fprintf(stdout,"INFO: ........................................(Does not apply to USER DEFINED envelopes).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: EXPONENT OF ENVELOPE RISE OR DECAY......can vary over time.(Does not apply to USER DEFINED envelopes).\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: in USER-DEFINED MODE\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Required data is a textfile of time/val(0-1) pairs defining an envelope, where time units are arbitrary\n");
		fprintf(stdout,"INFO: as the envelope is stretched to each unit duration.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(P_BINTOBRK):
		fprintf(stdout,"INFO: CONVERT BINARY PITCH DATA TO PITCH DATA TEXTFILE.\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: Pitch data is written to textfile as frequency values.\n");
		break;
	case(RRRR_EXTEND):
		fprintf(stdout,"INFO: EXTEND ITERATIVE SOUNDS.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ATTEMPT TO 'TIME-STRETCH' NATURAL ITERATIVE SOUNDS (LIKE ROLLED 'rrr' IN SPEECH) IN A PLAUSIBLE WAY.\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS IN MODE 1 ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: START OF SECTION TO BE EXTENDED ................ time of start of the iterated material in the source.\n");
		fprintf(stdout,"INFO: END OF SECTION TO BE EXTENDED ................... time of end of the iterated material in the source.\n");
		fprintf(stdout,"INFO: ANTICIPATED NO OF SEGMENTS TO FIND IN SRC... Estimate how many iterations you hear in marked area.\n");
		fprintf(stdout,"INFO: APPROX RANGE OF ITERATIVE SOUND (OCTAVES)\n");
		fprintf(stdout,"INFO:                      A guesstimate of the pitch-range of the iteration\n");
		fprintf(stdout,"INFO:                      This is the pitch range of the (low_frq) iteration, and NOT the resonant frequency.\n");
		fprintf(stdout,"INFO:                      e.g. for a rolled 'rrr' it is the frq of the 'rrr' itself (even if unvoiced)\n");
		fprintf(stdout,"INFO:                      and not the pitch of any sung note (if the 'rrr' is voiced).\n");
		fprintf(stdout,"INFO: TIMESTRETCH OF SECTION ........................... How much to time-stretch the marked material.\n");
		fprintf(stdout,"INFO: MAX ADJACENT OCCURENCES OF ANY SEG IN OUTPUT\n");
		fprintf(stdout,"INFO:                      The iterated material is extended by reusing the individual segments in a randomised pattern.\n");
		fprintf(stdout,"INFO:                      In this pattern, segment A may occur next to an identical copy of segment A, or not.\n");
		fprintf(stdout,"INFO:                      This parameter specifies how many adjacent copies of any segment you are prepared to allow.\n");
		fprintf(stdout,"INFO: AMPLITUDE SCATTER\n");
		fprintf(stdout,"INFO:                      The iterated segments may vary in amplitude.\n");
		fprintf(stdout,"INFO:                      0 retains original amplitude: N produces random amplitudes between orig and (1-N) * orig.\n");
		fprintf(stdout,"INFO: PITCH SCATTER\n");
		fprintf(stdout,"INFO:                      The iterated segments may vary in pitch.\n");;
		fprintf(stdout,"INFO:                      0 retains original pitch: N produces random pitchshift between N and -N semitones.\n");
		fprintf(stdout,"INFO: KEEP EXTENDED ITERATE ONLY....................... If flag is set, rest of file is not retained.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS MODE 2 ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IN THIS MODE THE PROCESS ATTEMPTS TO LOCATE THE (FIRST) OCCURENCE OF THE ITERATIVE.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: Hence there is no 'START..' or 'END OF SECTION TO BE EXTENDED'\n");
		fprintf(stdout,"INFO: and 'ANTICIPATED NO OF SEGMENTS TO FIND' is replaced by ...\n");
		fprintf(stdout,"INFO:           MINUMUM NO OF SEGMENTS TO FIND\n");
		fprintf(stdout,"INFO:           APPROX SIZE OF GRANULE_(MS) and\n");
		fprintf(stdout,"INFO:           GATE LEVEL BELOW WHICH SIGNAL ENVELOPE IGNORED\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: You can also cause the time-stretched iterate to ritardando to a specified speed, using...\n");
		fprintf(stdout,"INFO: TIME IN EXTENDED ITERATIVE BEFORE RITARNDO\n");
		fprintf(stdout,"INFO: EVENT SEPARATION IN FULLY SLOWED ITERATIVE and\n");
		fprintf(stdout,"INFO: TIME IN EXTENDED ITERATIVE WHERE RIT ENDS\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: And.....\n");
		fprintf(stdout,"INFO: NUMBER OF ITERATED ITEMS TO SKIP BEFORE USING ITEMS TO CREATE OUTPUT.\n");
		fprintf(stdout,"INFO: allows you to play through first N iterate-items before using the ensuing material for time-extension.\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: IN MODE 3 ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PROCESS EDITS THE SOUND INTO ITS START, THE ITERATE-UNITS AND THE END\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(SSSS_EXTEND):
		fprintf(stdout,"INFO: FIND AND TIME-STRETCH (FIRST) NOISE COMPONENT IN A SOUND.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: OUTPUT DURATION............................. Duration of output file.\n");
		fprintf(stdout,"INFO: MIN FRQ (HZ) JUDGED TO REPRESENT NOISE ..... Lowest signal 'frequency' (Hz) viewed as noise.\n");
		fprintf(stdout,"INFO: MINIMUM NOISE DURATION (MS)................. Minimum acceptable duration of usable block of noise in source signal.\n");
		fprintf(stdout,"INFO: MAXIMUM NOISE DURATION (SECS)............... Maximum acceptable duration of usable block of noise in source signal.\n");
		fprintf(stdout,"INFO: KEEP EXTENDED NOISE ONLY.................... Kepp ONLY the extended noise: Otherwise, keep whole src with extended noise.\n");
		break;
	case(HOUSE_GATE2):
		fprintf(stdout,"INFO: SUPPRESS GLITCHES\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: THIS PROGRAM ATTEMPTS TO CUT SHORT GLITCHES OUT OF SOUNDS.\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: MAX GLITCH DURATION (MS) .... maximum duration of event recognisable as a glitch.\n");
		fprintf(stdout,"INFO: MIN GLITCH SEPARATION (MS) ...minimum time signal must fall below threshold on either side of glitch.\n");
		fprintf(stdout,"INFO: GATING LEVEL AT GLITCH EDGE...maxmimum signal level at edges of glitch.\n");
		fprintf(stdout,"INFO: SPLICE LENGTH (MS).............must be less than half the minimum glitch-separation.\n");
		fprintf(stdout,"INFO: SEARCH WINDOW (MS).............size of window where average signal level is calculated.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: SEE DETAILS...................If selected,will list size and position of each (possible) glitch found.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: 1) Zero-length splices can be used if Gating-level is set to 0. In other cases they will produce clicks.\n");
		fprintf(stdout,"INFO: 2) Use larger windows to remove larger features.\n");
		fprintf(stdout,"INFO: 3) Very short windows may mistake parts of the waveform for 'silence' and also miss larger features.\n");
		break;
	case(GRAIN_ASSESS):
		fprintf(stdout,"INFO: ASSESS GATE LEVEL TO RETRIEVE MAXIMUM NUMBER OF GRAINS IN A SOUND.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(ZCROSS_RATIO):
		fprintf(stdout,"INFO: FIND PROPORTION OF ZERO CROSSINGS IN FILE BETWEEN SPECIFIED TIMES.\n");
		fprintf(stdout,"INFO: \n");
		break;
	case(GREV):
		fprintf(stdout,"INFO: LOCATE AND MANIPULATE 'GRAINS', USING ENVELOPE TROUGHS AND ZERO-CROSSING.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: This process locates elements of a sound by searching for troughs in the envelope.\n");
		fprintf(stdout,"INFO: It does not need a clear attack to recognise a 'grain' in a sound, and is\n");
		fprintf(stdout,"INFO: more appropriate for e.g. separating syllables in speech.\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: MODES ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
 		fprintf(stdout,"INFO: REVERSE ....... Reverse the order of the (grouped) grains.\n");
		fprintf(stdout,"INFO: REPEAT ......... Repeat each of the (grouped) grains.\n");
		fprintf(stdout,"INFO: DELETE ......... Delete a proportion of the (grouped) grains.\n");
		fprintf(stdout,"INFO: OMIT ............. Replace a proportion of the (grouped) grains with silence.\n");
		fprintf(stdout,"INFO: TIME STRETCH .. Time stretch the output, without timestretching the grains.\n");
		fprintf(stdout,"INFO: GET ..................... Get the times of the grains to a textfile.\n");
		fprintf(stdout,"INFO: PUT ..................... Reposition grains at times suppied in textfile.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: PARAMETERS ----------------------------------------------------\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ENVELOPE WINDOW SIZE (MS) .... This determines vthe size of grains that might be found..\n");
		fprintf(stdout,"INFO: DEPTH OF TROUGHS AS PROPORTION OF PEAK HEIGHT .... ee,g, with value .5, troughs between peaks\n");
		fprintf(stdout,"INFO:                    which do not fall to half the peak-height, are ignored\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IN TIME STRETCH MODE -----------.\n");    
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ........ TIME STRETCH RATIO (which may be greater [slow down] or less [speed up] than 1, and may vary over time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IN ALL OTHER MODES -----------.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ........ NO OF GRAINS GROUPED AS ONE UNIT ... operations are carried out on the unit,\n");
		fprintf(stdout,"INFO:                    which might be single grains, and may vary over time\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IN DELETE & OMIT MODES -----------.\n");    
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NO OF UNITS TO KEEP | OUT OF ......... e.g. keep 3 out of 7\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IN REPEAT MODE -----------.\n");    
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: NO OF UNIT REPETITIONS ............. Number of times each unit is repeated, which can vary over time.\n");
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: IN PUT  MODE-----------.\n");    
		fprintf(stdout,"INFO: \n");
		fprintf(stdout,"INFO: ........ GRAIN-TIMINGS is a textfile of the times where the grains are to be repositioned.\n");
		fprintf(stdout,"INFO: \n");
		break;
	default:
		fprintf(stdout,"ERROR: Unknown PROCESS\n");
		fprintf(stdout,"INFO: \n");
		break;
	}
	return 0;
}


